#!/bin/bash

ebashs_version='0.9.2'

### BUFFERMAKER START

#!/bin/bash
buffermaker_version="0.10.4.1-ebashs-internal"
log_buffer+=('' 'START')
## Buffermaker
# Pure bash tui framework (wip)

shopt -s lastpipe # For syntax highlighting
shopt -s extglob # Ensure advanced pattern matching is available
shopt -s checkwinsize && (:;:) # Enable and then trigger a terminal size refresh

declare -r DEFIFS="$IFS"
declare -A highlight faces faces_raw options charmap alias descriptions
declare -A menulineedit diredmenu menulinedebug
declare -A menufancy
declare -A keys_def keys_global
declare -a k_hex buffers_l log_buffer extensions modes=('keys_global')
declare -n buffer bf_s bf_e bf_d
declare -i menuloc_x menuloc_y toplines bottomlines hidden ismenu comment current_count _isdone
declare -n menucon
declare message reset readin

function load-default-config {
	## Configuration
	#		The magic :: function
	#			:: sets value to option depending on current context:
	#				set-options → define-options() → ass. array options
	#				global-set → global-set-key → define-key global → as. ar. keys_global
	#				add-mode → local-set-key → define-key <keys> → a. a. keys_<keys>
	#					mode-options → local-set-mode-option → define-mode-option → a. a. key_options_<keys>
	#				set-alias → add-alias → a. a. alias
	#				add-menu → local-set-menu → define-menu <menu> → menu_<menu>_0 & menu_<menu>_1
	#				set-highlight → add-highlight → a. a. highlight
					  
	options=(
		[mouse]=0
		[todonote]=0
		[menu-line]=0
		[mode-line]=0
		[command-line]=0 # note that disabling this means that any message will instead be draw on top of buffer
		[line-number-mode]=0
		[empty-line-char]=''
		[tabchar]='    '
		[keep-message]=0
		[log]=0
		[log-functions]=0
		[tty-linuxfb]=1 # enable truecolor support for framebuffer
		[full-redraw]=0 # redraws whole buffer, can fix artifacting in linuxfb at cost of performance
		[esc-to-meta]=0
	)
		
	## Key bindings configuration
	#		A keybinding is defined via either
	#		global-set; :: ... ... or add-mode <mode>; :: ... ...
	#		:: <key> <command>
	#			<key> is defined either via
	#				Hexadecimal format (with ' 0' added as suffix).
	#				Name of key like '[<key>]'
	#				Emacsy "$(kbd <key> )" (<key> being something like C-s M-e ...)
	#			The name of key and $(kbd) get translated into hex. format on startup.
	#
	#			mode-options sets magic :: to defining mode options
	#			:: option value

	add-mode empty
		mode-options
			:: else :
			:: disable-global 1
	
	## Faces
	#		Defined in escape codes
	#		Helper functions:
	#			:weight
	#				normal
	#				bold
	#			:slant
	#				normal
	#				italic
	#			:background & :foreground
	#				either hex. colour, colour name, or c<index> for 256 indexed colours
	#		See extensions/gruvboxdark for another example
default_faces=(
		reset '\e[m'
		default "$(:weight normal)"
		menu "$(:mode inverse)"
		menu-highlight '\e[7;30;43m'
		menu-back '\e[4m\e[1m'
		menu-enabled-face  "$(:mode inverse)"
		menu-selected-face "$(:foreground yellow :mode inverse :weight bold)"
		button "$(:foreground light-cyan)"
		link '\e[4;96m'
		link-highlight '\e[1;4;96m'
		title "$(:weight bold)"
		highlight "$(:weight bold :foreground light-red)"
		dim "$(:weight dim)"
		name "$(:foreground magenta)"
		hint "$(:foreground light-yellow)"
		hint-highlight '\e[4;93m'
		line-number "$(:foreground gray)"
		line-number-empty "$(:weight dim :foreground gray)"
		line-number-current-line "$(:weight bold :foreground light-red)"
		tab-face "$(:weight dim :foreground gray)"
		region "$(:weight bold :background gray)"
		minibuffer-prompt "$(:weight normal)"
		#
		TODO "$(:background magenta)"
		NOTE "$(:background gray)"
		mode-line "$(:mode inverse)"
		file-name "$(:weight bold)"
		# common colors for format stuff
		black      '\e[30m' gray          '\e[90m'
		red        '\e[31m' light-red     '\e[91m'
		green      '\e[32m' light-green   '\e[92m'
		yellow     '\e[33m' light-yellow  '\e[93m'
		blue       '\e[34m' light-blue    '\e[94m'
		magenta    '\e[35m' light-magenta '\e[95m'
		cyan       '\e[36m' light-cyan    '\e[96m'
		light-gray '\e[37m' white         '\e[97m'

		bg-black      '\e[40m' bg-gray          '\e[100m'
		bg-red        '\e[41m' bg-light-red     '\e[101m'
		bg-green      '\e[42m' bg-light-green   '\e[102m'
		bg-yellow     '\e[43m' bg-light-yellow  '\e[103m'
		bg-blue       '\e[44m' bg-light-blue    '\e[104m'
		bg-magenta    '\e[45m' bg-light-magenta '\e[105m'
		bg-cyan       '\e[46m' bg-light-cyan    '\e[106m'
		bg-light-gray '\e[47m' bg-white         '\e[107m'
)
	load-theme default_faces
}

## syntaxy sugar sugary syntax
log_buffer+=('- LOADING BASH EXTENSIONS -')
function @ifs { IFS="$DEFIFS"; }
	
# Make bash not be bashy enough
function @doc {
	mapfile -t "description_${desc_count}"
	descriptions["function_${1}_description"]="description_${desc_count}"
	((desc_count++))
}

# reverse of defun :D
function nufed {
	((_addfragment==1)) && {
		@add '='
		_addfragment=0
	}
	IFS=
	local -a fn
	local deffn="function $_function"$'\n'
	mapfile fn <<<"$(declare -f '=')"
	for ((i=1; i<${#fn[@]}; i++)) {
		deffn+="${fn[i]}"
	}
	eval "$deffn"
	_isdone=0
	@ifs
	unset '='
}
	
	
@doc copy-function <<'+'
copies function \$1 to function \$2
advantage of copying instead of creating wrapper alias functions should be in theory performance(?)

Little test script:
    1() {
    	echo hi > /dev/null
    }
    echo 1
    time for e in {0..100000}; do
    	1
    done
    
    2() {
    	1
    }
    echo 2
    time for e in {0..100000}; do
    	2
    done
    
    3() {
    	2
    }
    echo 3
    time for e in {0..100000}; do
    	3
    done
    
    4() {
    	3
    }
    echo 4
    time for e in {0..100000}; do
    	4
    done

output:
    1
    
    real	0m1,636s
    user	0m1,081s
    sys	0m0,540s
    2
    
    real	0m1,986s
    user	0m1,453s
    sys	0m0,518s
    3
    
    real	0m2,380s
    user	0m1,873s
    sys	0m0,491s
    4
    
    real	0m2,768s
    user	0m2,154s
    sys	0m0,595s

It seems like there's small performace gain.
+
function copy-function {
	local -a fn
	local deffn="function $2"$'\n'
	mapfile fn <<<"$(declare -f "$1")"
	for ((i=1; i<${#fn[@]}; i++)) {
		deffn+="${fn[i]}"
	}
	eval "$deffn"
}

function defun {
	if [ -z "$1" ]; then
		nufed
	else
		((desc_count++))
		log_buffer+=("    DEFUN: $1")
		((_isdone)) && nufed
		_addfragment="${_pass_addfragment}"
		descriptions["function_${1}_description"]="description_${desc_count}"
		_function="$1"
		_isdone=1
		_last_add=add-doc
	fi
}

function ::
case "$_last_add" in
	add-menu) local-set-menu "$@";;
	set-alias) add-alias "$@";;
	set-highlight) add-highlight "$@";;
	global-set) global-set-key "$@";;
	set-options) define-option "$@";;
	add-doc) add-doc "$@";;
	add-mode) local-set-key "$@";;
	mode-options) local-set-mode-option "$@";;
	set-buffer) local-set-buffer-data "$@"
esac

function add-doc {
	local -n cdoc="description_${desc_count}"
	cdoc+=("${_indent}$*")
}
function doc {
	((desc_count++))
	descriptions["function_${1}_description"]="description_${desc_count}"
	_function="$1"
	_last_add=add-doc
	_indent=''
	shift
	[ -n "$*" ] &&
		:: "$*"
}
copy-function doc @@

## :+ Add documentation indent
function :+ {
	_indent+="    "
	# "$*"
}
## :- Remove documentation indent
function :- {
	_indent="${_indent:0:${#_indent}-4}"
	# "$*"
}
# hell

## focus set magic # function
function focus {
	_last_add="$1"
}

## declare-new-buffer Create new text buffer
function declare-new-buffer {
	_last_add='set-buffer'
	((current_count++))
	set-buffer "bf_${current_count}"
	buffers_l+=("$current_buffer")
	last_line=1
	declare -Ag "${current_buffer}_bf_d"
	bf_d=(
		# some sane default values
		[line]=0
		[base]=1
		[column]=0
		[modified]=0
	)
}

## local-set-buffer-data
# set bf_d[] array of currently \"focused\" buffer
function local-set-buffer-data {
	while [ -n "$2" ]; do
		bf_d["$1"]="$2"
		shift 2
	done
}

## [auto] Checks bf_d[] array and set\'s needed missing values automatically
function [auto] {
	[ -z "${bf_d[loc-x]}" ] && bf_d[loc-x]=1
	[ -z "${bf_d[loc-y]}" ] && bf_d[loc-y]=1
	[ -z "${bf_d[size-x]}" ] && bf_d[size-x]=$COLUMNS
	[ -z "${bf_d[size-y]}" ] && bf_d[size-y]=$((LINES - 1))
	[ -z "${bf_d[syntax]}" ] && set-syntax 
}

## defun-fragment Same as defun but includes fragments for the function
function defun-fragment {
	_pass_addfragment=1
	defun "$@"
}

# fragments act basically like macros but with cooler name
# see redraw-buffer function for example usage
## fragment Creates a function-insertable macro
function fragment {
	log_buffer+=("        FRAGMENT: $1")
	declare -ag "_fragment_$1"
	mapfile "_fragment_$1"
}
	
## @add Adds fragment to a function
function @add {
	local -a _add_fn
	local -a _add_nfn
	local -i _add_f
	local -i _add_hf
	local _add_nfnline
	mapfile _add_fn < <(declare -f -- "$1")
	IFS=' '
	for _add_l in "${!_add_fn[@]}"; {
		_add_f=0
		_add_hf=0
		_add_nfnline=
		for _add_w in ${_add_fn[_add_l]}; {
			if [ "$_add_w" = '@' ]; then
				_add_f=1
			elif ((_add_f)); then
				_add_f=0
				_add_hf=1
				local -n _add_fragment="_fragment_${_add_w//[^[:alnum:]]/}"
				for _add_l1 in "${!_add_fragment[@]}"; {
					_add_nfnline+=" ${_add_fragment[_add_l1]}"
				}
			else
				_add_nfnline+=" $_add_w"
			fi
		}
		((_add_hf)) || _add_nfn+="${_add_fn[_add_l]}"
		((_add_hf)) && _add_nfn+="$_add_nfnline"
	}
	eval "${_add_nfn[*]}"
}

## @def Defines a function template
function @def {
	local -n _tpl="_template_$1"
	local _fn
	local -i _n=0
	shift
	for _w in $_tpl; {
		case "$_w" in
			'@var')
				_n=1;;
			*)
				((_n)) && {
					_n=0
					_fn+="${!_w} "
					continue
				}
				_fn+="$_w "
		esac
	}
	eval "$_fn"
}

## _ Variable refernce helper
function _ {
	# this function is here to simplify stuff as writing overlong variables indexed by overloong variable index...
	# ...is quite tiring <3
	[ -z "$1" ] && {
		for n in "${refalias[@]}"; do
			unset "$n"
		done
		unset refalias
		return
	}
	declare -gn "$1"="$2"
	refalias+=("$1")
}

## __ Swap variable references
function __ {
	# swap two references
	local -n _swap_1="$1"
	local _swap_copy_1="${!_swap_1}"
	local -n _swap_2="$2"
	local _swap_copy_2="${!_swap_2}"
	declare -gn "$1"="${_swap_copy_2}"
	declare -gn "$2"="${_swap_copy_1}"
}

## @fn Shorthand for one line functions
function @fn {
	[ -z "$*" ] && exit 1 # error if empty
	local name="$1"
	shift
	eval "function $name { $@; }"
}

## copy-array
# A univeral function to copy both normal and associative arrays
function copy-array {
	local -n source="$1"
	local -n target="$2"
	target=()
	for idx in "${!source[@]}"; {
		target[idx]="${source[idx]}"
	}
}

## append-array
# Append array \$1 to \$2  
function append-array {
	local -n source="$1"
	local -n target="$2"
	for idx in "${!source[@]}"; {
		target+=("${source[idx]}")
	}
}

## setface Convert colors to escape codes
# '$1' can be either one of colors:
:+     black
#     red
#     green
#     yellow
#     blue
#     magenta
#     cyan
#     ligth-gray
#     gray
#     light-red
#     light-green
#     light-yellow
#     light-blue
#     light-magenta
#     light-cyan
#     white
:- 'or hex. color (like "#bb2040")'
# 'or indexed 256 color with "c" as prefix (like c127)'
# 'for background color $mode has to be 48 and for foreground 38'
::
# If \$TERM \(current "$TERM"\) is \'linux\' \& option tty-linuxfb is 1 try to use true color even for tty
# Instead of normal '\e[$mode;r;g;bm' is used '\e]P$~1mode$Hexcode\e[$~2modem'
:+     '$mode 38 → $~1mode 2 & $~2mode 32'
#     '$mode 48 → $~1mode 1 & $~2mode 41'
:- Note that the linuxfb colors are very experimental and suffer from cursor implicitly overwriting them on movenment
function setface {
	[ -z "$1" ] && return
	case "$1" in
		black)      [ "$mode" = '38' ] && printf '\\e[30m' || printf '\\e[40m';;
		red)        [ "$mode" = '38' ] && printf '\\e[31m' || printf '\\e[41m';;
		green)      [ "$mode" = '38' ] && printf '\\e[32m' || printf '\\e[42m';;
		yellow)     [ "$mode" = '38' ] && printf '\\e[33m' || printf '\\e[43m';;
		blue)       [ "$mode" = '38' ] && printf '\\e[34m' || printf '\\e[44m';;
		magenta)    [ "$mode" = '38' ] && printf '\\e[35m' || printf '\\e[45m';;
		cyan)       [ "$mode" = '38' ] && printf '\\e[36m' || printf '\\e[46m';;
		light-gray) [ "$mode" = '38' ] && printf '\\e[37m' || printf '\\e[47m';;

		gray)          [ "$mode" = '38' ] && printf '\\e[90m' || printf '\\e[100m';;
		light-red)     [ "$mode" = '38' ] && printf '\\e[91m' || printf '\\e[101m';;
		light-green)   [ "$mode" = '38' ] && printf '\\e[92m' || printf '\\e[102m';;
		light-yellow)  [ "$mode" = '38' ] && printf '\\e[93m' || printf '\\e[103m';;
		light-blue)    [ "$mode" = '38' ] && printf '\\e[94m' || printf '\\e[104m';;
		light-magenta) [ "$mode" = '38' ] && printf '\\e[95m' || printf '\\e[105m';;
		light-cyan)    [ "$mode" = '38' ] && printf '\\e[96m' || printf '\\e[106m';;
		white)         [ "$mode" = '38' ] && printf '\\e[97m' || printf '\\e[107m';;
		*) case "${1::1}" in
			   '#')
				   if [ "$TERM" = 'linux' ] && ((options[tty-linuxfb])); then # Hack for linux framebuffer tty
					   case "$mode" in
						   38) printf '\\e]P2%s\\e[32m' "${1:1:6}" ;;
						   48) printf '\\e]P1%s\\e[41m' "${1:1:6}"
					   esac
				   else
					   local r="${1:1:2}"
					   local g="${1:3:2}"
					   local b="${1:5:2}"
					   printf '\\e[%d;2;%d;%d;%dm' "${mode}" $((16#$r)) $((16#$g)) $((16#$b))
				   fi;;
			   'c')
				   printf '\\e[%d;5;%dm' "${mode}" "${1:1}"
		   esac
	esac
	shift
	[ -n "$1" ] && "$@";
}

## :foreground
# Set foreground color.
# 'See <a> doc-goto setface : <f> link setface </f> </a> for more info.'
function :foreground { mode=38; setface "$@"; }

## :background
# Set background color.
# 'See <a> doc-goto setface : <f> link setface </f> </a> for more info.'
function :background { mode=48; setface "$@"; }

## :mode Sets text mode:
# '	inverse - inverses background and foreground'
function :mode {
	case "$1" in
		inverse) printf '\\e[7m';;
	esac
	shift
	[ -n "$1" ] && "$@";
}
	
## :weight Sets thickness of text:
:+     bold
#     dim
#     normal
function :weight {
	case "$1" in
		bold) printf '\\e[1m';;
		dim) printf '\\e[2m';;
		normal) printf '\\e[m'
	esac
	shift
	[ -n "$1" ] && "$@";
}

## :slant Sets slant of text:
:+     italic
#     normal
function :slant {
	case "$1" in
		italic) printf '\\e[3m';;
		normal) printf '\\e[m'
	esac
	shift
	[ -n "$1" ] && "$@";
}
	
## kbd Converts Emacs like key notation into hex.
function kbd {
	local -i i=0
	local out
	local in
	local -i ch=1
	# Surely there is better solution...
	case "$1" in
		C-a) printf '1 0' ;; C-b) printf '2 0' ;;
		C-c) printf '3 0' ;; C-d) printf '4 0' ;;
		C-e) printf '5 0' ;; C-f) printf '6 0' ;;
		C-g) printf '7 0' ;; C-h) printf '8 0' ;;
		C-i) printf '9 0' ;; C-j) printf 'a 0' ;;
		C-k) printf 'b 0' ;; C-l) printf 'c 0' ;;
		C-m) printf 'd 0' ;; C-n) printf 'e 0' ;;
		C-o) printf 'f 0' ;; C-p) printf '10 0';;
		C-q) printf '11 0';; C-r) printf '12 0';;
		C-s) printf '13 0';; C-t) printf '14 0';;
		C-u) printf '15 0';; C-v) printf '16 0';;
		C-w) printf '17 0';; C-x) printf '18 0';;
		C-y) printf '19 0';; C-z) printf '1a 0';;
		*)  ch=0
			case "${1:0:2}" in
				M-) in="${1:2:1}";;
				*) in="$1"
			esac
	esac
	((ch)) && return
	echo "$in" | {
		while read -rsn1; do
			out+="$(printf "%x\n" "'${in:$i}") "
			((i++))
		done
	}
	out=${out::-1}
	printf '%s' "${out}"
}

## define-key defines keybinding
:+     '$1' can be either:
#     '[function-key]'
#     '[arrow-key]'
#     '[prior | next]'
#     'RET'
#     'DEL'
#     '[delechar]'
#     'hex code ending with 0'
function define-key {
	local -n keys="keys_$1"
	case "$2" in
		#function keys
		'[f1]') keys[1b 4f 50 0]="$3";;
		'[f2]') keys[1b 4f 51 0]="$3";;
		'[f3]') keys[1b 4f 52 0]="$3";;
		'[f4]') keys[1b 4f 53 0]="$3";;
		'[f5]')  keys[1b 5b 31 35 7e 0]="$3";;
		'[f6]')  keys[1b 5b 31 37 7e 0]="$3";;
		'[f7]')  keys[1b 5b 31 38 7e 0]="$3";;
		'[f8]')  keys[1b 5b 32 39 7e 0]="$3";;
		'[f9]')  keys[1b 5b 32 30 7e 0]="$3";;
		'[f10]') keys[1b 5b 32 31 7e 0]="$3";;
		'[f11]') keys[1b 5b 32 33 7e 0]="$3";;
		'[f12]') keys[1b 5b 32 34 7e 0]="$3";;
		#arrow keys
		'[left]')  keys[1b 5b 44 0]="$3";;
		'[up]')    keys[1b 5b 41 0]="$3";;
		'[right]') keys[1b 5b 43 0]="$3";;
		'[down]')  keys[1b 5b 42 0]="$3";;
		#pg up & down
		'[prior]') keys[1b 5b 36 7e 0]="$3";;
		'[next]')  keys[1b 5b 35 7e 0]="$3";;
		#return
		'RET') keys[a 0]="$3";;
		#backspace & delete
		'DEL') keys[7f 0]="$3";;
		'[deletechar]') keys[1b 5b 33 7e 0]="$3";;
		'ESC') keys[1b 0 0]="$3";;
		'[deletechar]') keys[1b 5b 33 7e 0]="$3";;
		*) keys["$2"]="$3"
	esac
}

## local-set-key
# Sets keybinding of lastly defined mode
# See define-key for details
@fn local-set-key 'define-key "$_last_keys" "$@"'

## global-set-key
# Sets keybinding of global mode
# See define-key for details
@fn global-set-key 'define-key global "$@"'

## define-mode-option
# Sets option of mode '$1'
function define-mode-option {
	local -n ko="key_options_$1"
	ko["$2"]="$3"
}

## local-set-mode-option See define-mode-option
@fn local-set-mode-option 'define-mode-option "$_last_keys" "$@"'

## mode-options Brings mode-options of lastly defined mode into \"focus\"
@fn mode-options '_last_add="mode-options"'


## add-alias Adds alias '$1' of command '$2...' to M-x
function add-alias {
	local name="$1"
	shift
	alias["$name"]="$@"
}

## set-alias Brings into \"focus\" alias setting
@fn set-alias '_last_add=set-alias'

## add-highlight Sets highlighting mode '$1' for file types '$2...'
function add-highlight {
	local name="$1"
	shift
	for i in "$@"; {
		highlight["$i"]="$name"
	}
}

## set-alias Brings into \"focus\" highlight setting
@fn set-highlight '_last_add=set-highlight'

## clear-screen clears screen
@fn clear-screen "printf '\033c'"

## add-mode
# Adds keybing mode
function add-mode {
	log_buffer+=("        ADD MODE $1")
	_last_keys="$1"
	_last_add='add-mode'
	modes+=("keys_$1")
	declare -Ag "keys_$1"
	declare -Ag "key_options_$1"
}

## add-menu
# Adds menu
function add-menu {
	# create new menu function & array
	log_buffer+=("        ADD MENU $1")
	eval "function menu-${1} { menu $1; }"
	declare -ag "menu_${1}_0"
	declare -ag "menu_${1}_1"
	_last_menu="$1"
	_last_add='add-menu'
}

## local-set-menu Sets \"focused\" menu item
@fn local-set-menu 'define-menu "$_last_menu" "$1" "$2"'

## global-set Brings into \"focus\" global mode
@fn global-set '_last_add=global-set'

## define-option Defines options[] buffer
@fn define-option 'options["$1"]="$2"'

## set-options Brings into \"focus\" options setting
@fn set-options '_last_add=set-options'

## define-menu
# Defines item in menu '$1' with name '$2' with command '$3'
# '    If command is "menu-top_menu" face menu-back is used.'
function define-menu {
	local -n menu_0="menu_${1}_0"
	local -n menu_1="menu_${1}_1"
	local item_0
	case "$3" in
		'menu-top_menu') item_0="$(printf '%b' "${faces[menu-back]}")$2";;
		*) item_0="$2"
	esac
	menu_0+=("$item_0")
	menu_1+=("$3")
}

## load-theme Loads theme from array
function load-theme {
	local -i t=0
	local k
	local -n theme="$1"
	for i in "${theme[@]}"; {
		((t==0)) && {
			k="$i"
			t=1
		} || {
			faces["$k"]="$i"
			faces_raw["$k"]="$(printf '%b' "$i")"
			t=0
		}
	}
	((t)) && errno=1 die
	# aliases for nicer formating
	faces+=(
		[bl]="${faces[black]}"
		[dr]="${faces[red]}"
		[dg]="${faces[green]}"
		[dy]="${faces[yellow]}"
		[db]="${faces[blue]}"
		[dm]="${faces[magenta]}"
		[dc]="${faces[cyan]}"
		[dw]="${faces[light-gray]}"
		[gr]="${faces[gray]}"
		[lr]="${faces[light-red]}"
		[lg]="${faces[light-green]}"
		[ly]="${faces[light-yellow]}"
		[lb]="${faces[light-blue]}"
		[lm]="${faces[light-magenta]}"
		[lc]="${faces[light-cyan]}"
		[lw]="${faces[light-white]}"
	)
	faces_raw+=(
		[bl]="${faces_raw[black]}"
		[dr]="${faces_raw[red]}"
		[dg]="${faces_raw[green]}"
		[dy]="${faces_raw[yellow]}"
		[db]="${faces_raw[blue]}"
		[dm]="${faces_raw[magenta]}"
		[dc]="${faces_raw[cyan]}"
		[dw]="${faces_raw[light-gray]}"
		[gr]="${faces_raw[gray]}"
		[lr]="${faces_raw[light-red]}"
		[lg]="${faces_raw[light-green]}"
		[ly]="${faces_raw[light-yellow]}"
		[lb]="${faces_raw[light-blue]}"
		[lm]="${faces_raw[light-magenta]}"
		[lc]="${faces_raw[light-cyan]}"
		[lw]="${faces_raw[light-white]}"
	)
}

## extension Set properites of extension
function extension {
	log_buffer+=("- LOADING EXTENSION $1 -")
	extensions+=("$1")
	declare -Ag "${1}_ext_d"
	declare -ng ext_d="${1}_ext_d"
}
## version: Set version of extension
function version: {
	ext_d[version]="$1"
}

log_buffer+=('- LOADING BASH EXTENSIONS DONE -')

## rest of this garbageware

## refresh Refreshes buffer
# 'clears screen, reset syntax, redraws'
# 'See <a> doc-goto clear-screen : <f> link clear-screen </f> </a> for more info.'
function refresh {
	clear-screen
	bf_s=''
	
	message="reloaded..."
	redraw
}

## switch-mode
# Change current mode of buffer into '$1'
function switch-mode {
	bckmode="${bf_d[mode]}"
	bf_d[mode]="$1"
	redraw-statusline
}

## mode-back
# Restores previous mode
function mode-back {
	bf_d[mode]="$bckmode"
	unset bckmode
	redraw-statusline
}

## read-command
# Works like normal "'read'" but for bottom commanline
function read-command {
	printf '\e[%s;0H' $((bf_d[size-y] + bf_d[loc-y]))
	printf '\e[?25h'
	read -re -p "$1" -i "$3" "$2" || return 1
}

## base-name
# Basically equivalent to the "'basename'" coreutil		
function base-name
	for file in "$@"; {
		file="${file%/}"
		printf '%s\n' "${file##*/}"
	}

### TODO: make this make sense

## make-render Creates syntax highlighting for currently visible lines
function make-render {
	make-render-area "${bf_d[base]}" $((bf_d[base] + bf_d[size-y] + bf_d[loc-y]))
}

## make-render-area
# Creates syntax highlighting for lines from '$1' to '$2'
function make-render-area {
    local -i line="$1"
	local -i syntaxline=$line
	local -n linearray="${current_buffer}_syntax${syntaxline}"
	linearray=()
	bckeIFS="${IFS}"
	IFS=
	for ((l=syntaxline;l<${2};l++)); do
		((l > $2)) && break
		local -n linearray="${current_buffer}_syntax${syntaxline}"
		linearray=()
		bf_s[syntaxline]="${current_buffer}_syntax${syntaxline}"
		((syntaxline++))
		line="$l"
		make-render-line-loop
	done
	IFS="$bckeIFS"
}
	
## make-render-line
# Syntax highlights single line '$1'
# Defaults to currently selected line if no argument is passed
function make-render-line {
	local -i line=${1:-bf_d[line]}
	local -i syntaxline=$line
	local -n linearray="${current_buffer}_syntax${syntaxline}"
	bf_s[syntaxline]="${current_buffer}_syntax${syntaxline}"
	linearray=()
	bckeIFS="${IFS}"
	IFS=
	make-render-line-loop
	IFS="$bckeIFS"
}



## make-render-line-loop
# Backend for make-render-area \& make-render-line
# Also creates bf_e charmap for movenment
:+     "Tab is 't'"
#     "Space is 's'"
#     "Any unmaped char is '0'"
function make-render-line-loop {
	local -i comment=0
	local -i skip_next_space=0
	local word=''
	bf_e[line]=''

	for _link in ${bf_c[line]}; do
		unset "$_link"
	done
	unset bf_c[line]
		
	column=0
	while read -rsn1 char; do	
		case "$char" in
			' ')
				syntax-word
				word=''
				((skip_next_space==1)) && skip_next_space=0 && continue
				bf_e[line]+='s'
				face-no-expand "${facename:-${bf_d[background]:-default}}" ' '
				((column++));;
			'	')
				syntax-word
				word=''
				local -i i
				for ((i = ${#options[tabchar]}; i > 0 ; i--)); do
					bf_e[line]+="${charmap[	]}"
				done
				face-no-expand tab-face "${options[tabchar]}"
				((column+=${#options[tabchar]}));;
			'')
				syntax-word
				word=''
				skip_next_space=0
				face-no-expand "${bf_d[background]:-default}" ' '
				newline=1 # tell syntax functions that the previous char was newline # used for format thing
				return;;
			*)
				word+="${char}"
		esac
	done  <<< "${buffer[line]}"
}

## syntax-word
# Decides what a word should highlighted as:
:+     'If todonote option is enabled, highlight "NOTE:" & "TODO:"'
#     'If the word is supposed to be comment highlight it as it'
#     'Else pass it to current syntax function'
function syntax-word {
	(("${options[todonote]}"==1)) && {
		case "$word" in
			'NOTE:') face NOTE "${word}"; return ;;
			'TODO:') face TODO "${word}"; return ;;
		esac
	}
	((comment)) && set-face font-lock-comment-face ||
		"${bf_d[syntax]}"
	((bf_d[syntax-exec])) || face "$syntax_face" "$word" # s_ex controls syntax extended
}

## face
# Add highlighted word to multidimensional nonsense "'bf_s'" arry
function face {
	IFS=' '
	[[ "$2" =~ ${2//?/(.)} ]]
	linearray+=("${faces_raw[reset]}${faces_raw[${1}]}${BASH_REMATCH[@]:1}")
	IFS=''
	for ((iw=0; iw < ${#2}; iw++)); do
		bf_e[line]+='0'
	done
}

## face-no-expand
# Add highlighted word to multidimensional nonsense "'bf_s'" arry without adding anything to bf_e[] array
function face-no-expand {
	IFS=' '
	[[ "$2" =~ ${2//?/(.)} ]]
	linearray+=("${faces_raw[reset]}${faces_raw[${1}]}${BASH_REMATCH[@]:1}")
	IFS=''
}

## set-face Sets face for syntax highlighting
@fn set-face 'syntax_face="$1"'

## size-full
# Sets size of buffer to be fullscreen
function size-full {
	bf_d+=(
		[loc-x]=1
		[loc-y]=1
		[size-x]=$COLUMNS
		[size-y]=$((LINES - 1))
	)
}

## set-buffer
# Switch to buffer \$1 
function set-buffer {
	log info "switch to buffer [$1]"
	current_buffer="$1"
	declare -ng buffer="${current_buffer}_buffer"
	declare -ng bf_s="${current_buffer}_bf_s"
	declare -ng bf_e="${current_buffer}_bf_e"
	declare -ng bf_d="${current_buffer}_bf_d"
	declare -ng bf_c="${current_buffer}_bf_c"
}

## add-to-list
# Adds a buffer into currently active buffer list
function add-to-list {
	log info "added into buffer list: $current_buffer"
	buffers_l+=("$current_buffer")
}

## clear-buffer
# Empties buffer bf_s bf_e \& bf_d
function clear-buffer {
	buffer=()
	for l in "${bf_s[@]}"; {
		unset "$l"
	}
	bf_s=()
	bf_e=()
	for l in "${bf_c[@]}"; {
		unset "$l"
	}
	bf_c=()
}

## list-directory
# Basically like ls command 
function list-directory {
	((hidden==1)) && shopt -s dotglob
	((hidden==0)) && shopt -u dotglob
	printf '..\n'
	printf '%s\n' *
}

## current-time
# Basically like coreutil "'date'"
@fn current-time 'printf "%($1)T\\n"'

## log
# Adds message into log
# '    info -- everything *should* be well'
# '    warn -- something is wrong but it *should* not break entire Ebashs'
# '    error -- something is wrong and anything can break, but it *can* still run(?)'
# '    fatal -- something is mega wrong and only thing left to do is to die'
# Is disabled when log wasn\'t initialised, see init-log for info
function log {
	((log)) || return
	local type="$1"
	shift
	tooktime="$(( $(current-time '%s') - lasttime ))"
	bufferlog+=("<f> title [$type] </f> <f> font-lock-comment-face ${tooktime}s </f> <f> name [${FUNCNAME[1]}] </f> $*")
	lasttime="$(current-time '%s')"
}

## log-echo
# Adds message into log without any special formating	
function log-echo {
	((log)) || return
	bufferlog+=("<f> font-lock-comment-face > </f>    $*")
}

## debug
# +debug -- basically like set -x but reports stuff into log
## +log	
# Debug function to add logging to function it\'s called from
function +log {
	((log)) || return
	((options[log-functions])) && log '*' "${FUNCNAME[1]}"
	trap 'log bash $? $LINENO ${BASH_COMMAND}' ERR
}
## +debug
# Debug function to add extensive \(set -x like\) logging to function it\'s called from
function +debug {
	((log)) || return
	trap 'log DEBUG "${BASH_COMMAND}"' DEBUG
}

## goto Load array into buffer
function goto {
	clear-buffer
	bf_d[line]=1
	bf_d[column]=0
	copy-array "$1" buffer
	redraw
}

@doc syntax-format <<'EOF'
Convert formated text into Ebashs buffer understandable format.

<f> title <u> Specifications </u> </f>

<[> name <f> <f> hint face_name text... </f> <[> name </f>
<-> Set <f> hint text </f> to face <f> hint face_name </f-> .

<[> name <h> <f> hint text... </f> <[> name </h>
<-> Make <f> hint text </f> into title.

<[> name <a> <f> hint command </f> <[> name : <f> hint text </f> <[> name </a>
<-> Create clickable area that executes <f> hint command </f> on click and is labeled <f> hint text </f-> .
<-> See <a> doc-goto link-enter : <f> link link-enter </f> </a> 

<[> name <link> <f> hint command </f> <[> name : <f> hint text </f> <[> name </link>
<-> Create clickable area that executes <f> hint command </f> on click and is labeled <f> hint text </f-> .
<-> <[> name <link> also automatically adds <f> link link </f> face to text.

<[> name <u> <f> hint text </f> <[> name </u>
<-> Make <f> hint text </f> <u> uppercase. </u>

<[> name <i> <f> hint number_of_spaces hint text </f-> ...\n...\n...\n... <[> name </i>
<i-tab> Indent lines by <f> hint number of spaces </f-> .

<[> name <i-tab>
<-> Indent by tab (default 4 spaces).
<-> Tab size is controlled via tab_format variable. </i>

<[> name <s> <f> hint number_of_spaces </f>
<-> Insert <f> hint number of spaces </f-> .

<[> name <tab>
<-> Insert tab.
<-> <[> name <-> is alias for <[> name <tab>.

<[> name <v> <f> hint variable_name </f> <[> name </v>
<-> Insert contents of <f> hint variable </f> into text at formating time.

<[> name <\> <f> hint text </f>
<-> Escape <f> hint text </f>

<[> name <[> <f> hint face_name text </f>
<-> Escape <f> hint text </f> with <f> hint face </f-> .


Some of these keywords also include versions to glue together with other words.
For example:
<-> text <[> name <-f> <f> name face </f> color! <[> name </f-> text
Will turn into text <-f> lr c <-f> ly o <-f> lg l <-f> lc o <-f> lb r <-f> lm ! </f> </f> </f> </f> </f> </f-> text.
EOF
function syntax-format {
	((skip_word==1)) && {
		skip_next_space=1
		[ "$word" = '-->' ] && skip_word=0
		return
	}
	[ "$word" = '<!--' ] && {
		skip_next_space=1
		skip_word=1
		return
	}
	((newline==1)) && {
		ichar="${indent_spaces}"
	}
	((newline==0)) && {
		ichar=
	}

	((escape==2)) && {
		escape=1
		facename="$word"
		skip_next_space=1
		return
	}
	((escape==1)) && {
		escape=0
		face "$facename" "${ichar}$word"
		return
	}
	[ "$word" = '<\>' ] && {
		escape=1
		skip_next_space=1
		facename='unknown'
		return
	}
	[ "$word" = '<[>' ] && {
		escape=2
		skip_next_space=1
		return
	}
	
	((variable==1)) && {
		variable=0
		word="${!word}"
	}
	[ "$word" = '<v>' ] && {
		variable=1
		varname=
		skip_next_space=1
		return
	}

	[ "$word" = '</u>' ] && {
		upper=0
		skip_next_space=1
		return
	}
	[ "$word" = '<u>' ] && {
		upper=1
		skip_next_space=1
		return
	}
	[ "$word" = '</f>' ] && {
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		((column--))
		unset facename
		[ -n "$bckfacename" ] && {
			facename="$bckfacename"
			unset bckfacename
		}
		return
	}
	[ "$word" = '</f->' ] && {
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		((column--))
		skip_next_space=1
		[ -n "$bckfacename" ] && {
			facename="$bckfacename"
			unset bckfacename
		}
		return
	}
	((facedef==1)) && {
		skip_next_space=1
		facedef=0
		facename="$word"
		return
	}
	[ "$word" = '<f>' ] && {
		bckfacename="$facename"
		skip_next_space=1
		facedef=1
		return
	}
	[ "$word" = '<-f>' ] && {
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		((column--))
		bckfacename="$facename"
		skip_next_space=1
		facedef=1
		return
	}
	
	[ "$word" = '</h>' ] && {
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		((column--))
		unset facename
		upper=0
		[ -n "$bckfacename" ] && {
			facename="$bckfacename"
			unset bckfacename
		}
		return
	}
	[ "$word" = '<h>' ] && {
		bckfacename="$facename"
		skip_next_space=1
		facename=title
		upper=1
		return
	}
	
	((sethighlight==2)) && {
		sethighlight=1
		skip_next_space=1
		tmp_sex="$word"
		return
	}
	((sethighlight==1)) && {
		sethighlight=0
		skip_next_space=1
		bf_d[syntax-exec]="$tmp_sex"
		bf_d[syntax]="syntax-$word"
		return
	}
	[ "$word" = '<change-syntax>' ] && {
		skip_next_space=1
		sethighlight=2
		return
	}
	((space_next==1)) && {
		space_next=0
		skip_next_space=1
		for ((if=0; if< word; if++)) {
			linearray+=(' ')
			bf_e[line]+='s'
			((column++))
		}
		return
	}
	[ "$word" = '<s>' ] && {
		space_next=1
		skip_next_space=1
		return
	}
	[ "$word" = '<tab>' ] || [ "$word" = '<->' ] && {
		skip_next_space=1
		for ((if=0; if< format_tab; if++)) {
			linearray+=(' ')
			bf_e[line]+='s'
			((column++))
		}
		return
	}
	[ "$word" = '</i>' ] && {
		indent_spaces=
		return
	}
	((indent==1)) && {
		indent=0
		skip_next_space=1
		indent_spaces=
		indent_spaces_e=
		for ((if=0; if< word; if++)) {
			indent_spaces+=' '
			indent_spaces_e+='s'
		}
		return
	}
	[ "$word" = '<i>' ] && {
		indent=1
		skip_next_space=1
		return
	}
	[ "$word" = '<i-tab>' ] && {
		skip_next_space=1
		indent_spaces=
		indent_spaces_e=
		for ((if=0; if< format_tab; if++)) {
			indent_spaces+=' '
			indent_spaces_e+='s'
		}
		return
	}
	((link==2)) && {
		[ "$word" = ':' ] && {
			((
				skip_next_space=1,
				link=1
			))
			return
		}
		skip_next_space=1
		linkfn+="$word "
		return
	}
	[ "$word" = '</a>' ] && {
		((lc++))
		((column--))
		link=0
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		bf_c[line]+="bf_c_${lc}_${current_buffer} "
		declare -Ag "bf_c_${lc}_${current_buffer}"
		local -n bf_c_line="bf_c_${lc}_${current_buffer}"
		bf_c_line=(
			[start]="$lsx"
			[end]=$((column - 1))
			[exec]="$linkfn"
		)
		return
	}
	[ "$word" = '<a>' ] && {
		((
			link=2,
			lsx=column,
			skip_next_space=1
		))
		linkfn=
		return
	}
	((facelink==2)) && {
		[ "$word" = ':' ] && {
			((
				skip_next_space=1,
				facelink=1
			))
			facename='link'
			return
		}
		skip_next_space=1
		linkfn+="$word "
		return
	}
	[ "$word" = '</link>' ] && {
		((lc++))
		((column--))
		facelink=0
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		bf_c[line]+="bf_c_${lc}_${current_buffer} "
		declare -Ag "bf_c_${lc}_${current_buffer}"
		local -n bf_c_line="bf_c_${lc}_${current_buffer}"
		bf_c_line=(
			[start]="$lsx"
			[end]=$((column - 1))
			[exec]="$linkfn"
		)
		unset facename
		[ -n "$bckfacename" ] && {
			facename="$bckfacename"
			unset bckfacename
		}
		return
	}
	[ "$word" = '<link>' ] && {
		((
			facelink=2,
			lsx=column,
			skip_next_space=1
		))
		linkfn=
		return
	}
	
	((object==1)) && {
		skip_next_space=1
		[ "$word" = 'text:' ] && {
			object=0
			set_obj=0
			return
		}
		[ "$word" = 'select:' ] && { set_obj=1; obj_select=; return; }
		[ "$word" = 'id:' ] && { set_obj=2; obj_id=; return; }
		[ "$word" = 'left:' ] && { set_obj=3; obj_left=; return; }
		[ "$word" = 'up:' ] && { set_obj=4; obj_up=; return; }
		[ "$word" = 'right:' ] && { set_obj=5; obj_right=; return; }
		[ "$word" = 'down:' ] && { set_obj=6; obj_down=; return; }

		((set_obj==1)) && obj_select+="$word "
		((set_obj==2)) && obj_id+="$word "
		((set_obj==3)) && obj_left+="$word "
		((set_obj==4)) && obj_up+="$word "
		((set_obj==5)) && obj_right+="$word "
		((set_obj==6)) && obj_down+="$word "
		return
	}
	[ "$word" = '</o>' ] && {
		((lc++))
		((column--))
		link=0
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		bf_c[line]+="bf_c_${lc}_${current_buffer} "
		declare -Ag "bf_c_${lc}_${current_buffer}"
		local -n bf_c_line="bf_c_${lc}_${current_buffer}"
		bf_c_line=(
			[start]="$lsx"
			[end]=$((column - 1))
			[exec]="$obj_select"
			[id]="$obj_id"
			[left]="$obj_left"
			[up]="$obj_up"
			[right]="$obj_right"
			[down]="$obj_down"
		)
		return
	}
	[ "$word" = '<o>' ] && {
		((
			object=1,
			lsx=column,
			skip_next_space=1
		))
		obj_id=
		obj_text=
		obj_select='true'
		obj_left='backward-char'
		obj_up='previous-line'
		obj_right='forward-char'
		obj_down='next-line'
		set_obj=0
		return
	}
	
	((newline==1)) && newline=0
	((column+=${#ichar} + ${#word}))
	((upper==1)) && {
		word="${word^^}"
	}
	face "${facename:-unknown}" "${ichar}$word"
}

@doc link-enter <<'EOF'
Executes <f> name clickable area </f> of formated text to which current position
of cursor points.
Mostly used for <f> name hyperlinks </f-> .

Internally <f> name clickable area </f> is defined via bf_c 2d array. Each line contains
the <f> name clickable areas </f-> . Each of these is it's own associative array.
Each <f> name clickable area </f> contains:
<i-tab> <[> hint start - the first column of the area
<[> hint end   - the last column of the area
<[> hint exec  - what command should be executed when this function,
<-> <f> name link-enter </f> is ran. </i>
EOF
function link-enter {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"
		#echo "    $link" >> d
		#echo "${bf_c_line[start]}" >> d
		#echo "${bf_c_line[end]}" >> d
		#echo "${bf_c_line[exec]}" >> d
		
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				has=1
				${bf_c_line[exec]}
				return
			}
	}
	${bf_d[format-else]}
}

function format-left {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				${bf_c_line[left]:-backward-char}
				return
			}
	}
	backward-char
}
function format-up {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				${bf_c_line[up]:-previous-line}
				return
			}
	}
	previous-line
}
function format-right {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				${bf_c_line[right]:-forward-char}
				return
			}
	}
	forward-char
}
function format-down {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				${bf_c_line[down]:-next-line}
				return
			}
	}
	next-line
}

function obj {
	for y in "${!bf_c[@]}"; {
		for obj in ${bf_c[y]}; {
			local -n bf_c_line="$obj"
			[ "${bf_c_line[id]}" = "$1 " ] && {
				((bf_d[line]=y, bf_d[column]=bf_c_line[start]))
				redraw-cursor
			}
		}
	}
}
	
@fn is-function 'declare -F -- "$1" > /dev/null'

## Dumps current buffer into a file	
function dump-buffer {
	true >"$1" # Set the file to an empty text file
	for ln in "${buffer[@]}"; do # Write in the buffer to the file
		echo "$ln" >>"$1"
	done
}

## die
# Closes Ebashs with exit code \$errno, if errno is empty exit with 0
# If \$nocleanup is 1, do not restore the terminal to sane mode and do not cleanup 
# Else restore to sane mode 
function die {
	((nocleanup)) && exit "${errno:-0}"
	${on_die:-true}
	echo -e "\e[?1000;1006;1015l" #disable mouse tracking
	clear-screen # TODO fix the buffer switching
	printf '\e[?25h\e[?7h\e[?1049l' # Reset terminal to sane mode
	exit "${errno:-0}" # Assume that we are exiting without an error
}

# Sets \$nocleanup to 1 and dies	
function abort {
	((nocleanup=1)) && die "$@"
}

fragment keepcolumn <<'+'
	[ -z "$bckrl" ] && bckrl="${bf_d[column]}"	
	(( ${#bf_e[bf_d[line]]} < bf_d[column] )) && bf_d[column]=${#bf_e[bf_d[line]]}
	(( ${#bf_e[bf_d[line]]} > bckrl )) && bf_d[column]=${bckrl}
+

# Moves up \$1 lines, if \$ is empty move up 1 line
function move-previous-line {
	for ((i = 0; i < ${1:-1}; i++)); do
		((bf_d[line] > 1)) && ((bf_d[line]--)) # As long as we can keep going up, go up
		((bf_d[line] < bf_d[base] + 1)) && {
			((bf_d[base]--)) # Push back the top if we need to
			move_base=1 # Send signal to redraw-cursor that the buffer was moved, thus needs to be redraw fully
			((bf_d[base] <= 0)) && bf_d[base]=1 # Don't push back if our base is at 1
		}
		[ -z "$bckrl" ] && bckrl="${bf_d[column]}"	
		(( ${#bf_e[bf_d[line]]} < bf_d[column] )) && bf_d[column]=${#bf_e[bf_d[line]]}
		(( ${#bf_e[bf_d[line]]} > bckrl )) && bf_d[column]=${bckrl}
	done
}

# Moves down \$1 lines, if \$ is empty move down 1 line
function move-next-line {
	for ((i = 0; i < ${1:-1}; i++)); do
		((bf_d[line] < ${#buffer[@]}+1)) && ((bf_d[line]++)) # If we can go down, go down
		# Move window down if needed
		((bf_d[line] > bf_d[base] + bf_d[size-y] - 3 - bottomlines)) && {
			((bf_d[base]++))
			move_base=1
		}
		[ -z "$bckrl" ] && bckrl="${bf_d[column]}"	
		(( ${#bf_e[bf_d[line]]} < bf_d[column] )) && bf_d[column]=${#bf_e[bf_d[line]]}
		(( ${#bf_e[bf_d[line]]} > bckrl )) && bf_d[column]=${bckrl}
	done
}

function previous-line {
	move-previous-line "$@"
	redraw-statusline
	if ((bf_d[selection])); then
		redraw
	else
		redraw-cursor
	fi
}
function next-line {
	move-next-line "$@"
	redraw-statusline
	if ((bf_d[selection])); then
		redraw
	else
		redraw-cursor
	fi
}
function scroll-down {
	move-previous-line $((bf_d[size-y] - 3))
	redraw-statusline
	if ((bf_d[selection])); then
		redraw
	else
		redraw-cursor
	fi
}
function scroll-up {
	move-next-line $((bf_d[size-y] - 3))
	redraw-statusline
	if ((bf_d[selection])); then
		redraw
	else
		redraw-cursor
	fi
}
	
@fn move-beginning-of-line 'bf_d[column]=0; redraw'
@fn move-end-of-line 'bf_d[column]="${#bf_e[${bf_d[line]}]}"; redraw'


function move-select {
	((bf_d[selection])) || {
		bf_d[selection_start_y]="${bf_d[line]}"
		bf_d[selection_start_x]="${bf_d[column]}"
		bf_d[selection]=1
	}
}

function select-forward {
	move-select
	forward-char
}
function select-backward {
	move-select
	backward-char
}
function select-next {
	move-select
	next-line
}
function select-previous {
	move-select
	previous-line
}

function forward-char {
	for ((i = 0; i < ${1:-1}; i++)); do
		case "${bf_e[${bf_d[line]}]:${bf_d[column]}+1:1}" in
			't') bf_d[column]=$(( bf_d[column]+${#options[tabchar]}));;
			*) ((bf_d[column]++));;
		esac
		((bf_d[column] > ${#bf_e[${bf_d[line]}]})) && {
			bf_d[column]=0
			next-line
			return
		}
		bckrl=
	done
	if ((bf_d[selection])); then
		redraw
	else
		redraw-cursor-line
	fi
}

function backward-char {
	for ((i = 0; i < ${1:-1}; i++)); do
		case "${bf_e[${bf_d[line]}]:${bf_d[column]}-1:1}" in
			't') bf_d[column]=$(( bf_d[column]-${#options[tabchar]}));;
			*) ((bf_d[column]--));;
		esac
		((bf_d[column] < 0)) && ((bf_d[line]==1)) && {
			bf_d[line]=1
			bf_d[column]=0
		}
		((bf_d[column] < 0)) && {
			bf_d[column]="${#bf_e[${bf_d[line]}-1]}"
			previous-line
			return
		}
		bckrl=
	done
	if ((bf_d[selection])); then
		redraw
	else
		redraw-cursor-line
	fi
}
	
## forward-word
# Moves forward to next word
function forward-word {
	((bf_d[column] == ${#bf_e[bf_d[line]]})) && {
		next-line
		move-beginning-of-line
	}
	while :; do
		((bf_d[column] < ${#bf_e[bf_d[line]]})) && ((bf_d[column]++)) || break
		case "${bf_e[bf_d[line]]:${bf_d[column]}:1}" in
			't'|'s') break
		esac
	done
	redraw
}

## backward-word
# Moves backward to previous word
function backward-word {
	((bf_d[column] == 0)) && {
		previous-line
		move-end-of-line
	}
	while :; do
		((bf_d[column] > 0)) && ((bf_d[column]--)) || break
		case "${bf_e[bf_d[line]]:${bf_d[column]}:1}" in
			't'|'s') break
		esac
	done
	redraw
}


@doc to-line <<'+'
Move cursor to line number $1 and move the line into middle of visible buffer area.
+
function to-line {
	bf_d[line]="$1"
	bf_d[base]=$((bf_d[line] - bf_d[size-y] / 2 ))
	redraw
}
			
# Handle clicking on top menu with mouse		
function menuline-mouse {
	local -n top_0="menu_${bf_d[menuline]}_0"
	local -n top_1="menu_${bf_d[menuline]}_1"
	#determine which item should be triggered
	[ -z "$1" ] && menuloc_x=0 || menuloc_x=$1
	local cx="${bf_d[loc-x]}"
	i=0
	for i in "${!top_0[@]}"; {
		la="${#top_0[i]}"
		((menuloc_x>cx)) && ((menuloc_x<(cx + la + 1))) && {
			${top_1[$i]}
			return
		}
		cx=$(( cx + la + 1 ))
	}
}
# Redraw popup menu
function redraw-menu {
	printf '\e[?25l' # hide cursor (again)
	printf '\e[%s;0H' $menuloc_y
	for i in "${!menu_0[@]}"; {
		if ((i == menuselection)); then
			printf "\e[%sC${faces[menu-selected-face]}%s${reset}\n" $menuloc_x "${menu_0[i]}"  
		else
	   		printf "\e[%sC${faces[menu-enabled-face]}%s${reset}\n" $menuloc_x "${menu_0[i]}"
		fi
	}
}


function menuup {
	((menuselection > 0)) && ((menuselection--));
	redraw-menu;
}
function menudown {
	((menuselection < ${#menu_0[@]} -1)) && ((menuselection++));
	redraw-menu;
}

# Execute selected item in menu
function menuselect
for i in "${!menu_1[@]}"; {
	((i == menuselection)) && "${menu_1[i]}"
}

# Closes a menu
function menuleave {
	ismenu=0
	bf_d[mode]="${modebackup}"
	redraw
}

# Opens a menu \$1	
function menu {
	declare -ng menu_0=menu_${1}_0
	declare -ng menu_1=menu_${1}_1
	((ismenu == 0 )) && modebackup="${bf_d[mode]}"
	ismenu=1
	declare -ig menuselection=0
	bf_d[mode]='menu'
	redraw
}

# deletes current buffer
function delete-buffer {
	local -a copy
	local i=0
	local index
	for b in "${buffers_l[@]}"
	do
		[[ "$b" != "$current_buffer"  ]] && copy+=("$b")
		[[ "$b" = "$current_buffer"  ]] && index="$i"
		((i++))
	done
	unset buffers_l
	copy-array copy buffers_l
	current_buffer="${buffers_l[index-1]}"
	redraw
}
						
# Draw multiline region
function selection-draw
if ((i == bf_d["${1}_y"])); then
	printf "${ln}%*s\e[%sG%b%s%b%s%b%b"\
		   ${lnargs[@]}\
		   $((bf_d[size-x] - bf_d[number-length]))\
		   ''\
		   $((bf_d[loc-x] + bf_d[number-length] + space))\
		   "${faces[default]}"\
		   "${linearray[*]:bf_d[basecolumn]:bf_d[${1}_x]}"\
		   "\e[m${faces[region]}"\
		   "${buffer[i]:bf_d[${1}_x]:bf_d[size-x] - (bf_d[number-length] + 1)}"\
		   "${faces[default]}" "$nlchar"
elif ((i == bf_d["${2}_y"])); then
	printf "${ln}%*s\e[%sG%b%b%s%b%s%b%b"\
		   ${lnargs[@]}\
		   $((bf_d[size-x] - bf_d[number-length]))\
		   ''\
		   $((bf_d[loc-x] + bf_d[number-length] + space))\
		   "${faces[default]}"\
		   "${faces[region]}"\
		   "${buffer[i]:bf_d[basecolumn]:bf_d[${2}_x]}"\
		   "\e[m"\
		   "${linearray[*]:bf_d[${2}_x]:bf_d[size-x]}"\
		   "${faces[default]}" "$nlchar"
else
	printf "${ln}%*s\e[%sG%b%b%s%b%b"\
		   ${lnargs[@]}\
		   $((bf_d[size-x] - bf_d[number-length]))\
		   ''\
		   $((bf_d[loc-x] + bf_d[number-length] + space))\
		   "${faces[default]}"\
		   "${faces[region]}" "${buffer[i]:bf_d[basecolumn]:bf_d[size-x] - (bf_d[number-length] + 1)}"\
		   "${faces[default]}" "$nlchar"
fi

# Handle changing size of terminal
function change-size-screen {
	bf_d[size-x]="$COLUMNS"
	bf_d[size-y]=$((LINES-1))
	redraw
}
	
## redraw
# Redraw screen
function redraw {
	[ -n "${bf_d[redraw]}" ] && {
		"${bf_d[redraw]}" "$@"
		return
	}
	printf '\e[?25l'

	# the first line should be always empty 
	unset buffer[0]
	
	# Handle changing size of buffer
	((bf_d[size-x]!=bcksize_x)) || ((bf_d[size-y]!=bcksize_y)) && {
		# Make the statusline full of dashes
		dashline=$(
			for ((i=0; i<bf_d[size-x]; i++)) {
				printf '-'
			}
		)
		bcksize_x=${bf_d[size-x]}
		bcksize_y=${bf_d[size-y]}
	}
		
	# Get length of line-number of lines
	bf_d[length]="${#buffer[@]}"
	((bf_d[length]==0)) &&((bf_d[length]++))
	
	((options[line-number-mode])) && {
		bf_d[number-length]=${#bf_d[length]}
		bf_d[number-space]=1
	} || ((bf_d[number-length]=0, bf_d[number-space]=0))
	
	# Update selection ends to current cursor
	((bf_d[selection]==1)) &&
		((bf_d[selection_end_y]=bf_d[line], bf_d[selection_end_x]=bf_d[column]))
	
	# Move the buffer horizontally if needed
	((bf_d[column] +3 < bf_d[size-x] - bf_d[number-length] - 1)) &&
		bf_d[basecolumn]=0
	((bf_d[column] +3 > bf_d[size-x] - bf_d[number-length] - 1)) &&
		bf_d[basecolumn]=$((bf_d[column] - (bf_d[size-x] + bf_d[loc-x] - bf_d[number-length] - 1) +3))

	# Draw top menuline
	(("${options[menu-line]}"==1)) && {
		"${bf_d[menuline-function]:-redraw-menuline}"
	} || printf "\e[%s;%sH" "${bf_d[loc-y]}" "${bf_d[loc-x]}"

	# IFS has to be empty in order to bufferarray multiarray be printed as words instead of chars
	IFS=''

	# Handle line number displaying
	# the resulting line has to be printed in one go to prevent flicker
	# space stores if the position of actuall text should be offset by +1
	# ln stores printf print line
	# args stores printf arguments
	local -i space
	local ln
	local -a lnargs
	
	# Iterate over shown lines
	local -i max=$((bf_d[size-y] - (toplines + bottomlines) + 1))
	for ((i = bf_d[base]; i - bf_d[base] < max; i++)); do
	# if the line is last, do not add newline

		ln="\e[%dG"
		lnargs=(
			"${bf_d[loc-x]}"
		)
		if ((options[line-number-mode])); then
			space=1
			ln="\e[%dG%b%*s"
			lnargs=(
				"${bf_d[loc-x]}"
				"${faces[line-number]}"
				"${bf_d[number-length]}"
				"$i"
			)
			((i == bf_d[line])) && lnargs[1]="${faces[line-number-current-line]}"
		fi
		
		((i - bf_d[base] > max - 2)) && nlchar='' || nlchar='\n'

		((i > ${#buffer[@]})) &&
			printf '\e[%sG%b%*s%s%b%*s%b'\
				   "${bf_d[loc-x]}"\
				   "${faces[line-number-empty]}"\
				   $((bf_d[number-length]/2)) ''\
				   "${options[empty-line-char]}"\
				   "${faces[default]}"\
				   $((bf_d[size-x] - bf_d[number-length]))\
				   ''\
				   "$nlchar" &&
			continue
		
		# to improve speed syntaxing has to be "lazy" -- having to be heavily cached as ram is far less expensive to waste
		[ -z "${bf_s[base+i]}" ] && {
			make-render-line $((base + i))
		}
		local -n linearray="${bf_s[i]}"
		
		# draw the selection area
		((bf_d[selection])) && {
			((i == bf_d[selection_start_y])) &&
				((bf_d[selection_start_y] == bf_d[selection_end_y])) && {
					((bf_d[selection_start_x] <= bf_d[selection_end_x])) && {
						local -n sx=bf_d[selection_start_x]
						local -n ex=bf_d[selection_end_x]
					} || {
						local -n sx=bf_d[selection_end_x]
						local -n ex=bf_d[selection_start_x]
					}
					printf "${ln}%*s\e[%sG%b%s%b%s%b%s%b"\
						   ${lnargs[@]}\
						   $((bf_d[size-x] - bf_d[number-length]))\
						   ''\
						   $((bf_d[loc-x] + bf_d[number-length] + space))\
						   "${faces[default]}"\
						   "${linearray[*]:bf_d[basecolumn]:sx}"\
						   "\e[m${faces[region]}"\
						   "${buffer[i]:sx:ex-sx}"\
						   "\e[m"\
						   "${linearray[*]:ex:bf_d[size-x]}"\
						   "$nlchar"
					continue
				}
			((i >= bf_d[selection_start_y])) && ((i <= bf_d[selection_end_y])) && {
				selection-draw selection_start selection_end
				continue
			}
			((i <= bf_d[selection_start_y])) && ((i >= bf_d[selection_end_y])) && {
				selection-draw selection_end selection_start
				continue
			}
		}
		# due to escape codes present in bf_s,
		# the bf_s has to be multidimensional nonsense for perfomance reasons
		printf "${ln}%b%*s\e[%sG%b%s\e[m%b"\
			   ${lnargs[@]}\
			   "${faces[${bf_d[background]:-default}]}"\
			   $((bf_d[size-x] - bf_d[number-length]))\
			   ''\
			   $((bf_d[loc-x] + bf_d[number-length] + space))\
			   "${faces[${bf_d[background]:-default}]}"\
			   "${linearray[*]:bf_d[basecolumn]:bf_d[size-x] - (bf_d[number-length])}"\
			   "$nlchar"
	done
	redraw-statusline
	redraw-commandline
	((no_cursor)) || redraw-cursor		
	@ifs		
	# redraw menu if open
	[ "${bf_d[mode]}" = 'menu' ] && redraw-menu
}

## print-buffer-line
function print-buffer-line {
	IFS=''
	local -n linearray="${bf_s[bf_d[line]]}"
	printf '%s' "${linearray[*]:bf_d[basecolumn]:bf_d[size-x] - (bf_d[number-length])}"
	@ifs
}

## redraw-menuline Redraws top menu line
function redraw-menuline {
	local -n top_0="menu_${bf_d[menuline]}_0"
	printf "\e[0m\e[%s;%sH${faces[menu]}\e[?25l%*s\r%s"\
		   "${bf_d[loc-y]}"\
		   "${bf_d[loc-x]}"\
		   "${bf_d[size-x]}"\
		   "${bf_d[info]}"
	printf '\e[%sG%s\e[0m\n' "${bf_d[loc-x]}" "${top_0[*]}"
}

# Draw cursor on the line
function redraw-cursor-line {
	((options[full-redraw]==0)) && {
		# redraw if buffer needs to be moved horizontally
		((bf_d[column] > bf_d[size-x] - bf_d[number-lenght] - space)) && {
			redraw
			return
		}
		((bf_d[basecolumn]==0)) || {
			redraw
			return
		}
		printf '\e[%sG\e[?25h'\
			   $((bf_d[column] - bf_d[basecolumn] + bf_d[number-length] + bf_d[loc-x] + bf_d[number-space])) ||
			redraw
	}
}
	
# Draw cursor and if move_base is 1 redraw
function redraw-cursor {
	((options[full-redraw])) && {
		no_cursor=1
		redraw
		no_cursor=0
	}
	((move_base)) && {
		move_base=0
		redraw
		return
	}
	local -i y=$((bf_d[line] + options[menu-line] - bf_d[base] + bf_d[loc-y]))
	((options[line-number-mode])) && {
		printf '\e[%s;%sH%b%*s\e[m'\
			   $((last_line + options[menu-line] - bf_d[base] + bf_d[loc-y]))\
			   "${bf_d[loc-x]}"\
			   "${faces[line-number]}"\
			   ${bf_d[number-length]}\
			   $last_line
		printf '\e[%s;%sH%b%*s\e[m'\
			   $y\
			   "${bf_d[loc-x]}"\
			   "${faces[line-number-current-line]}"\
			   ${bf_d[number-length]}\
			   ${bf_d[line]}
	}
	printf '\e[%s;%sH\e[?25h'\
		   $y\
		   $((bf_d[column] - bf_d[basecolumn] + bf_d[number-length] + bf_d[loc-x] + bf_d[number-space]))
	last_line=${bf_d[line]}
}

# Draw bottom mode/status line
function redraw-statusline {
	((options[mode-line])) &&
		printf "\e[%s;%sH\e[%sG%b%s\e[%sG%s %b%s\e[m%b %d%% (%d,%d) (%s[%s]) (screen: %s) \e[m" \
			   $((bf_d[size-y] - 1 + bf_d[loc-y]))\
			   $((bf_d[size-x] + bf_d[loc-x]))\
			   "${bf_d[loc-x]}"\
			   "${faces[mode-line]}"\
			   "$dashline"\
			   "${bf_d[loc-x]}" \
			   "${bf_d[mode]}"\
			   "${faces[file-name]}"\
			   "$(base-name "${bf_d[file]}")"\
			   "${faces[mode-line]}"\
			   $((100 * bf_d[line] / bf_d[length]))\
			   "${bf_d[line]}"\
			   "${bf_d[column]}"\
			   "${highlight[${bf_d[filetype]}]}"\
			   "${bf_d[filetype]}"\
			   "$current_buffer"
}

# Draw bottomest command line message echo area
function redraw-commandline {
	# clear message if it has been printed before already
	((options[keep-message]==0)) && 
		((clrmsg)) && {
			message=
			clrmsg=0
		} || clrmsg=1
	if ((options[command-line])); then
		printf "\e[%s;%sH\n${faces[minibuffer-prompt]}%*s\r%s\e[m" \
			   $((LINES-1)) 1 $((COLUMNS)) ' ' "$message"
	else
		[ -n "$message" ] &&
			printf "\e[%s;%sH%s" \
				   $((LINES)) 1 "$message"
	fi
}

## handle-mouse
# Handle mouse click
function handle-mouse {
	local -i x y
	#parse mouse stuff somewhatish weirdly
	[ "${k_hex[*]:0:5}" = '1b 5b 3c 36 34' ] && previous-line && return
	[ "${k_hex[*]:0:5}" = '1b 5b 3c 36 35' ] && next-line && return
	[ "${k_hex[*]:0:5}" = '1b 5b 3c 38 30' ] && previous-line 9 && return
	[ "${k_hex[*]:0:5}" = '1b 5b 3c 38 31' ] && next-line 9 && return
	((skipnext==1)) && skipnext=0 && return
	((skipnext==0)) && [ "${k_hex[*]:0:2}" = '1b 5b' ] && {
		mapfile -t -d '' inputarray <<< "${1}"
		inputarray[-1]="${inputarray[-1]%?}"
		[ -z "${inputarray[2]}" ] && skipnext=1
		mapfile -t -d ';' inputarray <<< "${inputarray[1]}"
		inputarray[-1]="${inputarray[-1]%?}"	
		mousemode="${inputarray[0]}"
		x="${inputarray[1]}"
		y="${inputarray[2]::-1}"
		#limitations of movenment
		#TODO:
		[ $y = "${bf_d[loc-y]}" ] && menuline-mouse $x && return #handle menuline
		((x < (bf_d[number-length] + bf_d[loc-x] + 2))) && {
			if [ "$mousemode" = '[<0' ]; then
				bf_d[line]=$(( bf_d[base] + ( (y - bf_d[loc-y]) - toplines) ))
				redraw
			elif [ "$mousemode" = '[<2' ]; then #VERY BAD SOLUTION, TODO: FIX
				clear-screen
				echo 'Enter the index: '
				read -re line
				redraw
			fi
			return
		}
		bf_d[line]=$(( bf_d[base] + ( y - bf_d[loc-y] - 1) ))
		bf_d[column]=$(( x - (bf_d[loc-x] + bf_d[number-length] + 1) ))
		((bf_d[line] > ${#bf_e[@]})) &&
			bf_d[line]=${#bf_e[@]}
		((bf_d[column] > ${#bf_e[bf_d[line]]})) &&
			bf_d[column]=${#bf_e[bf_d[line]]}
		redraw
	}
}

## insert-word
# Insert \$1 to buffer
function insert-word {
	((options[save-states])) && save-state
	local -i rlr
	unset ta
	local ta
	ta=${bf_e[${bf_d[line]}]:0:${bf_d[column]}}
	ta=${ta//[^t]}
	ta=${#ta}
	rlr=$((bf_d[column] + ta / 4 - ta))
	buffer[bf_d[line]]="${buffer[${bf_d[line]}]:0:${rlr}}$1${buffer[${bf_d[line]}]:${rlr}}"
	#add at cursor position - amount of tabs * tab size
	make-render-line
	forward-char "${#1}"
	bf_d[selection]=0
	redraw
	bf_d[modified]=1
}

## input-key Handles input
# Either \$1 raw character input or k_hex array containing hex values of characters is used
function input-key {
	#arg $1 is the pressed key in normal text form
	#k_hex is pressed key in hex array ending with 0
		
	local -i mode_contains=0
	local -n modekeys="keys_${bf_d[mode]}"\
	         key_options="key_options_${bf_d[mode]}"

	# global keys
	((key_options[disable-global])) ||
		for str in "${!keys_global[@]}"
		{
			[ "$str" = "${k_hex[*]}" ] && {
				"${keys_global[$str]}"
				return
			}
		}

	# Execute the 'always' key option
	((${#key_options[@]})) &&
		[ -n "${key_options[always]}" ] && "${key_options[always]}"

	# Loop over current mode keybindings to match current keypress
	for str in "${!modekeys[@]}"
	{
		[ "$str" = "${k_hex[*]}" ] && {
			"${modekeys[$str]}"
			mode_contains=1
		}
	}

	# If mode keybinding doesn't contain current keypress, execute this
	((${#key_options[@]})) &&
		((mode_contains == 0)) &&
		[ -n "${key_options[else]}" ] && {
			[ "${key_options[else]}" = 'insert' ] || {
				"${key_options[else]}" && return
			}
		}

	# Do not continue if mode contains keypress to prevent control chars flooding file
	((mode_contains==1)) && return

	# If mouse is enabled, do whatever the hell that ugly piece of code does
	(("${options[mouse]}"==1)) && {
		handle-mouse "$1"
		return
	}

	# Insert the pressed character
	[[ $1 =~ [[:cntrl:]] ]] && return # If char is control char, return
	insert-word "$1"
}

function init-var {
	((options[log])) && init-log || unset buffer_log # set up log buffer (M-x log)


	log info setting traps...
	trap change-size-screen WINCH ALRM # Attach WINCH and ALRM to redraw the screen
	trap die EXIT HUP USR1 # Attach most exit codes to cleanup and exit
	trap 'k_hex=(3 0); input-key' INT
	trap quit SIGTERM

	format_tab=4

	menuloc_y=0; menuloc_x=0 # menu positions
	log info 'Setting menu-line'
	toplines=${toplines:-0}
	((toplines=toplines + options[menu-line]))

	# this is reverse because the value is added to buffer redrawing size
	log info 'Setting mode-line'
	bottomlines=${bottomlines:-0}
	((options[mode-line]==0)) && ((bottomlines--))
	log info 'Setting command-line'
	((options[command-line]==0)) && ((bottomlines--))
	((bottomlines+=2))
	
	log-echo "toplines $toplines"
	log-echo "bottomlines $bottomlines"
	
	log info 'Setting reset'
	reset='\e[0;0m'
	log info 'Setting charmap'
	charmap=(
		#[0] is reserved for any unmapped char
		[	]='t' # tab
		[ ]='s' # space
	)
	if ((options[esc-to-meta])); then
		esc_timeout=123456789 # a very big number
	else
		esc_timeout=0.01
	fi
	log info 'Setting nlchar'
	nlchar='\n'
	printf '\e[?1049h'
	log info 'Setting mouse'
	((options[mouse])) && echo -ne "\e[?1000;1006;1015h" #enable mouse tracking
}

## main Main keyboard loop
function main
	while :; do
		local -a k=()
		local -i i=1
		k_hex=() # Also convert the input sequence into hex for way easier handling
		# Check for ready input
		read -rsN1 k[0] && {
			k_hex[0]="$(printf "%x\n" "'${k[0]}")"

			# Hack to try preventing arrow codes being split into multiple and inserting garbage to buffer
			[ "${k_hex[0]}" = '1b' ] && {
				read -rsN1 -t "${esc_timeout}" k[1]
				k_hex[1]="$(printf "%x\n" "'${k[1]}")"
				[ "${k_hex[1]}" = '5b' ] && {
					read -rsN1 k[2]
					k_hex[2]="$(printf "%x\n" "'${k[2]}")"
					case "${k_hex[2]}" in
						'41'|'42'|'43'|'44')
							k_hex[3]='0'
							input-key "${k[@]}"
							continue
					esac
					i=2
				}
				((i++))
			}
			# Multibyte hack
			while read -rsN1 -t0.0001 k[$i]; do
				k_hex[$i]="$(printf "%x\n" "'${k[$i]}")"
				((i++))
			done
			k_hex[$i]='0'
			input-key "${k[@]}" # Handle keypress event
		}
	done	

### BUFFERMAKER END

## Ebashs
#		Emacs-like editor written in pure Bash
#		Had been tested properly only on Bash 5.2, and will propably be broken on 4.x versions and definitelly on 3 and older.

function load-default-config-ebashs {
	## Configuration
	#		The magic :: function
	#			:: sets value to option depending on current context:
	#				set-options → define-options() → ass. array options
	#				global-set → global-set-key → define-key global → as. ar. keys_global
	#				add-mode → local-set-key → define-key <keys> → a. a. keys_<keys>
	#					mode-options → local-set-mode-option → define-mode-option → a. a. key_options_<keys>
	#				set-alias → add-alias → a. a. alias
	#				add-menu → local-set-menu → define-menu <menu> → menu_<menu>_0 & menu_<menu>_1
	#				set-highlight → add-highlight → a. a. highlight
					  
	set-options
		:: mouse 0
		:: todonote 1
		:: menu-line 1
		:: mode-line 1
		:: command-line 1 # note that disabling this means that any message will instead be draw on top of buffer
		:: line-number-mode 1
		:: empty-line-char '~'
		:: tabchar '│   '
		:: file-prompt 'Path: '
		:: command-prompt 'M-x '
		:: cancelhex '18 0'
		:: default_mode 'edit'
		:: keep-message 0
		:: help-message "Ebashs $version"
		:: dired-message 'Pick a file'
		:: log 0
		:: log-functions 0
		:: tty-linuxfb 1 # enable truecolor support for framebuffer
		:: full-redraw 0 # redraws whole buffer, can fix artifacting in linuxfb at cost of performance
		:: welcome-buffer 1 # show welcome message instead of scratch
		:: esc-to-meta 1
		
	## Key bindings configuration
	#		A keybinding is defined via either
	#		global-set; :: ... ... or add-mode <mode>; :: ... ...
	#		:: <key> <command>
	#			<key> is defined either via
	#				Hexadecimal format (with ' 0' added as suffix).
	#				Name of key like '[<key>]'
	#				Emacsy "$(kbd <key> )" (<key> being something like C-s M-e ...)
	#			The name of key and $(kbd) get translated into hex. format on startup.
	#
	#			mode-options sets magic :: to defining mode options
	#			:: option value

	global-set
		:: "$(kbd C-x)" 'prefix'
		:: "$(kbd M-x)" 'execute-extended-command'
		:: '[f10]' 'menu-top_menu'
		:: "$(kbd C-g)" 'mode-back'
		:: '[up]' 'previous-line'
		:: '[down]' 'next-line'
		:: '[right]' 'forward-char'
		:: '[left]' 'backward-char'
		:: '[next]' 'scroll-down'
		:: '[prior]' 'scroll-up'
		:: "$(kbd C-a)" 'move-beginning-of-line'
		:: "$(kbd C-e)" 'move-end-of-line'
		:: "$(kbd C-p)" 'previous-line'
		:: "$(kbd C-n)" 'next-line'
		:: "$(kbd C-f)" 'forward-char'
		:: "$(kbd M-f)" 'forward-word'
		:: "$(kbd C-b)" 'backward-char'
		:: "$(kbd M-b)" 'backward-word'
		:: "$(kbd M-v)" 'scroll-down'
		:: "$(kbd C-v)" 'scroll-up'

	add-mode edit
		:: '1b 5b 31 3b 32 41 0' select-previous
		:: '1b 5b 31 3b 32 42 0' select-next
		:: '1b 5b 31 3b 32 43 0' select-forward
		:: '1b 5b 31 3b 32 44 0' select-backward
		:: '1b 20 0' set-mark-command # in gnu emacs this is C-SPC but i cant get that to be detected in bash so M-SPC will suffice
		:: '20 0' insert-space
		:: "$(kbd C-h)" prefix-help
		:: 'RET' newline
		:: "$(kbd C-l)" newline
		:: "$(kbd M-d)" duplicate-line
		:: "$(kbd C-t)" execute
		:: "$(kbd C-d)" delete-line
		:: 'DEL' backspace
		:: '[deletechar]' delete
		:: "$(kbd M-g)" menu-key
		:: '1b 5b 48 0' move-beginning-of-line
		:: "$(kbd C-i)" indent-for-tab-command
		:: '1b 5b 46 0' move-end-of-line
		mode-options
			:: else 'insert'

	add-mode dired
		:: RET 'dired-select'
		:: "$(kbd h)" 'toggle_hidden'
	
	add-mode view
		:: RET 'quit-view'

	add-mode doc
		:: RET 'doc-select'
		:: "$(kbd C-c)" 'quit-doc'
	
	add-mode list_buffers
		:: RET 'buffer-select'
		mode-options
			:: else 'true'
	
	add-mode prefix
		:: "$(kbd C-c)" 'quit'
		:: "$(kbd C-s)" 'write_buffer'
		:: "$(kbd C-f)" 'find-file'
		:: "$(kbd C-b)" 'list-buffers'
		:: "$(kbd b)" 'switch-to-buffer'
		:: "$(kbd 0)" 'delete-buffer'
		:: "$(kbd u)" 'undo'
		mode-options
			:: always 'mode-back'
			:: disable-global 1
	
	add-mode prefix_help
		:: "$(kbd C-g)" 'mode-back'
		:: "$(kbd C-a)" 'about'
		:: "$(kbd r)" 'manual'
		:: "$(kbd f)" 'describe-function'
		:: "$(kbd C-f)" 'describe'
		mode-options
			:: disable-global 1

	add-mode menu
		:: '[up]' 'menuup'
		:: '[down]' 'menudown'
		:: 'RET' 'menuselect'
		mode-options
			:: else 'menuleave'
			:: disable-global 1

	add-mode format
		:: '[left]' format-left
		:: '[up]' format-up
		:: '[right]' format-right
		:: '[down]' format-down
		:: 'RET' link-enter
		:: "$(kbd C-c)" quit-view
		:: '[next]' 'scroll-down'
		:: '[prior]' 'scroll-up'
		:: "$(kbd C-a)" 'move-beginning-of-line'
		:: "$(kbd C-e)" 'move-end-of-line'
		:: "$(kbd C-p)" 'previous-line'
		:: "$(kbd C-n)" 'next-line'
		:: "$(kbd C-f)" 'forward-char'
		:: "$(kbd M-f)" 'forward-word'
		:: "$(kbd C-b)" 'backward-char'
		:: "$(kbd M-b)" 'backward-word'
		:: "$(kbd M-v)" 'scroll-down'
		:: "$(kbd C-v)" 'scroll-up'
		:: "$(kbd C-x)" 'prefix'
		:: "$(kbd M-x)" 'execute-extended-command'
		:: '[f10]' 'menu-top_menu'
		:: "$(kbd C-g)" 'mode-back'
		mode-options
			:: else :
			:: disable-global 1

	add-mode welcome
		:: 'RET' link-enter
		:: "$(kbd f)" find-file
		:: "$(kbd b)" dired
		:: "$(kbd m)" manual
		:: "$(kbd d)" view-page
		:: "$(kbd a)" about
		:: "$(kbd i)" inputcodes
		:: "$(kbd c)" list-faces-display
		:: "$(kbd l)" view-log
		:: "$(kbd C-c)" quit-view
		mode-options
			:: else :
		
	## Faces
	#		Defined in escape codes
	#		Helper functions:
	#			:weight
	#				normal
	#				bold
	#			:slant
	#				normal
	#				italic
	#			:background & :foreground
	#				either hex. colour, colour name, or c<index> for 256 indexed colours
	#		See extensions/gruvboxdark for another example
edit_faces=(
		# syntax highlighting
		sh-quoted-exec "$(:foreground light-yellow)"
		font-lock-variable-string-face "$(:foreground cyan)"
		font-lock-comment-face "$(:weight dim)"
		font-lock-variable-name-face "$(:foreground light-cyan)"
		font-lock-argument-face "$(:foreground light-yellow)"
		font-lock-flow-face "$(:foreground ligth-yellow)"
		font-lock-pipe-face "$(:weight bold :foreground light-blue)"
		font-lock-bracket-face "$(:weight bold :foreground light-gray)"
		font-lock-constant-face "$(:foreground light-green)"
		font-lock-string-face "$(:foreground green)"
		font-lock-assign-face "$(:foreground light-blue)"
		font-lock-function-name-face "$(:weight bold :foreground light-cyan)"
		font-lock-keyword-face "$(:foreground light-red)"
		font-lock-util-face "$(:foreground light-magenta)"
		font-lock-declare-face "$(:foreground red)"
	)
	load-theme edit_faces

	## Aliases
	#		List of aliases for M-x.
	set-alias
		:: set-buffer-file 'find-file'
		:: read-file 'read-buffer'
		:: write-file 'write-buffer'
		:: force-quit 'die'
		:: menul 'menu-top_menu'
		:: menu-file 'menu-file'
		:: input 'inputcodes'
		:: log 'view-log'

	## Menus
	#		Defined via ordered pseudo-associative double-arrays
	#			All menu items calling 'menu-top' get applied the 'menu-back' face
	#
	#		Menu top is the top menuline & f10 menu	
	#		Menu dired is the top menuline in dired buffers	
	add-menu top
		:: File menu-file
		:: Keys menu-key
		:: Help menu-help
		:: Debug menu-debug
		:: Redraw refresh

	add-menu top_menu
		:: 'File   ' menu-file
		:: 'Keys   ' menu-key
		:: 'Help   ' menu-help
		:: 'Debug  ' menu-debug
		:: 'Redraw ' refresh

	add-menu file
		:: '        BACK        ' menu-top_menu
		:: 'Quit        C-x C-c ' quit
		:: 'Visit file  C-x C-f ' find-file
		:: 'Execute         C-t ' execute
		:: 'Save        C-x C-s ' write-buffer
		:: 'Dired               ' dired
	add-menu help
		:: '        BACK        ' menu-top
		:: 'Keybinding          ' menu-key
		:: 'About               ' about

	add-menu key
	    :: '        BACK        ' menu-top_menu
		:: 'Exit        C-x C-c ' quit
		:: 'New Line    C-l | ⏎ ' newline
		:: 'Visit file  C-x C-f ' find-file
		:: 'Save file   C-x C-s ' write-buffer
		:: 'Delete Line     C-d ' delete-line
		:: 'Prev Line       C-p ' previous-line
		:: 'Next Line       C-n ' next-line
		:: 'Prev Page       C-y ' scroll-down
		:: 'Next Page       C-v ' scroll-up
		:: 'Execute         C-t ' execute
		:: 'Shell           C-s ' shell
		:: 'Force exist     M-q ' die
    add-menu debug
		:: '   BACK   ' menu-top_menu
		:: 'clear     ' clear-screen
		:: 'refresh   ' refresh
		:: 'backspace ' backspace
		:: 'right     ' forward-char
		:: 'left      ' backward-char
		:: 'inputcodes' inputcodes
		:: 'faces     ' list-faces-display

	## Syntax highlighting
	set-highlight
		:: 'shell' bash ksh dash sh mksh zsh ash oksh i\*bash 'busybox sh'
		:: 'ebashs' ebashs
		:: 'config' conf
		:: 'execline' execlineb
		:: 'format-edit' format
		:: 'dired' i\*dired
		:: 'unknown' unknown

	add-menu dired
		:: 'toggle hidden (h)' "toggle_hidden"

	add-menu dialog
		:: quit 'quit-view'

	add-menu welcome
		:: about 'about'
		:: manual 'manual'
		:: docs 'view-page'
		:: quit 'quit-view'
	
	# Navigation used in some inbuild buffers
	#format_nav="<a> about : <f> link About </f> </a> "
	#format_nav+="<a> manual : <f> link Manual </f> </a> "
	#format_nav+="<a> view-page : <f> link Documentation </f> </a>"
	format_nav="<o> id: about select: about right: obj manual text: <f> link About </f> </o> "
	format_nav+="<o> id: manual select: manual left: obj about right: obj doc text: <f> link Manual </f> </o> "
	format_nav+="<o> id: doc select: view-page left: obj manual right: next-line text: <f> link Documentation </f> </o>"
}

## Documentation
function load-doc {
	mapfile -t -O 1 top_doc <<'EOF'
<h> Documentation </h>

<tab> <link> goto doc_control : Controls </link>
<tab> <link> describe : Functions </link>
<tab> <link> goto doc_faces : Face setting </link>
EOF

	mapfile -t -O 1 doc_control <<'EOF'
<link> goto top_doc : Back </link>
<h> [ Controls ] </h>

Automatically generated list of keybindings. Click on function name to view it's documentation.
Note that currently only key set via $(kbd C-char or M-char) will show up.
EOF
	for mode in "${modes[@]}"; do
		doc_control+=(
			'</i>'
			"<h> ${mode} </h>"
			'<i-tab>'
		)
		local -n moderef="$mode"
		for ch in\
			C-a C-b C-c C-d C-e C-f C-g C-h C-i C-j C-k C-l C-m C-n C-o C-p C-q C-r C-s C-t C-u C-v C-w C-x C-y C-z :\
			M-a M-b M-c M-d M-e M-f M-g M-h M-i M-j M-k M-l M-m M-n M-o M-p M-q M-r M-s M-t M-u M-v M-w M-x M-y M-z	
		do
			[ "$ch" = ':' ] && {
				doc_control+=('')
				continue
			}
			key=${moderef[$(kbd ${ch})]}
			[ -z "$key" ] && continue
			doc_control+=(
				"<f> highlight ${ch} </f> <a> doc-select $key : <f> font-lock-function-name-face $key </f> </a>"
			)
		done
	done
	doc_control+=(
		'</i>'
	)

	mapfile -t -O 1 doc_faces <<'EOF'
<link> goto top_doc : Back </link>
<h> [ Face configuration ] </h>

Faces are set via theme arrays. Theme array consists pairs of name and value.
The first is name, second is value, then again first... second... ... ... . The
Theme array has to be then loaded via <link> doc-select load-theme : load-theme </link> function.

Faces configured via escape codes, for example:
<-> <f> blue perfectblue '\e[44m' </f>
Produces blue colored face

But <[> title Ebashs is civilised and so has nicer settings for this:
<-> <f> blue perfecterblue "$(:background blue)" </f>
or one of 256 colors:
<-> <f> blue blue256 "$(:background c18)" </f>
or if you use nice terminal even full 24 bit hex. color:
<-> <f> blue TRUEBLUE "$(:background " <-f> ansi-color-blue #0000ff </f-> ")" </f>

The face-setting functions can be combined:
<-> <f> red red <-f> cyan cyan </f> </f> <f> cyan "$(:background <f> ansi-color-cyan c44 </f> </f> <f> red :foreground <f> ansi-color-red c196 </f-> )" </f>

<-> <-> see <link> doc-select :foreground : :foreground </link> <link> doc-select :background : :background </link> <link> doc-select setface : setface </link>

The boldness and dimness can be set via <a> doc-select :weight : <f> link :weight </f> </a> function.
The inverseness can be set via <a> doc-select :mode : <f> link :mode </f> </a> function.
The slant can be set via <a> doc-select :slant : <f> link :slant </f> </a> function.

<h> Example </h>

To change faces used on this page

<-> <f> title misleading_theme </f-> =( <i> 8
<[> title title "$(:weight bold :background "#ffffff")"
<[> link link "$(:weight bold :background light-yellow)"
<[> ansi-color-blue ansi-color-blue "$(:background cyan)"
<[> ansi-color-cyan ansi-color-cyan "$(:background green)"
<[> blue blue "$(:foreground cyan)"
<[> red red "$(:foreground yellow)"
<[> font-lock-keyword-face font-lock-keyword-face ''
<[> cyan cyan "$(:foreground green)" </i>
<-> )
<-> <f> font-lock-keyword-face load-theme </f> <f> title misleading-theme </f>
EOF
}

@@ execute-extended-command
:: 'Handles M-x command prompt & execution'
function execute-extended-command {
	read-command "${options[command-prompt]}" readin || return 1
	for lcmd in "${!alias[@]}"; {
		[ "$readin" = "$lcmd" ] && {
			${alias[$lcmd]}
			return
		}
	}
	$readin			
	((noredraw)) && noredraw=0 || redraw
}

function prefix { switch-mode prefix; }
function prefix-help { switch-mode prefix_help; }

@@ save Saves current buffer references data as '$1'
function save {
	local name="$1"
	local -n savedcurrent_buffer="current_buffer${name}"
	savedcurrent_buffer="$current_buffer"
}

@@ restore Restores '$1' buffer references data to current
function restore {
	local name="$1"
	local -n savedcurrent_buffer="current_buffer${name}"
	set-buffer "${savedcurrent_buffer}"
}

@@ set-syntax
:: Picks syntax highlighting function for current filetype
function set-syntax
	if [ -n "${highlight[*]}" ] && bf_d[syntax]="syntax-${highlight[unknown]}"
	then
		for syntax_setting in "${!highlight[@]}"; {
			[ "$syntax_setting" = "${bf_d[filetype]}" ] && {
				bf_d[syntax]="syntax-${highlight[$syntax_setting]}"
			}
		}
	else
		log warn 'no highlight array... using unknown'
	fi

@@ syntax-shell
:: Syntax function for shell
:: Used faces:
	:+ '* sh-quoted-exec'
	:: '* font-lock-declare-face'
	:: '* font-lock-variable-string-face'
	:: '* font-lock-comment-face & sets comment to 1 for syntax-word function'
	:: '* font-lock-variable-name-face'
	:: '* font-lock-argument-face'
	:: '* font-lock-function-name-face'
	:: '* font-lock-flow-face'
	:: '* font-lock-pipe-face'
	:: '* font-lock-bracket-face'
	:: '* font-lock-constant-face'
	:: '* font-lock-string-face'
	:: '* font-lock-assign-face'
	:: '* font-lock-keyword-face'
	:: '* font-lock-default-face'
function syntax-shell
	case "${word}" in
		'$('*|'"$('*) set-face sh-quoted-exec;;
		*'=()'|'declare'|'local'|'typeset') set-face font-lock-declare-face;;
		'"$'*) set-face font-lock-variable-string-face;;
		'#'*) set-face font-lock-comment-face && comment=1;;
		'$'*) set-face font-lock-variable-name-face;;
		'-'*) set-face font-lock-argument-face;;
		*'()') set-face font-lock-function-name-face;;
		'||'|'&&'|';'|'&') set-face font-lock-flow-face;;
		'>'|'<'|'|'|'>>'|'<<'|'<<<') set-face font-lock-pipe-face;;
		'('|')'|'{'|'}'|'[['|']]'|'['|']') set-face font-lock-bracket-face;;
		'function') set-face font-lock-function-name-face;;
		*"'"*) set-face font-lock-constant-face;;
		*'"'*) set-face font-lock-string-face;;
		*'='*) set-face font-lock-assign-face;;
		'echo'|'return'|'case'|'esac'|'for'|'while'|'do'|'done'|'if'|'elif'|\
		'else'|'printf'|'fi'|'continue'|'exit'|'bind'|'then'|'break'|'read'|\
		'let'|'shopt'|'trap'|'set'|'eval'\
			) set-face font-lock-keyword-face;;
		*) set-face default;;
	esac

@@ syntax-ebashs
:: Syntax function for shell
:: Used faces:
	:+ '* sh-quoted-exec'
	:: '* font-lock-declare-face'
	:: '* font-lock-variable-string-face'
	:: '* font-lock-comment-face & sets comment to 1 for syntax-word function'
	:: '* font-lock-variable-name-face'
	:: '* font-lock-argument-face'
	:: '* font-lock-function-name-face'
	:: '* font-lock-flow-face'
	:: '* font-lock-pipe-face'
	:: '* font-lock-bracket-face'
	:: '* font-lock-constant-face'
	:: '* font-lock-string-face'
	:: '* font-lock-assign-face'
	:: '* font-lock-keyword-face'
	:: '* font-lock-default-face'
function syntax-ebashs
	case "${word}" in
		'$('*|'"$('*) set-face sh-quoted-exec;;
		*'=()'|'declare'|'local'|'typeset') set-face font-lock-declare-face;;
		'"$'*) set-face font-lock-variable-string-face;;
		'#'*) set-face font-lock-comment-face && comment=1;;
		'$'*|'@') set-face font-lock-variable-name-face;;
		'-'*|'::') set-face font-lock-argument-face;;
		*'()') set-face font-lock-function-name-face;;
		'||'|'&&'|';'|'&') set-face font-lock-flow-face;;
		'>'|'<'|'|'|'>>'|'<<'|'<<<') set-face font-lock-pipe-face;;
		'('|')'|'{'|'}'|'[['|']]'|'['|']') set-face font-lock-bracket-face;;
		'new'|'template'|'@def'|'@fn'|'@:') set-face font-lock-function-name-face;;
		*"'"*) set-face font-lock-constant-face;;
		*'"'*) set-face font-lock-string-face;;
		*'='*|'function') set-face font-lock-assign-face;;
		'echo'|'return'|'case'|'esac'|'for'|'while'|'do'|'done'|'if'|'elif'|\
		'else'|'printf'|'fi'|'continue'|'exit'|'bind'|'then'|'break'|'read'|\
		'let'|'shopt'|'trap'|'set'|'eval'\
			) set-face font-lock-keyword-face;;
		'set-options'|'global-set'|'define-key'|'local-set-key'|'add-mode'|'mode-options'|\
		'load-theme'|'set-alias'|'add-menu'|'@ifs'|'doc'|'_'|'__'|'copy-array'|\
		':foreground'|':background'|':mode'|'weight'|':slant'|'kbd'|'add-highlight'\
			) set-face font-lock-keyword-face;;
		*) set-face default;;
	esac

@@ syntax-execline
:: Syntax function for execline
function syntax-execline
	case "${word}" in
		'"$'*) set-face font-lock-variable-string-face;;
		'#'*) set-face font-lock-comment-face && comment=1;;
		'$'*) set-face font-lock-variable-name-face;;
		'-'*) set-face font-lock-argument-face;;
		'{'|'}') set-face font-lock-bracket-face;;
		*'"'*) set-face font-lock-string-face;;
		'execlineb'|'execline-cd'|'posix-cd'|'cd'|'execline-umask'|'posix-umask'|'umask'|\
		'emptyenv'|'envfile'|'export'|'unexport'|'fdclose'|'fdblock'|'fdmove'|'fdswap'|'fdreserve'|\
		'redirfd'|'piperw'|'heredoc'|'wait'|'getcwd'|'getpid'|'exec'|'tryexec'|'exit'|'trap'|'withstdinas'|\
		'foreground'|'background'|'case'|'if'|'ifelse'|'ifte'|'ifthenelse'|'backtick'|'pipeline'|'runblock'|\
		'define'|'importas'|'elglob'|'elgetpositionals'|'multidefine'|'multisubstitute'|\
		'fox'|'forstdin'|'forbacktickx'|'loopwhilex'|\
		'elgetopt'|'shift'|'dollarat'|\
		'eltest'|'homeof'|\
		'execline') set-face font-lock-keyword-face;;
		's6-basename'|'s6-cat'|'s6-chmod'|'s6-chown'|'s6-clock'|'s6-cut'|'s6-dirname'|'s6-dumpenv'|\
		's6-echo'|'s6-env'|'s6-expr'|'s6-false'|'s6-format-filter'|'s6-grep'|'s6-head'|'s6-hiercopy'|\
		's6-linkname'|'s6-ln'|'s6-ls'|'s6-maximumtime'|'s6-mkdir'|'s6-mkfifo'|'s6-nice'|'s6-nuke'|\
		's6-pause'|'s6-printenv'|'s6-quote-filter'|'s6-quote'|'s6-rename'|'s6-rmrf'|'s6-seq'|\
		's6-sleep'|'s6-sort'|'s6-sync'|'s6-tai64ndiff'|'s6-tail'|'s6-touch'|'s6-true'|'s6-uniquename'|\
		's6-unquote-filter'|'s6-unquote'|'s6-update-symlinks'|'seekablepipe'|\
		's6-portable-utils') set-face font-lock-util-face;;
		'rngseed'|'s6-chroot'|'s6-freeramdisk'|'s6-hostname'|'s6-logwatch'|'s6-mount'|\
		's6-pivotchroot'|'s6-ps'|'s6-swapoff'|'s6-swapon'|'s6-umount') set-face font-lock-util-face;;
		*) set-face default;;
	esac

@@ syntax-format-edit
:: Syntax function for ebashs\'s formatter
function syntax-format-edit
	case "${word}" in
		'<f>'|'<-f>'|'</f>'|'</f->'|'<u>'|'</u>'|'<tab>'|'<i>'|'</i>'|'<i-tab>'|'<h>'|'<s>'\
			)set-face font-lock-keyword-face;;
		*) set-face default;;
	esac
@@ syntax-unknown Default syntax function
:: Sets everything to default face
@fn syntax-unknown 'set-face default'

@@ syntax-list-buffers
:: Syntax function for list-buffers
function syntax-list-buffers {
	((syntaxline==2)) && {
		face hint "$word"
		return
	}
	local -n cbf_d="${word}_bf_d"
	face link "$(printf '%*s' -6 "$word")"
	face file-name "$(printf '%*s' -16 "${cbf_d[file]}")"
	face default "$(printf '%*s' -10 "${cbf_d[mode]}")"
	face font-lock-comment-face "${cbf_d[modified]} "
}

@@ syntax-dired
:: Highlighting for dired buffers
:+     '* Directories → link'
::     '* Files → default'
function syntax-dired {
	[ -d "$word" ] && set-face link
	[ -f "$word" ] && set-face default
}

@@ syntax-config
:: Basic syntax function for config files
:: Used faces:
:+     '* default'
::     '* font-lock-comment-face & sets comment to 1 for syntax-word function'	
function syntax-config
	case "${word}" in
		'#'*) set-face font-lock-comment-face && comment=1;;
		*) set-face default;;
	esac

@@ filetype
:: Detect type of file '$1':					
:+     "* If file doesn't exist → unknown"
::     "* If is COMMIT_EDITMSG → conf"
::     "* If is ebashs → ebashs"
::     "* Extension →"
::     "* Shebang →"
::     "* Special shebang #@ →"
::     "* unknown →"
function filetype {
	[ ! -f "$1" ] && {
		echo unknown
		return
	}
	#very ugly, TODO: redo this
	local filename shebang extension
	local -a filenamesplit shebangsplit
	[ $# = 0 ] && return
	[ "${1:0:1}" = '.' ] || {
		IFS='.'
		filename="${1%/}"
		filename="${filename##*/}"
		[ "$filename" = 'COMMIT_EDITMSG' ] && echo conf && return
		[ "$filename" = 'ebashs' ] && echo ebashs && return
		filenamesplit=($filename)
		extension="${filenamesplit[-1]}"
		[ "${#filenamesplit[@]}" -gt 1 ] && echo "$extension" && return
	}
	mapfile -n 1 file_data < "$1"
	shebang="$(echo -n "${file_data[@]}")"
	case "${shebang:0:2}" in
		'#!')
			shebang="${shebang%/}"
			IFS=' '
			shebangsplit=("${shebang##*/}")
			local shebangss=(${shebangsplit[-1]})
			case "${shebangss[0]}" in
				env)
					printf '%s\n' "${shebangss[1]}";;
				*)
					printf '%s\n' "${shebangsplit[-1]}";;
			esac
			;;
		'! ')
			mapfile -d ' ' -t split <<< "${shebang}"
			printf '%s\n' "${split[1]}"
			;;
		'##')
			mapfile -d ' ' -t split <<< "${shebang}"
			printf '%s\n' "${split[1]}"
			;;
		*) echo unknown
	esac
	@ifs
}

@@ find-file
:: Asks for file and opens it
function find-file {
	printf '\e[%s;0H' $((bf_d[size-y] + bf_d[loc-y]))
	printf '\e[?25h'
	bind 'set disable-completion off' 2>/dev/null # Enable completion
	read -re -p "${options[file-prompt]}" command && {
		read-buffer "$command"
		[ -n "$bckmode" ] && bf_d[mode]="$bckmode" || bf_d[mode]=edit
		redraw
	}
	bind 'set disable-completion on' 2>/dev/null
}

@@ view-format
:: Open file as formated document
function view-format {
	save openfile
	printf '\e[%s;0H' $((bf_d[size-y] + bf_d[loc-y]))
	printf '\e[?25h'
	bind 'set disable-completion off' 2>/dev/null # Enable completion
	read -re -p "${options[file-prompt]}" command && {
		read-buffer "$command"
		bf_d[syntax]=syntax-format
		bf_d[syntax-exec]=1
		[ -n "$bckmode" ] && bf_d[mode]="$bckmode" || bf_d[mode]=view
		redraw
	}
	bind 'set disable-completion on' 2>/dev/null
}

@@ insert-debug-hex
:: Adds hex code of keypress into buffer
function insert-debug-hex {
	buffer+=(
		"${k_hex[*]}"
	)
	next-line
	make-render-line
	redraw
}

@@ switch-to-buffer
:: Interactive wrapper for set-buffer
function switch-to-buffer {
	redraw
	read-command "Switch to buffer: " readin
	set-buffer "$readin"
	redraw
}

@@ list-buffers
:: Displays currently active buffers
function list-buffers {
	save openfile
	set-buffer list_buffers
	declare -Ag "${current_buffer}_bf_d"
	focus set-buffer
		:: line 1
		:: base 1
		:: column 0
		:: modified 0
		:: mode 'list_buffers'
		:: info 'Currently open buffers'
		:: filetype 'i*buffer-list'
		:: file '*Buffer List*'
		:: syntax syntax-list-buffers
		:: syntax-exec 1
		:: menuline 'about'
	[auto]
	buffer=(
		''
		'ID    FILENAME        MODE      MODIFIED'
	)
	bf_s=('')
	append-array buffers_l buffer
	redraw
	}
	
@@ buffer-select
:: Is ran on RET inside list_buffers buffer
function buffer-select {
	((bf_d[line]==1)) && return
	set-buffer "${buffer[bf_d[line]]}"
	[ "${bf_d[mode]}" = 'prefix' ] && bf_d[mode]="$bckmode"
	redraw
}

add-mode debuginput
	local-set-key "$(kbd C-x)" 'quit-view'
	local-set-mode-option else 'insert-debug-hex'
	local-set-mode-option disable-global 1
add-menu debuginput
	local-set-key 'quit-debuginput'

@@ inputcodes
:: Opens debug input buffer
function inputcodes {
	save openfile
	declare-new-buffer
		:: mode 'debuginput'
		:: info 'C-x (18 0) to close'
		:: filetype 'i*term'
		:: file '*debuginput*'
		:: modified 0
		:: syntax syntax-unknown
		:: menuline 'debuginput'
		[auto]
		
	buffer=(
		''
		'[ KEY DEBUGGER ]'
		''
		"Press any key to see Ebashs's native hex. representation of it."
		"See C-h f define-key & C-h f kbd for fancier key settings"
		''
	)
	bf_d[line]=7
	redraw
}

@@ read-buffer
:: Reads file \$1 into new buffer
function read-buffer {
	log info "reading $* ..."
	declare-new-buffer
		:: mode "${options[default_mode]}"
		:: info "${options[help-message]}"
		:: filetype "$(filetype "$1")"
		:: file "$1"
		:: menuline 'top'
		:: current_state 0
	[auto]
	((options[view])) &&	
		[ "${bf_d[filetype]}" = 'format' ] && {
			:: mode format
			:: syntax syntax-format
			:: syntax-exec 1
		}
		
	[ -f "${bf_d[file]}" ] && mapfile -t -O 1 "${current_buffer}_buffer" <"${bf_d[file]}" # Read file into an array
	
	
	# Ensure that something was actually read into the file
	[[ -n "${buffer[*]}" ]] && {
		message="Read ${#buffer[@]} lines from '${bf_d[file]}'"
	} || {
		message="'${bf_d[file]}' is empty"
	}
	bf_d[line]=1 # Indicate that we have a buffer loaded
	bf_d[modified]=0
}

@@ toggle_hidden
:: Toggles hidden files in dired buffer
function toggle_hidden {
	((hidden==0)) && hidden=1 || hidden=0
	dired
}

@@ dired
:: Open file manager in current working directory
function dired {
	declare-new-buffer
		:: info 'Dired'
		:: mode 'dired'
		:: filetype 'i*dired'
		:: file '*dired*'
		:: menuline 'dired'
		[auto]
		
	mapfile -t -O 1 buffer <<< "$(list-directory)"
	make-render
	if [[ "${buffer[1]}" ]]; then # Ensure that something was actually read into the file
		bf_d+=(
			[line]=1
			[info]="$PWD"
		)
	else
		bf_d[info]="error: empty"
	fi
	redraw
}

@@ dired-select
:: Select a item in dired buffer
	:+     '* If it is a directory cd into it and open new dired'
	::     '* If it is a file open it via read-buffer function'
function dired-select
	if [ -d "${buffer[bf_d[line]]}" ]; then
		cd "${buffer[bf_d[line]]}"
		dired
	else
		read-buffer "${buffer[bf_d[line]]}" || exit 1
		redraw
	fi

@@ init-log
:: Initializes M-x view-log buffer
function init-log {
	log=1
	declare -Ag "log_bf_d"
	declare -ng bufferlog="log_buffer"
	declare -ng bf_d="log_bf_d"
	focus set-buffer
		:: base 1
		:: column 0
		:: info 'LOG'
		:: mode 'view'
		:: help-message 'LOG'
		:: filetype 'i*view'
		:: file '*log*'
		:: modified 0
		:: syntax syntax-format
		:: syntax-exec 1
		:: menuline 'menulog'
	add-menu
		:: 'quit' 'quit-view'

	size-full

	bufferlog+=(
		''
		"<f> title Ebashs version $version </f>"
		"<tab> <f> highlight [ LOG START ] </f>"
		''
		'<f> title System info: </f> <i-tab>'
		"Bash version:  ${BASH_VERSION}"
		"System:        ${OSTYPE}"
		"Terminal type: ${TERM}"
		"Locale:        ${LANG} </i>" 
		''
		'<f> title Loaded extensions: </f>'
	)
	for e in "${extensions[@]}"; {
		local -n ext_d="${e}_ext_d"
		bufferlog+=("    $e - ${ext_d[version]}")
	}
	bufferlog+=(
		''
		'<f> hint level time function message </f>'
	)
	lasttime="$(current-time '%s')"
}

@@ view-log
:: Opens log buffer
function view-log {
	((log)) || {
		message='Error: log is not initialised'
		return
	}
	save openfile
	set-buffer log
	copy-array buffer bf_e
	clear-screen
	redraw
}

@@ buffer-dialog
:: Helper functions for creating simple popup buffers
function buffer-dialog {
	save openfile
	declare-new-buffer
		:: line 1
		:: info "$1"
		:: mode view
		:: filetype 'i*view'
		:: file "$2"
		:: modified 0
		:: syntax syntax-unknown
	size-full
}

@@ buffer-dialog-draw
:: Draws buffer created by buffer-dialog
# NOTE: To be removed
function buffer-dialog-draw {
	clear-screen
	redraw
}
	
@@ about
:: Shows about information	
function about {
	save openfile
	declare-new-buffer
		:: line 1
		:: info "About"
		:: mode format
		:: filetype 'i*format'
		:: file "*about*"
		:: modified 0
		:: syntax syntax-format
		:: syntax-exec 1
	size-full
	mapfile -t -O 1 buffer <<EOF
$format_nav

<h> Ebashs $ebashs_version </h>
Buffermaker $buffermaker_version

Copyright(č)ˇ 2022-2024 <f> title Netkv </f-> .
( <-f> title bed </f-> : Copyright(č)ˇ 2020 <f> title Comfies </f-> .)

This is Ebashs, one component of the Bash/Bash operating system.

An editor written in pure bash via nonsense sphagetti code trying copying emacs.

Repo <s> 19 <f> link https://github.com/aeknt/spis </f>
<s> 24 Ebashs comes with ABSOLUTELY NO WARRANTY




Based on <s> 15 <f> link https://github.com/comfies/bed </f>


<tab> <f> hint For more information about usage of Ebashs, press <f> light-gray C-h C-r </f> to view </f> <link> manual : manual </link>

<i> 5
<f> dr                          .............. </f>
<f> lr                       @***%@@@@@@@@@@@@... </f>
<f> dr                ** .*@@@@@@@@@@@@@@@@@@@@@.. </f>
<f> dy                .       @@&....,,#@@@@@@@@ </f>
<f> ly                 ....,@@@@@@@@@@@@@@@@@@ </f>
<f> dy             /@@@@@@@@@@@@@@@@@@@@@@. </f>
<f> dg           @@@@@@@,,...@@@&.. </f>
<f> lg         .@@@@@@@@@@@,,@@@&. </f>
<f> dg         ..@@@@@@@@@@@@@@@&.. </f>
<f> dc           .../@@@@@@@@@@@@@@..... </f>
<f> lc              ....@@@@@@@@@@@@@@@&.... </f>
<f> dc              ..(#@@@@@@@@@@@@@@@@@@@ </f>                                    
<f> db         ./@@@@@@@@@@@@@@@@%...... </f>
<f> lb     .@@@@@@@@@@@@@@@@.@@@&. </f>
<f> db   @@@@@@@@@@@@@@..   .@@@&. </f>
<f> dm  .@@@@@@@@@@@@.      .@@@&. </f>
<f> lm ..@@@@@@@@@@@@/.......@@@&. </f>
<f> dm  ...,@@@@@@@@@@@@@@@@@@@@&................. </f>
<f> gr      ...@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@.. </f>
<f> dw          ....../@@@@@@@@@@@@@@@@@@@@@@@@@@@@@# </f>
<f> lw                   ..,,,,*##@@@@@@@@@@@@@@@.      .###################. </f>
<f> dw                 @@@@@@@@@@@@@@@@@@@@..        @@@@@@@@@@@@@@@@@@@@@@ </f>
<f> gr              /@@@@@@@/........              @@@@@@@@@@@@@@@@@@@@. </f>
</i>                                                                              
                                                                                

<i> 2 <f> hint ─[ <-f> light-cyan bsd0 </f-> ]───────────────────────────────────────────────────────────────────────────────────── </f->
Permission to use, copy, modify, and/or distribute this software for any purpose
with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
<f> hint ──────────────────────────────────────────────────────────────────────────────────────────── </f> </i>

EOF
	redraw
}

@@ view-page
:: Display formated text nicely	
function view-page {
	save openfile
	declare-new-buffer
		:: line 3
		:: column 4
		:: info "view"
		:: mode format
		:: filetype 'format'
		:: file "*view*"
		:: modified 0
		:: isfile 0
		:: syntax syntax-format
		:: syntax-exec 1
	size-full
	clrmsg=0	
	message='loading...'
	redraw-commandline
	load-doc
	copy-array top_doc buffer
	redraw
}

@@ list-faces-display
:: Displays list of faces
function list-faces-display {
	save openfile
	declare-new-buffer
		:: line 1
		:: info "$1"
		:: mode view
		:: filetype 'i*view'
		:: file '*format*'
		:: modified 0
		:: syntax syntax-format
		:: syntax-exec 1
	size-full
	buffer=('')
	for face in "${!faces[@]}"; do
		buffer+=(
			"$(printf '%*s' -40 "${face}") <f> ${face} abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ </f>"
		)
	done
	buffer-dialog-draw
}

@@ list-data-display
:: Displays list of data of buffer from bf_d array	
function list-data-display {
	read-command "List data of buffer: " readin
	local -n bdata="${readin}_bf_d"
	buffer-dialog faces 'data' '*list-data-display*'
	buffer=('')
	for datum in "${!bdata[@]}"; do
		buffer+=(
			"$(
			printf '%*s%s' -20 "${datum}" "${bdata[${datum}]}"
		)"
		)
	done
	buffer-dialog-draw
}

@@ list-options-display
:: Displays list of options
function list-options-display {
	buffer-dialog faces '*list-data-display*'
	buffer=('')
	for option in "${!options[@]}"; do
		buffer+=(
			"$(
				printf '%*s%s' -20 "${option}" "${options[${option}]}"
			)"	
		)
	done
	buffer-dialog-draw
}

@@ table-init
:: Initializes bml \(bash markup language\) table
function table-init {
	table_columns="$1"
	shift
	local -i i=0
	for col in "$@"; do
		local -n n="table_column_$i"
		n="$col"
		((i++))
	done
}

@@ table-char
:: Sets style of bml table
function table-char
	if (( ${#@} == 11 )); then
		table_char=("$@")
	else
		table_char=(─ │ ┌ ┬ ┐ ├ ┼ ┤ └ ┴ ┘)
	fi

@@ table-top
:: Prints top line of bml table
function table-top {
	printf '%s' "<f> hint ${table_char[2]}"
	for ((i=0; i<table_columns; i++)); do
		local -n n="table_column_$i"
		for ((ii=1; ii-1<n; ii++)); do
			printf '%s' "${table_char[0]}"
		done
		((i==table_columns-1)) || printf '%s' "${table_char[3]}"
		((i==table_columns-1)) && printf '%s' "${table_char[4]}"
	done
	printf '%s\n' ' </f->'
}

@@ table-title-line
:: Prints bml table title divider
function table-title-line {
	printf '%s' "<f> hint ${table_char[5]}"
	for ((i=0; i<table_columns; i++)); do
		local -n n="table_column_$i"
		for ((ii=1; ii-1<n; ii++)); do
			printf '%s' "${table_char[0]}"
		done
		((i==table_columns-1)) || printf '%s' "${table_char[6]}"
		((i==table_columns-1)) && printf '%s' "${table_char[7]}"
	done
	printf '%s\n' ' </f->'
}
@fn table-divider 'table-title-line "$@"'

@@ table-bottom
:: Prints bottom line of bml table
function table-bottom {
	printf '%s' "<f> hint ${table_char[8]}"
	for ((i=0; i<table_columns; i++)); do
		local -n n="table_column_$i"
		for ((ii=1; ii-1<n; ii++)); do
			printf '%s' "${table_char[0]}"
		done
		((i==table_columns-1)) || printf '%s' "${table_char[9]}"
		((i==table_columns-1)) && printf '%s' "${table_char[10]}"
	done
	printf '%s\n' ' </f->'
}

@@ table-item
:: Prints line of table
function table-item {
	local -i i=0
	for item in "$@"; do
		local -n n="table_column_$i"
		printf '%s' "<f> hint ${table_char[1]} </f-> "
		printf '%s' "$item"
		printf '%*s' $(( n - ${#item} )) ''
		((i++))
	done
	printf '%s' "<f> hint ${table_char[1]}"
	printf '%s\n' ' </f->'
}

@@ table-title
:: Prints title of table
function table-title {
	local -i i=0
	for title in "$@"; do
		local -n n="table_column_$i"
		printf '<f> hint %s' "${table_char[1]} </f->"
		printf '%*s' $(( n / 2 - ( ${#title} / 2 ) )) ''
		printf '%s' " <-f> title $title </f-> "
		if ((${#title}%2==0)) && ((n%2==1)); then
			printf ' %*s' $(( ( n / 2 - ( ${#title} / 2 ) ) + 1 )) ''
		else
			printf ' %*s' $(( n / 2 - ( ${#title} / 2 ) )) ''
		fi
		((i++))
	done
	printf '%s' "<f> hint ${table_char[1]}"
	printf '%s\n' ' </f->'
}

@@ code-block
:: Prints code in bml document
function code-block while read -r; do echo " <-f> light-cyan $REPLY </f-> "; done

@@ print-stdin
:: Basically like coreutil "'cat'"
function print-stdin while read -r; do echo "$REPLY"; done

@@ text
:: Prints normal text in bml document
function text
	while read -r; do
		l=${#REPLY}
		for ((i=0; i<l; i+=(bf_d[size-x]/3)*2)); do
			printf '%s%s\n' "$1" "${REPLY:i:(bf_d[size-x]/3)*2}"
		done
	done

@fn title 'printf "[ <f> title %s </f> ]" "$@"'
@fn code 'printf "$@"'

@@ header
:: Prints header of bml document
function header {
	arg=$*
	table-init 1 $(( ${#arg} * 2 ))
	table-char ═ ║ ╔ X ╗ X X X ╚ X ╝
	print-stdin <<-EOF2
                                 $(table-top)
                                 $(table-title "${1}")
                                 $(table-bottom)
	EOF2
}

@@ manual
:: 'Displays C-h r manual buffer'
function manual {
	save openfile
	declare-new-buffer
		:: line 1
		:: info "About"
		:: mode view
		:: filetype 'i*format'
		:: file "*about*"
		:: modified 0
		:: syntax syntax-format
		:: syntax-exec 1
	size-full
	get-manual
	redraw
}
	
@@ get-manual
:: Parses manual bml document
function get-manual {
	#DO NOT edit following lines, makedoc handles them automatically
	# MAKEDOC INSERT README START
mapfile -t -O 1 buffer <<EOF
$(text <<EOF2
This is Ebashs, one component of the Bash/Bash operating system.
… or even better an attempt to clone GNU Emacs in bash.
EOF2
)

$(text '    '<<EOF2
Note that the readme, may be currently outdated as I am changing the core functioning of Ebashs.

Versions of Ebashs ending in WIP-x are and will be broken, you can check version via M-x about or by reading the second line of Ebashs script.
EOF2
)

$(text '    '<<EOF2
For more updated help run inside Ebashs $(code 'M-x describe') or $(code 'C-h C-f')
EOF2
)

$(text <<EOF2
Update: Ebashs was split into two parts, the editor (Ebashs) and the underlying tui framework (Buffermaker). This split isn't yet complete and using Buffermaker for programs other than Ebashs is very experimental (see testapp example).

Update 2: Buffermaker has been separated into https://github.com/aeknt/BufferMaker. Ebashs now includes its internal version of BufferMaker library to prevent breaking when I randomly decide to change core functions, and to make using Ebashs easier.
EOF2
)

$(header EBASHS)

$(title DESCRIPTION)

$(text <<EOF2
An attempt to clone GNU Emacs but in bash.
EOF2
)

$(title FEATURES)

$(text <<EOF2
syntax highlighting
custom keybindings
custom modes -- so you can implement the evil too
file picker
mouse support
EOF2
)

$(title CONFIG)

$(text <<EOF2
Ebashs is configured via variables defined at start, you can separate it into file and then source it.
EOF2
)

    $(title 'OPTIONS ARRAY')

$(table-init 3 19 19 39; table-char
print-stdin <<EOF2
    $(table-top)
    $(table-title NAME DEFAULT DESCRIPTION)
    $(table-title-line)
    $(table-item mouse ' 0' 'enable mouse at launch')
    $(table-item todonote ' 1' "highlight 'TODO:' & 'NOTE:'")
    $(table-item menuline ' 1' 'display menuline')
    $(table-item tabchar "$(code '|   ')" 'what should tab display as')
    $(table-item file_prompt "'Path: '" 'file setting prompt')
    $(table-item cmd_prompt "'M-x '" 'command line prompt')
    $(table-item cancelhex "'18 0' (C-x)" 'keybinding to exit debug input menu')
    $(table-item default_mode ' edit' 'what mode should be set on launch')
    $(table-item help_message "'F10 to open menu'" 'top right help message')
    $(table-item dired_message "'Pick a file'" 'same as above but for dired buffer')
    $(table-bottom)
EOF2
)

    $(title 'KEYBINDING ARRAYS')

$(text '    ' <<EOF2
Keybinding arrays match with modes. The array has to be associative and nammed $(code 'keys_<mode>'). $(code 'keys_def') is reserved and used as reference for other arrays, it's also reversed compared to other keybinding arrays.
EOF2
)

$(text '     ' <<EOF2
Keybindings are defined via hexadecimal syntax suffixed with ' 0'. Function $(code '@kbd field') is equivalent to $(code '${keys_def[field]}') but nicer. Function kbd provides Emacsy keybinding syntax.
EOF2
)

$(text '    ' <<EOF2
There is also a optionable option array possible for all keybinding arrays. Currently only defined option is [else] which defines what should happen if no key is matched from the keybinding. These arrays have to be named $(code 'key_options_<mode>').
EOF2
)

    $(title MODES)

$(text '    ' <<EOF2
Modes determine used keybinding and other properties of buffer.
EOF2
)

$(table-init 2 19 43; table-char
print-stdin <<EOF2
    $(table-top)
    $(table-title NAME DESCRIPTION)
    $(table-title-line)
    $(table-item edit "general editing mode")
    $(table-item dired "mode used in file picker")
    $(table-item view "read-only mode")
    $(table-item menu "mode of menus")
    $(table-item debuginput "for getting input codes (M-x input)")
    $(table-item prefix "for C-x prefix")
    $(table-item prefix_help "for C-h prefix")
    $(table-item quit "for quit confirmation")
    $(table-item list_buffers "used in buffer switcher")
    $(table-bottom)
EOF2
)

    $(title STYLE)

$(text '    ' <<EOF2
Style of stuff is defined as escape code. See extensions/gruvboxdark for example of custom theme.
EOF2
)

$(table-init 3 32 19 39; table-char
print-stdin <<EOF2
    $(table-top)
    $(table-title NAME DEFAULT DESCRIPTION)
    $(table-title-line)
    $(table-item default ' \e[m' 'Default face')
    $(table-item TODO ' \e[0;97;45m' "Highlighting of 'TODO: '")
    $(table-item NOTE ' \e[0;97;100m' "Highlighting of 'NOTE: '")
    $(table-item menu ' \e[0;37;40' 'Menuline')
    $(table-item menu-enabled-face ' \e[0;37;40' 'Items of menuline')
    $(table-item selected ' \e[30;45m' 'Selected item')
    $(table-item link ' \e[94m' 'Redirects')
    $(table-item menu-selected-face ' \e[30;45m' 'Selected item of menu')
    $(table-item mode-line ' \e[40;97m' 'Bottom statusline')
    $(table-item line-number ' \e[0;90m' 'Line count')
    $(table-item line-number-empty ' \e[0;90m' 'Lines that do not exist')
    $(table-item line-number-current-line ' \e[0;91m' 'Currently selected line')
    $(table-item tab-face ' \e[0;90m' 'Tabs')
    $(table-item minibuffer-prompt ' \e[m' 'Bottom commandline')
    $(table-divider)
    $(table-item font-lock-variable-string-face ' \e[0;36;48m' 'Quoted variables')
    $(table-item font-lock-comment-face ' \e[3;37;48m' 'Comments')
    $(table-item font-lock-variable-name-face ' \e[0;96m' 'Variables')
    $(table-item font-lock-argument-face ' \e[0;93m' 'Options')
    $(table-item font-lock-flow-face ' \e[0;93m' 'Control flow')
    $(table-item font-lock-pipe-face ' \e[1;94m' 'Pipes')
    $(table-item font-lock-bracket-face ' \e[1;95m' 'Brackets')
    $(table-item font-lock-constant-face ' \e[0;92m' 'Constants')
    $(table-item font-lock-string-face ' \e[0;32m' 'Strings')
    $(table-item font-lock-assign-face ' \e[0;94;108m' 'Variable assignments')
    $(table-item font-lock-function-name-face ' \e[0;30;44m' 'Function definitions')
    $(table-item font-lock-declare-face ' \e[0;91m' 'Keywords')
    $(table-bottom)
EOF2
)
$(text '    ' <<EOF2
Ebashs also includes the ansi-color-* faces, see M-x list-faces-display for full list.
EOF2
)

    $(title SYNTAX)

$(text '    ' <<EOF2
Defines which syntax functions should be used for which file types.
EOF2
)

    $(title MENULINE)

$(text '    ' <<EOF2
Defines items in menuline, content of keys defines which functions should be ran on invocation.
EOF2
)

    $(title MENUS)

$(text '    ' <<EOF2
Each menu has to have helper function to set it up on request:
EOF2
)
$(code-block bash <<EOF2
        <menu>() { declare -ng menucon=<menu>; menu; }
EOF2
)
$(text '    ' <<EOF2
The contents of menu are defined by an associative  array.
EOF2
)

    $(title ALIAS)

$(text '    ' <<EOF2
Defines aliases that can be used in $(code 'M-x').
EOF2
)
$(text '    ' <<EOF2
Use function $(code add-alias name command) to define.
EOF2
)

$(title EXTENDING)

$(text <<EOF2
Some of useful variables and for extending Ebashs
EOF2
)

$(table-init 2 19 43; table-char
print-stdin <<EOF2
$(table-top)
$(table-title NAME DESCRIPTION)
$(table-title-line)
$(table-item buffer 'File data')
$(table-item buffersyntax 'Multidimensional buffer for rendering')
$(table-item bufferexpand 'Special characters filtered out')
$(table-item bufferdata 'Options of current buffer')
$(table-item charmap 'Definitions for bufferexpand')
$(table-item mode 'Current mode')
$(table-item commands 'List of M-x commands')
$(table-bottom)
EOF2
)

$(title 'SYNTAX HIGHLIGHTING')

$(text <<EOF2
Ebashs handles highlighting via checking 'syntax' array which consists of $(code '[file type]=syntax-function')
EOF2
)

    $(title 'SYNTAX FUNCTIONS')

$(text '    ' <<EOF2
Here is sample bash syntax function included with Ebashs:
EOF2
)

$(code-block bash <<EOF2
    set-highlight
        :: shell bash ksh dash sh mksh zsh ash oksh i*bash

	defun syntax-shell
		:: Syntax function for shell
		:: Used faces:
		:: '    * font-lock-declare-face'
		:: '    * font-lock-variable-string-face'
		:: '    * font-lock-comment-face & sets comment to 1 for syntax-word function'
		:: '    * font-lock-variable-name-face'
		:: '    * font-lock-argument-face'
		:: '    * font-lock-function-name-face'
		:: '    * font-lock-flow-face'
		:: '    * font-lock-pipe-face'
		:: '    * font-lock-bracket-face'
		:: '    * font-lock-constant-face'
		:: '    * font-lock-string-face'
		:: '    * font-lock-assign-face'
		:: '    * font-lock-keyword-face'
		:: '    * font-lock-default-face'
		function =
			case "${word}" in
				*'=()'|'declare'|'local'|'typeset') set-face font-lock-declare-face;;
				'"$'*) set-face font-lock-variable-string-face;;
				'#'*) set-face font-lock-comment-face && comment=1;;
				'$'*) set-face font-lock-variable-name-face;;
				'-'*) set-face font-lock-argument-face;;
				*'()') set-face font-lock-function-name-face;;
				'||'|'&&'|';'|'&') set-face font-lock-flow-face;;
				'>'|'<'|'|'|'>>'|'<<'|'<<<') set-face font-lock-pipe-face;;
				'('|')'|'{'|'}'|'[['|']]'|'['|']') set-face font-lock-bracket-face;;
				'function') set-face font-lock-function-name-face;;
				*"'"*) set-face font-lock-constant-face;;
				*'"'*) set-face font-lock-string-face;;
				*'='*) set-face font-lock-assign-face;;
				'echo'|'return'|'case'|'esac'|'for'|'while'|'do'|'done'|'if'|'elif'|\\
					'else'|'printf'|'fi'|'continue'|'exit'|'bind'|'then'|'break'|'read'|\\
					'let'|'shopt'|'trap'|'set'|'eval'\\
						) set-face font-lock-keyword-face;;
				*) set-face default;;
			esac
EOF2
)

$(text '    ' <<EOF2
The comments are handled specially via comment variable which gets reseted at every newline.
EOF2
)

$(title EXAMPLES)

$(text <<EOF2
A simple function to jump to line 11 when $(code 'C-x M-e') is pressed:
EOF2
)

$(code-block bash <<EOF2
    keys_prefix+=( # prefix is the mode for C-x
        [1b 65 0]='jump-to-11' # '1b 65 0' is the M-e in hex.
                               # You can use the M-x input to convert to hex. format.
    )
    jump-to-11() {
        [[ -n "${buffer[11]}" ]] && line=11 # If line 11 exists, set current line to 11.
        [[ "${bufferdata[mode]}" = 'prefix' ]] && quit-prefix
                                    # Since the key stroke contains C-x as prefix,
                                    # quit-prefix is is required as otherwise
                                    # it would stay in 'prefix' mode.
        redraw # Redraw whole buffer.
    }
EOF2
)

$(text <<EOF2
A function to write $(code 'Hello world!') at current cursor position when $(code 'M-x hi') is typed
EOF2
)

$(code-block bash <<EOF2
    commands+=(
        [hi]='hello-world' # Add command 'hi' invoking 'hello-world' function:
    )
    hello-world() {
        insert-word 'Hello-world!' # The function 'insert-word' handles insertion
                                   # of stuff, so no redraw or other magic is needed.
    }
EOF2
)

$(text '    ' <<EOF2
Create a menu containing previous functions $(code 'jump-to-11') & $(code 'hello-world'):
EOF2
)

$(code-block bash <<EOF2
    example-menu-function() { declare -ng menucon='example_menu'; menu; }
    # A function with which the menu will be invoked.

    declare -A example_menu
    example_menu=(
        [Jump to 11  ]='jump-to-11'  # The names of items in menu should have
        [Hello world!]='hello-world' # same width to display correctly.
    )

    # Add the example_menu into default menuline
    menulineedit+=(
        [Example]='example-menu-function'
    )
EOF2
)

$(title ETC)

$(text <<EOF2
Logo and it's krita file is in etc/

This readme is generated from doc/README.bml via makedoc script.
EOF2
)

$(title CREDITS)

$(text '    ' <<EOF2
Based on https://github.com/comfies/bed
EOF2
)

$(text '    '<<EOF2
fff by Dylan Araps https://github.com/dylanaraps/fff as base for extensions/efff
Licensed under the MIT license see extensions/efff for details
EOF2
)

$(text '    '<<EOF2
Early versions of Ebashs/Bano can be found at
https://github.com/aeknt/bashbox/blob/master/bin/nano
https://github.com/aeknt/bashbox/blob/master/bin/bano
EOF2
)
EOF
	# MAKEDOC INSERT README STOP
}

defun describe-function
	:: Displays help and info of function
	function = {
		redraw
		read-command 'Describe function: ' function || return 1
	    doc-select "$function"
	}

defun describe
	:: Displays help and info of all functions
	function = {
	    save openfiledoc
		declare-new-buffer
			:: line 9
			:: base 1
			:: column 0
			:: info "Documentation"
			:: mode format
			:: filetype 'format'
			:: file "*functions*"
			:: modified 0
			:: syntax syntax-format
			:: syntax-exec 1
			:: menuline 'dialog'
		size-full
		buffer=(
			''
		    "$format_nav"
			''
			'<f> title <u> Functions </u> </f>'
			'<i-tab>'
			'Documentation of these function is defined via internal pseudo-comments.'
			'It consists of the description and the source code. The source code is formated automatically'
			'by Bash and differs greatly from the formating of real source code.'
			'</i>'
)
		while read -r fn;  do
			buffer+=("<a> doc-select ${fn:11} : <f> link ${fn:11} </f> </a>")
		done <<< "$(declare -F)"
		buffer+=(
			''
			"<tab> <f> font-lock-comment-face Ebashs $version </f>"
		)
		redraw
}

defun doc-select	
	:: Select documentation item
	function = {
		local function="$@"
	    save openfile
		declare-new-buffer
			:: line 5
			:: info "Describe"
			:: mode format
			:: format-else quit-view
			:: filetype 'format'
			:: file "*describe*"
			:: modified 0
			:: syntax syntax-format
			:: syntax-exec 1
			size-full
		buffer=(
			''
			"$format_nav"
			''
		)
		mapfile -t -O 3 buffer <<< "$(get-description "$function")"
	    redraw
	}
nufed

@@ doc-goto
:: Replace function documentation with function \$1.
:: 'See <a> doc-goto get-description : <f> link get-description </f> </a> for more details.'
function doc-goto {
	clear-buffer
	bf_d[line]=1
	bf_d[column]=0
    buffer=(
		''
		"$format_nav"
		''
	)
	mapfile -t -O 3 buffer <<< "$(get-description "$1")"
	redraw
}

defun quit-doc
	:: Quits and restores previous buffer.
	function = {
		restore openfiledoc
		redraw
	}

defun get-description
	:: Prints desciption of function \$1
	function = {
		is-function "$1" || {
			echo "<f> highlight $1 is not a Ebashs function </f>"
			return
		}
		printf "%s\n" "<f> title [ $1 ] </f>"
		[ -z "${descriptions[function_${1}_description]}" ] && {
			echo 'Function has no documentation'
			return
		}
		local -n fn_desc="${descriptions[function_${1}_description]}"
		((${#fn_desc[@]})) && {
			echo
			for l in "${fn_desc[@]}"; {
				printf "%s\n" "$l"
			}
			#for i in {0..8}; {
			#	printf '\n'
			#}
			#printf '<f> title [ Source ] </f>\n <change-syntax> 0 shell\n'		 
			#declare -f -- "$1"
		}
	}

defun quit-view
	:: Quits and restores previous buffer.
	:: Used mainly for dialog buffers.
	function = {
		restore openfile
		redraw
	}
nufed

@@ duplicate-line Copies line
function duplicate-line {
	newline # create new empty line
	buffer[bf_d[line]-1]="${buffer[bf_d[line]]}" # copy current line to previous line
	#make-render-area $((bf_d[line]-1)) $((bf_d[line]))
	local -n lap="${current_buffer}_syntax$((bf_d[line]-1))"
	local -n lac="${current_buffer}_syntax$((bf_d[line]))"
	copy-array lac lap
	redraw
}
	
@@ newline
:: Inserts newline to current buffer at current cursor position, shift lines
:: below one line down and go down one line.
function newline {
	bf_d[modified]=1
	save-state
	buffer=('' "${buffer[@]:1:${bf_d[line]}-1}" '' "${buffer[@]:${bf_d[line]}}")
	buffer[bf_d[line]]="${buffer[${bf_d[line]}+1]:0:${bf_d[column]}}"
	buffer[bf_d[line]+1]="${buffer[${bf_d[line]}+1]:${bf_d[column]}:${#buffer[${bf_d[line]}+1]}}"
	bf_d[column]=0
	syntax-shift
	no_cursor=1
	redraw
	no_cursor=0
	next-line
}

@@ syntax-shift
:: Moves syntax multibuffer from current cursor position one line to the bottom.
:: Used in newline function.
::
:: Is currently very badly implemented, TODO: fix.
function syntax-shift {
	local -a tmp1
	local -a tmp2
	local extmp1
	local extmp2
	for ((l=bf_d[line];l<${#buffer[@]}+1;l++)); do
		local -n linearray="${current_buffer}_syntax${l}"
		copy-array linearray tmp1
		copy-array tmp2 linearray
		copy-array tmp1 tmp2
		extmp1="${bf_e[l]}"
		bf_e[l]="$extmp2"
		extmp2="$extmp1"
	done
	bf_s[buffer_length]="${current_buffer}_syntax${bf_d[number-length]}"
	unset tmp1 tmp2
	make-render-area $((bf_d[line])) $((bf_d[line]+2))
}

defun delete-line
	:: Deletes line at current cursor position
	function = {
		bf_d[modified]=1
		buffer-delete-line "${bf_d[line]}"
		((bf_d[line] == 1)) || previous-line
		redraw
	}

defun buffer-delete-line
	:: Deletes line at \$1
	function = {
		local -i l=$1
		save-state
		buffer=("" "${buffer[@]:1:l-1}" "${buffer[@]:l+1}")
		bf_s=("" "${bf_s[@]:1:l-1}")
	}

fragment getrlr <<'+'
	local -i rlr
	unset ta
	local ta
	ta=${bf_e[${bf_d[line]}]:0:${bf_d[column]}}
	ta=${ta//[^t]}
	ta=${#ta}
	rlr=$((bf_d[column] + ta / 4 - ta))
+

fragment predelete <<'+'
	((bf_d[selection])) && {
		delete-selection
		return
	}
	((${#buffer[${bf_d[line]}]} == 0 )) && {
		delete-line
		bf_d[column]="${#buffer[${bf_d[line]}]}"
		redraw
		return 0
	}
+

defun-fragment backspace
	:: Deletes previous character
	function = {
		save-state
		@ predelete
		@ getrlr
		((rlr==0)) && {
			buffer[bf_d[line]-1]="${buffer[bf_d[line]-1]}${buffer[bf_d[line]]}"
			delete-line
			bf_d[column]=${#bf_e[${bf_d[line]}]}
			redraw
			return 0
		}
		buffer[${bf_d[line]}]="${buffer[${bf_d[line]}]:0:$(( rlr - 1 ))}${buffer[${bf_d[line]}]:${rlr}}"
		backward-char #go back with cursor
		make-render-line # copy the buffer into bf_s and bf_e
		redraw #draw it
		bf_d[modified]=1
	}

defun-fragment delete
	:: Deletes next character
	function = {
		save-state
		@ predelete
		@ getrlr
		((rlr==${#buffer[bf_d[line]]})) && {
			buffer[bf_d[line]]="${buffer[bf_d[line]]}${buffer[bf_d[line]+1]}"
			move-next-line
			delete-line
			bf_d[column]=${#bf_e[${bf_d[line]}]}
			redraw
			return 0
		}
		buffer[bf_d[line]]="${buffer[bf_d[line]]:0:rlr}${buffer[bf_d[line]]:rlr+1:${#buffer[bf_d[line]]}}"
		make-render-line # copy the buffer into bf_s and bf_e
		redraw #draw it
		bf_d[modified]=1
	}

defun delete-selection
	:: Deletes region
	function = {
		_ sy bf_d[selection_start_y]
		_ ey bf_d[selection_end_y]
		_ sx bf_d[selection_start_x]
		_ ex bf_d[selection_end_x]
		((sy == ey)) && {
			((sx > ex)) && __ sx ex
			buffer[sy]="${buffer[sy]:0:sx}${buffer[sy]:ex}"
			bf_d[column]=$sx
			make-render-area $sy $((sy+1))
		} || {
			((sy > ey)) && {
				__ sy ey
				__ sx ex
			}
			buffer[sy]="${buffer[sy]:0:sx}"
			buffer[ey]="${buffer[ey]:ex}"
			buffer=("" "${buffer[@]:1:sy}" "${buffer[@]:ey}")
			bf_s=("" "${bf_s[@]:1:sy-1}")
			buffer[sy+1]="${buffer[sy]}${buffer[sy+1]}"
			buffer=("" "${buffer[@]:1:sy-2}" "${buffer[@]:sy}")
			bf_d[line]=$sy
			bf_d[column]=$sx
		}
		bf_d[selection]=0
		redraw
		_ # unset reference aliases
	}

defun write-buffer
	:: Writes current buffer into its target file	
	function =
		if [ -w "${bf_d[file]}" ]; then
			dump-buffer "${bf_d[file]}"
			bf_d[modified]=0
			message="Wrote ${#buffer[@]} lines to \'${bf_d[file]}\'"
		else
			return 1
		fi

add-mode quit
	local-set-key "$(kbd y)" 'save-quit'
	local-set-key "$(kbd n)" 'die'
	local-set-key "$(kbd c)" 'quit-quit'
	local-set-key "$(kbd C-y)" 'save-quit-force'

defun save-quit-force
	:: Force saving file
	function = {
		dump-buffer "${bf_d[file]}"
		die
	}
	
defun save-quit
	:: Writes buffer if target is writable
	function =
		if write-buffer; then
			die
		else
			message='File is not writable! [n/c] (to force save C-y)'
			redraw-commandline
		fi

defun quit-quit
	:: Quits quit message
	function = {
		bf_d[mode]="$bckmode"
		message='Quit canceled'
		redraw
	}

defun quit
	:: Displays quit message and sets mode to \'quit\'
	function = {
		[ -n "${bf_d[isfile]}" ] && ((bf_d[isfile]==0)) || ((bf_d[modified]==0)) && {
			die
		}
		
		[ -z "$bckmode" ] && bckmode="${bf_d[mode]}"
		bf_d[mode]='quit'
		redraw-statusline
		printf '\e[%s;0H' $((bf_d[size-y] + bf_d[loc-y]))
		printf '%s' 'Buffer modified, save before close? [y/n/c]'
	}

defun set-mark-command
	:: Begins selection	
	function =
		if ((bf_d[selection])); then
			log info 'selection disable'
			bf_d[selection]=0
		else
			bf_d[selection]=1
			bf_d[selection_start_y]="${bf_d[line]}"
			bf_d[selection_start_x]="${bf_d[column]}"
			log info 'selection enable'
		fi

defun shell
	:: Spawns bash as subprocess
	function = {
		clear-screen
		bash # NOTE: in theory an external command
		redraw
	}

defun execute
	:: Executes a command and inserts its output into buffer	
	function = {
		((bf_d[line] == 0)) && return # If the line is not possible, do nothing
		printf '\e[?25h\e[%sH' "$((bf_d[line] + 2 - bf_d[base]))" # Reset cursor position and enable cursor
		read -re -p "$(printf '%4s ' "$")" # Present editable line
		if [[ "$REPLY" != "${buffer[${bf_d[line]}]}" ]]; then # If the line is changed, update and inform
			buffer[${bf_d[line]}]="$($REPLY)"
			bf_d[modified]=1
		fi
		make-render-line
		redraw
	}

defun diff-buffer-syntax
	:: Deletes highlighting on modified lines, comparing two buffers
	function = {
		# remove outdated lines from bf_s to set them for resyntaxing
		local -n source="$1"
		local -n target="$2"
		for idx in "${!target[@]}"; do
			[ "${source[idx]}" = "${target[idx]}" ] || bf_s[idx]=
		done
	}

defun diff-buffer-copy
	:: Compares two buffers and copies the difference into \$3 buffer
	function = {
		local -n source="$1"
		local -n check="$2"
		local -n target="$3"
		[ -z "${source[*]}" ] && return 1 # | indicate that there's no previous buffer state to check against 
		[ -z "${check[*]}"  ] && return 1 # | should indicate save-state() to just copy the whole buffer
		target=()
		for idx in "${!source[@]}"; do
			[ "${source[idx]}" = "${check[idx]}" ] || target[idx]="${source[idx]}"
			[ "${source[idx]}" = "${check[idx]}" ] && target[idx]=''
		done
	}

defun diff-buffer-merge
	:: Add buffer \$1 on top of \$2
	function = {
		local -n source="$1"
		local -n target="$2"
		for idx in "${!source[@]}"; do
			[ -n "${source[idx]}" ] && target[idx]="${source[idx]}"
		done
	}

defun save-state
	:: Saves current buffer for undo function
	function = {
		((bf_d[current_state]++))
		declare -ga "${current_buffer}_buffer_state_${bf_d[current_state]}"
		diff-buffer-copy\
			buffer\
			"${current_buffer}_buffer_state_$((bf_d[current_state]-1))"\
			"${current_buffer}_buffer_state_${bf_d[current_state]}" || {
			copy-array buffer "${current_buffer}_buffer_state_${bf_d[current_state]}"
		}
	}

defun undo
	:: Undo a change
	function = {
		((bf_d[current_state]--))
		((bf_d[current_state]<0)) && {
			bf_d[current_state]=0
			bf_d[modified]=0
		}
		diff-buffer-syntax buffer "${current_buffer}_buffer_state_${bf_d[current_state]}"
		diff-buffer-merge "${current_buffer}_buffer_state_${bf_d[current_state]}" buffer
		redraw
	}

defun toggle-mouse
	:: 'Changes options[mouse]'
	function =
		case "${options[mouse]}" in
			0)
				printf '\e[?1000;1006;1015h'
				options[mouse]=1
				message='Enabled options[mouse]';;
			1)
				printf '\e[?1000;1006;1015l'
				options[mouse]=0
				message='Disabled options[mouse]'
		esac

defun toggle-mode-line
	:: 'Changes options[mode-line]'
	function =
		case "${options[mode-line]}" in
			0)
				options[mode-line]=1
				((bottomlines++))
				redraw;;
			1)
				options[mode-line]=0
				((bottomlines--))
				redraw
		esac

defun toggle-command-line
	:: 'Changes options[command-line]'
	function =
		case "${options[command-line]}" in
			0)
				options[commandline]=1
				((bottomlines++))
				redraw;;
			1)
				options[command-line]=0
				((bottomlines--))
				redraw
		esac

defun toggle-line-number-mode
	:: 'Changes options[line-number-mode]'
	function = {
		case "${options[line-number-mode]}" in
			0) options[line-number-mode]=1;;
			1) options[line-number-mode]=0
		esac
		redraw
	}

defun toggle-menu-line
	:: 'Changes options[menu-line]'
	function = {
		case "${options[menu-line]}" in
			0) options[menu-line]=1;;
			1) options[menu-line]=0
		esac
		toplines="${options[menu-line]}"
		redraw
	}
nufed
	
@fn self-insert 'insert-word $@'
@fn insert-space 'insert-word " "'
@fn indent-for-tab-command "insert-word '	'"

@@ load-config Sources custom config file
function load-config {
	log_buffer+=('LOADING CONFIG...')
	local config_file
	local f
	f=~/.config/ebashsrc.d/init.bash ;[ -f "$f" ] && config_file="$f"
	f=~/.config/ebashsrc ;[ -f "$f" ] && config_file="$f"
	f=~/.ebashsrc ;[ -f "$f" ] && config_file="$f"
	f=~/.ebashsrc.d/init.bash ;[ -f "$f" ] && config_file="$f"
	f=.ebashsrc ;[ -f "$f" ] && config_file="$f"
	f=.ebashsrc.d/init.bash ;[ -f "$f" ] && config_file="$f"
	
	f="${EBASHS_CONFIG}" ;[ -n "$f" ] && [ -f "$f" ] && config_file="$f"
	f="${EBASHS_CONFIG_DIR}/init.bash" ;[ -n "$f" ] && [ -f "$f" ] && config_file="$f"
	
	[ -z "$config_file" ] && return
	source "$config_file"
	log_buffer+=("LOADED $config_file")
}

@@ scratch
:: Empty buffer
function scratch {
	log info "loading empty buffer..."
	declare-new-buffer
		:: mode "${options[default_mode]}"
		:: info "${options[help-message]}"
		:: filetype "bash"
		:: file "*scratch*"
		:: isfile 0
		:: menuline welcome
		:: current_state 0
	set-syntax
	size-full

	buffer=(
		''
		'# This buffer is for text that is not saved, and for Bash evaluation.'
		'# To create a file, visit it with C-x C-f and enter text in its buffer.'
		''
	)
		
	message="For information about Ebashs and the BASH system, type C-h C-a."
	bf_d[line]=1 # Indicate that we have a buffer loaded
	bf_d[modified]=0
}

@@ welcome-buffer
:: Show welcome message
function welcome-buffer {
	log info "loading welcome buffer..."
	declare-new-buffer
		:: mode welcome
		:: info "${options[help-message]}"
		:: filetype "format"
		:: file "*welcome*"
		:: isfile 0
		:: menuline welcome
		:: current_state 0
		:: syntax syntax-format
		:: syntax-exec 1
	size-full

	buffer=(
		''
		'<f> title <u> Ebashs </u> </f>'
		'<i-tab>'
		' Welcome to Ebashs the editor of pure Bash.'
		'</i>'
		'<f> title <u> Actions </u> </f>'
		'<tab> <a> find-file : <f> red Open <f> title f </f-> ile </f> </a>'
		'<tab> <a> dired : <f> yellow <f> title B </f-> rowse files </f> </a>'
		'<tab> <a> manual : <f> green View <f> title m </f-> anual </f> </a>'
		'<tab> <a> view-page : <f> cyan View <f> title d </f-> ocumentation </f> </a>'
		'<tab> <a> about : <f> blue <f> title A </f-> bout Ebashs </f> </a>'
		'<tab> <a> inputcodes : <f> magenta <f> title I </f-> nput debugging </f> </a>'
		'<tab> <a> list-faces-display : <f> red Fa <-f> title c </f-> es </f> </a>'
	)
	((log)) && buffer+=(
		'<tab> <a> view-log : <f> yellow <f> title L </f-> og </f> </a>'
	)
		
	message="For information about Ebashs and the BASH system, type C-h C-a."
	bf_d[line]=1 # Indicate that we have a buffer loaded
	bf_d[modified]=0
}

@@ init
:: Prepares variables and launches main function
function init {
	case "$1" in
		'--quick'|'-Q')
			log_buffer+=('- LOAD DEFAULT CONFIG -')
			load-default-config
			shift;;
		'--version')
			echo "$version"
			abort;;
		'--dump')
			declare -f
			echo 'init "$@"'
			abort;;
		'--help')
			print-stdin <<EOF
Usage: ebashs [OPTION-OR-FILENAME]...

Run Ebashs, the extensible, customizable, maybe-real-time
display editor.  The recommended way to start Ebashs for normal editing
is with no options at all.

Run C-h r RET inside Ebashs to read "manual".

Initialization options:
--quick, -Q    don't load config
--help,        display this help and exit
--version,     display version information and exit
--view, -v     open file for viewing if possible
--exec, -e     execute file as script with Ebashs features
EOF
			abort;;
		'--view'|'-v')
			log_buffer+=('- LOAD DEFAULT CONFIG -')
			options[view]=1
			load-default-config
			load-default-config-ebashs #loads default config
			load-config
			shift;;
		'--exec'|'-e')
			log_buffer+=('- LOAD DEFAULT CONFIG -')
			options[view]=1
			options[no-file]=1
			load-default-config
			load-default-config-ebashs #loads default config
			load-config
			source "$2"
			shift;;
		*)
			log_buffer+=('- LOAD DEFAULT CONFIG -')
			load-default-config
			load-default-config-ebashs #loads default config
			load-config
	esac
	init-var
	
	if [[ "$1" ]]; then # If a file was provided in the terminal pre-load it
		log info "args: $1"
		if [ -d "$1" ]; then
			log info "[$1] is directory => dired"
			cd "$1" || exit
			dired # enter the file selector in specified folder
		else
			log info "[$1] is file => read-buffer"
			read-buffer "$1"
		fi
	else
		log info "no arg => scratch"
		if ((options[welcome-buffer])); then
			welcome-buffer
		else
			scratch
		fi
	fi
	log info "drawing..."
	redraw
	log info 'entering main loop...'
	main
}

log_buffer+=('INIT')
init "$@"
