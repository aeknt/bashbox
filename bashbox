#!/usr/bin/env bash
cmdf=$1
shift
case $cmdf in
--build)
	echo 1712440723,176093
;;
arch)
#!/usr/bin/env bash
#
# arch in pure bash.

echo "$HOSTTYPE"
;;
at)
#!/bin/bash
[ -z "$1" ] && echo "usage: at <unix time>, while command is stdin" && exit
gettime() {
	printf "%(%s)T\\n"
}
waituntil() {
	while true
	do
		[ "$1" = "$(gettime)" ] && ("$input") && exit
	done
}
input=$(while read -r command
	do
		echo "$command"
	done
)
[ "$1" -lt "$(gettime)" ] && echo "can't be in past" && exit
waituntil "$1" &
;;
bano)
#!/usr/bin/env bash
#stolen from https://github.com/comfies/bed and edited to be like nano and added few stuff like syntax highlighting
#i guess i will turn this into ebashs later :)
printf '\e[?7l'

declare -A syntax
declare -a buffer
declare -a buffersyntax
declare -i line base rl
declare file message modified filetype enable_mouse comment stringone stringtwo reservedlines

printf "\e[?1049h" #switch to alternative buffer

buffer=() # File contents
buffersyntax=() # File contents
line=0 # Currently selected line (0 means the buffer is empty)
base=1 # Top-most line shown
rl=0 # how left or right the cursor is
file= # Currently addressed file
message="Welcome to bano (press 'x' to quit)." # Feedback text in the status bar
modified=false # Tracking whether a file was modified
enable_mouse=true # Xterm mouse support
reservedlines=1 # Number of lines not displaying file

shopt -s lastpipe
shopt -s extglob # Ensure advanced pattern matching is available
shopt -s checkwinsize; (:) # Enable and then trigger a terminal size refresh
trap redraw WINCH ALRM # Attach WINCH and ALRM to redraw the screen
trap die EXIT HUP USR1 # Attach most exit codes to cleanup and exit
trap quit INT
trap quit SIGTERM

syntax[bash]=builtin_syntax_bash
syntax[sh]=builtin_syntax_bash #there isnt anything really bash specific currently
syntax[ksh]=builtin_syntax_bash
syntax[mksh]=builtin_syntax_bash
syntax[dash]=builtin_syntax_bash
syntax[zsh]=builtin_syntax_bash
syntax[conf]=builtin_syntax_conf
syntax[unknown]=builtin_syntax_unknown

builtin_syntax_bash() {
	case "${word:0:2}" in
		'"$') colour 0 36 48 "${word}"; return ;;
	esac
	case "${word:0:1}" in
		'#') colour 0 37 48 "${word}" && comment=true; return;;
		'$') colour 0 96 108 "${word}"; return ;;
		'-') colour 0 93 108 "${word}"; return ;;
	esac
	"${comment}" && colour 0 37 48 "${word}" && return
	case "${word}" in
		'||') colour 0 95 108 "${word}"; return ;;
		'&&') colour 0 95 108 "${word}"; return ;;
		']') colour 1 95 108 "${word}"; return ;;
		'[') colour 1 95 108 "${word}"; return ;;
		'[[') colour 1 95 108 "${word}"; return ;;
		']]') colour 1 95 108 "${word}"; return ;;
		')') colour 1 95 108 "${word}"; return ;;
		'(') colour 1 95 108 "${word}"; return ;;
		'{') colour 1 95 108 "${word}"; return ;;
		'}') colour 1 95 108 "${word}"; return ;;
		';') colour 0 95 108 "${word}"; return ;;
		*"'"*) colour 0 92 108 "${word}" && return ;;
		*'"'*) colour 0 32 48 "${word}" && return ;;
		*'='*) colour 0 94 108 "${word}"; return ;;
	esac
		   
	[[ "${word: -2}" = '()' ]] && colour 0 30 44 "${word}" && return
	case "${word}" in
		'echo'|'return'|'case'|'esac'|'for'|'while'|'do'|'done'|'if'|'elif'|'else'|'printf'|'fi'|'continue'|'exit'|'bind'|'then'|'break'|'read'|'declare'|'typeset'|'local'|'let'|'shopt'|'trap'|'set') colour 0 91 108 "${word}" && return
	esac
	colour 0 0 0 "${word}"
}
builtin_syntax_unknown() {
	colour 0 0 0 "${word}"
}
builtin_syntax_conf(){
	[[ "${word}" =~ "#" ]] && colour 38 5 4 "${word}" && comment=true && return
	"${comment}" && colour 38 5 4 "${word}" && return
	colour 0 0 0 "${word}"
}

syntax() {
	for s in "${!syntax[@]}"; {
		[ "$s" = "$filetype" ] && "${syntax[$s]}" && return
	}
	"${syntax[unknown]}"
}
basenam() {
	for file in "$@"; do
	    file="${file%/}"
	    printf '%s\n' "${file##*/}"
	done
}
filetype(){
	[ $# = 0 ] && return
	IFS='.'
	filename="${1%/}"
	filename="${filename##*/}"
	filenamesplit=($filename)
	extension="${filenamesplit[-1]}"
	[ "${#filenamesplit[@]}" -gt 1 ] && echo "$extension" && return
	mapfile -n 1 file_data < "$1"
	shebang="$(echo -n "${file_data[@]}")"
	[ ! "${shebang:0:1}" = '#' ] && echo unknown && return
	shebang="${shebang%/}"
	IFS=' '
	shebang="${shebang##*/}"
	shebangsplit=($shebang)
	printf '%s\n' "${shebangsplit[-1]}"	
}
set_buffer_file() {
	printf '\e[%s;0H' "${LINES}"
	printf '\e[D\033[1;93;108m' #make prompt nicer
    bind 'set disable-completion off' 2>/dev/null # Enable completion
    printf '\e[?25h' # Enable cursor
    if read -rei "$1$file" -p "${BED_FILE_PROMPT:=Path: }" file; then
        modified=true
    fi
    bind 'set disable-completion on' 2>/dev/null
}

read_buffer() {
	filetype="$(filetype "$1")"
    set_buffer_file "$1" # Update target file (pass on default if present)
    mapfile -t -O 1 buffer <"$file" # Read file into an array
    pipesyntax < "$file" | mapfile -t -O 1 buffersyntax  # Read file into an array
    if [[ "${buffer[1]}" ]]; then # Ensure that something was actually read into the file
        line=1 # Indicate that we have a buffer loaded
        modified=false
        message="Read ${#buffer[@]} lines from '$file'"
    else
        message="'$file' is empty"
    fi
}

write_buffer() {
    true >"$file" # Set the file to an empty text file
    for ln in "${buffer[@]}"; do # Write in the buffer to the file
        echo "$ln" >>"$file"
    done
    modified=false
    message="Wrote ${#buffer[@]} lines to '$file'"
}
megaredraw() {
	printf '%s\n' "${buffer[@]}" | pipesyntax | mapfile -t -O 1 buffersyntax
}
megaredrawline() {
	buffersyntax[line]="$(printf '%s' "${buffer[line]}" | pipesyntax)"
}
#megaredrawlinesyntax(){
#	buffersyntax[line]="$(printf '%s' "${buffer[line]}" | pipesyntax)"
#}
tabrender() {
	IFSbck="$IFS"
	IFS=
	while read -rsn1 char
	do
		[ "$char" = " " ] && printf ' ' && continue
		[ "$char" = "	" ] && printf '\033[0;37;48m%s\033[0;0m' "${BANO_RENDER_TAB:=.}" && continue
		printf '%s' "$char"
	done
	IFS="$IFSbck"
}
tabrenderraw() {
	IFSbck="$IFS"
	IFS=
	while read -rsn1 char
	do
		[ "$char" = " " ] && printf ' ' && continue
		[ "$char" = "	" ] && printf '%s' "${BANO_RENDER_TAB_ALT:= }" && continue
		printf '%s' "$char"
	done
	IFS="$IFSbck"
}
new_line() {
    buffer=("" "${buffer[@]:1:line}" "" "${buffer[@]:line+1}")
    unset 'buffer[0]'
    modified=true
	megaredraw
	down
	redraw
}

delete_line() {
    buffer=("" "${buffer[@]:1:line-1}" "${buffer[@]:line+1}")
    unset 'buffer[0]'
    ((line > ${#buffer[@]})) && up
    modified=true
    megaredraw
}

quit() {
	printf '\e[%s;0H' "${LINES}"
	printf '\e[D\033[1;93;108m' #make prompt nicer
    if [[ "$modified" == "true" ]]; then
        while :; do
            read -rsN1 -p "Buffer modified, save before close? [Y/n/c]" choice
            case "$choice" in
            Y|y) write_buffer; die;;
            N|n) die;;
            C|c) message="Quit canceled"; break;;
            *) continue;;
            esac
        done
    else
        die
    fi
}

up() {
    for ((i = 0; i < ${1:-1}; i++)); do
        ((line > 1)) && ((line--)) # As long as we can keep going up, go up
        ((line < base)) && ((base--)) # Push back the top if we need to
        ((base <= 0)) && base=1 # Don't push back if our base is at 1
        [ -z "$bckrl" ] && bckrl="${rl}"
        (( "${#buffer[line]}" < "${rl}" )) && rl="${#buffer[line]}"
        (( "${#buffer[line]}" > "${rl}" )) && rl=bckrl
    done
}

page_up() {
    up $((LINES - 3))
}

down() {
    for ((i = 0; i < ${1:-1}; i++)); do
        ((line < ${#buffer[@]})) && ((line++)) # If we can go down, go down
        ((line > base + LINES - 3)) && ((base++)) # Move window down if needed
        [ -z "$bckrl" ] && bckrl="${rl}"
        (( "${#buffer[line]}" < "${rl}" )) && rl="${#buffer[line]}"
        (( "${#buffer[line]}" > "${rl}" )) && rl=bckrl
    done
}

page_down() {
    down $((LINES - 3))
}

execute() {
    ((line == 0)) && return # If the line is not possible, do nothing
    printf '\e[?25h\e[%sH' "$((line + 2 - base))" # Reset cursor position and enable cursor
    read -re -p "$(printf '%4s ' "$")" # Present editable line
    if [[ "$REPLY" != "${buffer[line]}" ]]; then # If the line is changed, update and inform
        buffer[line]="$($REPLY)"
        modified=true
    fi
    megaredraw
    redraw
}
right() {
	case "${buffer[line]}" in
		*)((rl++));;
	esac
	[ "$rl" -gt "${#buffer[line]}" ] && { rl=0; down; }
	bckrl=
}
left() {
	((rl--))
	[ "$rl" -lt 0 ] && { up; rl="${#buffer[line]}"; }
	bckrl=
}
shell() {
	printf "\033c"
	bash
	redraw
}
help() {
	printf '\e[%s;0H' "${LINES}"
	printf '\033[0;0m'
	printf '\n' # Add final newline to seperate commandline
	printf '\e[0;107;30m C-x\e[0;m Exit     \e[0;107;30m⏎   \e[0;m New Line  \e[0;107;30m M-r\e[0;m Set Target \e[0;107;30m C-r\e[0;m Read File \e[0;107;30m C-o\e[0;m Write Out \e[0;107;30m C-d\e[0;m Delete Line \e[0;107;30m C-e\e[0;m Toggle Mouse\n'
	printf '\e[0;107;30m C-l\e[0;m New Line \e[0;107;30m C-p\e[0;m Prev Line \e[0;107;30m C-n\e[0;m Next Line  \e[0;107;30m C-y\e[0;m Prev Page \e[0;107;30m C-v\e[0;m Next Page \e[0;107;30m C-t\e[0;m Execute     \e[0;107;30m C-s\e[0;m Shell       \n'
	read -rsn1
	redraw
}

die() {
    bind 'set disable-completion off' 2>/dev/null # Enable completion
    printf '\e[?25h\e[?7h\e[?1047l' # Reset terminal to sane mode
    printf "\e[?1049l" # switch back to main buffer
    echo -e "\e[?1000;1006;1015l" #disable mouse tracking
    exit "${errno:-0}" # Assume that we are exiting without an error
}
mtoggle() {
	[ "$enable_mouse" = true ] && echo -ne "\e[?1000;1006;1015l" && enable_mouse=false && return
	[ "$enable_mouse" = false ] && echo -ne "\e[?1000;1006;1015h" && enable_mouse=true && return
}

redraw() {
    (printf '\e[0;30m \e[H\e[?25l\e[107m%*s\r %s \e[46;30m %s \e[0;107;30m L%s W%s\e[m' \
        "$COLUMNS" "$message" "bano (press C-g for help)" \
        "$(basenam "$file") ($filetype)" "$line" "${rl}") # Status line, among others
    for ((i = base; i - base < LINES - reservedlines; i++)); do # Iterate over shown lines
        ((i != line)) && printf '\e[90m' # Fade line number if not selected
        ((i > ${#buffer[@]})) && printf '\n\e[K   ~\e[m' || \
            case "${buffer[i]}" in
                *"TODO: "*|*TODO:) printf '\n\e[K%4s\e[m \033[0;45m%s\033[0;0m' "$i" "$(printf '%s' "${buffer[i]}" | tabrenderraw)";;
                *"NOTE: "*|*NOTE:) printf '\n\e[K%4s\e[m \033[0;47m%s\033[0;0m' "$i" "$(printf '%s' "${buffer[i]}" | tabrenderraw)";;
				*) printf '\n\e[K%4s\e[m %s' "$i" "${buffersyntax[i]}";;
            esac
            #TODO: make proper coloring based on variable for future config
    done
    printf '\e[?25h\e[%s;%sH' $((line + 2 - base)) $(( rl + 6 )) # move cursor to the line
}
backspace() {
	while [ "${#buffer[line]}" = 0 ]; do
		delete_line
	done
	buffer[line]="${buffer[line]:0:$(( rl - 1 ))}${buffer[line]:${rl}}" #add the key at $rl (cursor position)
	left #go left with cursor
	megaredrawline #not sure why this is needed but it prevents duplication of the letter
	redraw #draw it
	modified=true
}
keytype() {
	mouse=false
	case "$1" in
		${BANO_KEY_PGUP:=$'\E[5~'}) page_up; redraw; return;;
		${BANO_KEY_PGDN:=$'\E[6~'}) page_down; redraw; return;;
		${BANO_KEY_UP:=$'\E[A'}*) up; redraw; return;;
		${BANO_KEY_DOWN:=$'\E[B'}*) down; redraw; return;;
		${BANO_KEY_RIGHT:=$'\E[C'}*) right; redraw; return;;
		${BANO_KEY_LEFT:=$'\E[D'}*) left; redraw; return;;
	esac
	hexkey=$(printf "%x\n" "'$1")
	#clear        #stuff for debugging
	#echo $hexkey #stuff for debugging
	#read         #stuff for debugging
	#[ "$hexkey" = "$1b" ] && { read -r a; clear; echo $a; read; } && return
	#[ "${1:1:2}" = '[' ] && echo E && return
	case "$hexkey" in
		${BANO_KEY_EXIT:=18}) quit; return;;
		${BANO_KEY_PREVIOUS:=10}) up; redraw; return;;
		${BANO_KEY_NEXT:=e}) down; redraw; return;;
		${BANO_KEY_FORTH:=6}) right; redraw; return;;
		${BANO_KEY_BACK:=2}) left; redraw; return;;
		${BANO_KEY_PGPREVIOUS:=19}) page_down; redraw; return;;
		${BANO_KEY_PGNEXT:=16}) page_up; redraw; return;;
		${BANO_KEY_NEWLINE:=0}) new_line; return;;
		${BANO_KEY_NEWLINEALT:=c}) new_line; return;;
		${BANO_KEY_HELP:=7}) help; return;;
		${BANO_KEY_SAVE:=f}) write_buffer; return;;
		${BANO_KEY_READ:=12}) read_buffer; return;;
		${BANO_KEY_READ:=1b}) set_buffer_file; return;;
		${BANO_KEY_EXECUTE:=14}) execute; return;;
		${BANO_KEY_DELETE:=4}) delete_line; redraw; return;;
		${BANO_KEY_SHELL:=13}) shell; return;;
		${BANO_KEY_MOUSE_TOGGLE:=5}) mtoggle; return;;
		${BANO_KEY_SCROLL:=1b}) mouse=true;;
		${BANO_KEY_BACKSPACE:=7f}) backspace; return;; #delete last char when backspace is pressed
	esac
	#TODO: make mouse scrolling nice instead of ignoring it

	#parse mouse stuff somewhatish weirdly
	$mouse && {
		a=$(echo "$1")
		[ "${a: -1}" = 'm' ] && {
			value=0
			echo "$a" | while read -rsn1 mchar; do
				case "$mchar" in
					'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|9)tmp="${tmp}${mchar}";;
					'm'|'M'|';') {
						[ "$value" = '0' ] && mode="${tmp}" && tmp=
						[ "$value" = '1' ] && y="${tmp}" && tmp=
						[ "$value" = '2' ] && x="${tmp}" && tmp=
					};;
				esac
				case "$mchar" in
					';')((value++));;
					'm'|'M')value=0 && break;;
				esac
			done
		}
		#limitations of movenment
		[ $x = 1 ] && return
		[ $y -lt 6 ] && return
		line=$(( base + ( x - 2 ) ))
		rl=$(( y - 6 ))
		((line > ${#buffer[@]})) && line=${#buffer[@]}
		((rl > ${#buffer[line]})) && rl=${#buffer[line]}
		redraw
		return
	}
	
	buffer[line]="${buffer[line]:0:${rl}}$1${buffer[line]:${rl}}" #add the key at $rl (cursor position)
	right #go right with cursor
	megaredrawline #not sure why this is needed but it prevents duplication of the letter
	redraw #draw it
	modified=true
}

main() {
    printf '\e[?1047h' # Switch to alternative buffer
    echo -ne "\e[?1000;1006;1015h" #enable mouse tracking
    if [[ "$1" ]]; then # If a file was provided in the terminal pre-load it
        redraw # Draw out the UI before loading file
        read_buffer "$1"
    fi
    redraw
    while true; do
        local -a k=()
        local -i i=1
        
        if read -rsN1 -t"${BED_REFRESH_TIMEOUT:=1}" k[0]; then # Check for ready input
           while read -rsN1 -t0.0001 k[$i]; do ((i++)); done # Multibyte hack
            keytype "$(printf '%s' "${k[@]}")" # Handle keypress event
        fi
    done
}
pipesyntax() {
	comment=false
	stringone=false
	stringtwo=false
	word=
	bckIFS="${IFS}"
	IFS=
	colour(){
		printf "\033[%s;%s;%sm%s\033[0;0m" "$1" "$2" "$3" "$4"
	}
	readstuff() {
		while read -rsn1 char
		do
			[ "$char" = " " ] && syntax && word='' && printf ' ' && continue
			[ "$char" = "	" ] && syntax && word='' && printf '\033[0;37;48m%s\033[0;0m' "${BANO_RENDER_TAB:=.}" && continue
			[ -z "$char" ] && syntax && word='' comment='false' && echo && continue
			word="${word}${char}" && printf '%s\e[%sD' "$word" "${#word}"
		done
	}
	readstuff
	IFS="${bckIFS}"
}
main "$@"
printf '\e[?7h'
;;
base16)
#!/usr/bin/env bash
enc_hex() { local LC_ALL=C IFS=""
	    while read -r -d '' -n 1 c ; do printf "%02x" "'$c" ; done ; }
dec_hex() { while read -d '' -n 2 hl ; do printf "\x$hl" ; done ; }
if [ -z $1 ]; then
	enc_hex
elif [ $1 = -d ]; then
	dec_hex
fi
;;
base64)
#!/usr/bin/env bash
enc_hex() { local LC_ALL=C IFS=""
	    while read -r -d '' -n 1 c ; do printf "%02x" "'$c" ; done ; }
st8() { printf %02x $(($1 & 0xff)) ; }
b64_luts() {
	declare -g -A d e
	local c i j=0 p=printf
	for ((i = 65; i <= 90; i++, j++)) ; do
		c=$(st8 $i) ; e[$j]=$c ; d[$($p "\x$c")]=$j ; done
	for ((i = 97; i <= 122; i++, j++)) ; do
		c=$(st8 $i) ; e[$j]=$c ; d[$($p "\x$c")]=$j ; done
	for ((i = 48; i <= 57; i++, j++)) ; do
		c=$(st8 $i) ; e[$j]=$c ; d[$($p "\x$c")]=$j ; done
	for i in 43 47 ; do
		c=$(st8 $i) ; e[$j]=$c ; d[$($p "\x$c")]=$j ; j=$((j+1)) ; done
	d[=]=-1
}
enc_b64() {
	local c ; b64_luts
	while read -N 6 c ; do
		printf "\x${e[$((0x${c:0:2} >> 2))]}"
		printf "\x${e[$(((0x${c:0:2} & 3) << 4 | (0x${c:2:2}) >> 4))]}"
		printf "\x${e[$(((0x${c:2:2} & 15) << 2 | 0x${c:4:2} >> 6))]}"
		printf "\x${e[$((0x${c:4:2} & 0x3f))]}"
	done
	if ((${#c} == 4)) ; then
		printf "\x${e[$((0x${c:0:2} >> 2))]}"
		printf "\x${e[$(((0x${c:0:2} & 3) << 4 | (0x${c:2:2}) >> 4))]}"
		printf "\x${e[$(((0x${c:2:2} & 15) << 2))]}="
	elif ((${#c} == 2)) ; then
		printf "\x${e[$((0x${c:0:2} >> 2))]}"
		printf "\x${e[$(((0x${c:0:2} & 3) << 4))]}=="
	fi
}
dec_hex() { while read -d '' -n 2 hl ; do printf "\x$hl" ; done ; }
dec_b64() {
	local i r s t u ; b64_luts
	while read -N 4 i ; do
		r=${d[${i:0:1}]} ; s=${d[${i:1:1}]}
		t=${d[${i:2:1}]} ; u=${d[${i:3:1}]}
		if ((u >= 0)) ; then
			st8 $((r << 2 | s >> 4)) ; st8 $((s << 4 | t >> 2))
			st8 $(((t << 6) | u)) ; continue
		fi
		st8 $((r << 2 | s >> 4))
		if ((t >= 0)) ; then st8 $((s  << 4 | t >> 2)) ; fi
		break
	done
}
if [ -z $1 ]; then
	enc_hex | enc_b64
elif [ $1 = -d ]; then
	dec_b64 | dec_hex
fi
;;
basename)
#!/usr/bin/env bash
#
# basename in pure bash.

for file in "$@"; do
    file="${file%/}"
    printf '%s\n' "${file##*/}"
done
;;
bashbox-create)
#!/usr/bin/env bash
bashbox_build=$( if [ -z $EPOCHREALTIME ]; then printf "%(%s)T\\n"; else echo $EPOCHREALTIME; fi)
bin() {
	echo '#!/usr/bin/env bash' > bashbox
	echo 'cmdf=$1' >> bashbox
	echo 'shift' >> bashbox
	cd bin || exit 1
	items=$(printf '%s\n' *)
	help=$(echo *)
	cd ..
	echo 'case $cmdf in' >> bashbox
	echo '--build)' >> bashbox
	echo "	"echo $bashbox_build >> bashbox
	echo ';;' >> bashbox
	for i in $items
	do
		echo $i')' >> bashbox
		#start of text edit
		getcont bin/$i >> bashbox
		echo merging file $i
		echo ';;' >> bashbox
	done
	echo '*)' >> bashbox
	echo "echo $help"  >> bashbox
	echo ';;' >> bashbox
	echo 'esac' >> bashbox
}
getcont() {
	if [[ "$#" == 0 ]]; then
	    while read -rn1; do echo "$REPLY"; done
	else
	    for file in "$@"; do
	        if [[ -f $file ]]; then
	            printf '%s\n' "$(<"$file")"
	        else
	            printf '%s\n' "cat: $file: No such file or directory" >&2
	        fi
	    done
	fi
}
bin
;;
bc)
#!/usr/bin/env bash
#
# expr in pure bash.
if [ -z "$*" ]; then
	while true
	do
		read -rep ':' expre
		printf '%s\n' "$(($expre))"
	done
else	
	printf '%s\n' "$(($@))"
fi
;;
bf)
#!/usr/bin/env bash
#https://esolangs.org/wiki/Extended_Brainfuck
extension=0 #set which extended type to use
file=0
lenght() {
	#!/usr/bin/env bash
	#
	# wc in pure bash.
	
	while getopts "lcw" opt; do
	    case $opt in
	        l) lines=1 ;;
	        c) bytes=1 ;;
	        w) words=1 ;;
	
	        ?)
	            printf '%s\n' "error: -$OPTARG not a valid option." >&2
	            exit 1
	        ;;
	    esac
	done
	
	[[ -t 0 && -f ${*: -1} ]] &&
	    file=${*: -1}
	
	[[ -t 0 && ! -f $file ]] && {
	    printf '%s\n' "wc: ${file:-null}: No such file or directory." >&2
	    exit 1
	}
	
	mapfile file_data < "${file:-/dev/stdin}"
	
	for line in "${file_data[@]}"; do
	    read -ra line_split <<< "$line"
	    ((splits+=${#line_split[@]}, chars+=${#line}))
	done
	
	[[ -z $lines && -z $bytes && -z $words ]] &&
	    ((lines=1, bytes=1, words=1))
	
	[[ $lines ]] && printf '%s ' "${#file_data[@]}"
	[[ $words ]] && printf '%s ' "$splits"
	[[ $bytes ]] && printf '%s ' "$chars"
	
	printf '%s\n' "$file"
}
if [ "$1" = -x ]; then
	extension=1
	shift
elif [ "$1" = -x2 ]; then
	extension=2
	shift
elif [ "$1" = -xf2 ]; then
	extension=2
	file=1
	shift
fi
if (( $# )); then
	for arg; do
		programf+=$(< "$arg") || exit
	done
else
	mapfile -t
	programf=${MAPFILE[*]}
fi

#printf "%d\n" \'a #convert ascii to decimal

[ $extension = 0 ] && program=${programf//[^'><+-.,[]']} #basic
[ $extension = 1 ] && program=${programf//[^'><+-.,[]@$!}{~^&|']} #extended 1
[ $extension = 2 ] && program=${programf//[^'><+-.,[]@$!}{~^&|'?)(*/=_%]} #extended 2
IFS= read -d "" -r translation <<'EOF'
declare -a a
LC_ALL=C
IFS=
p=0

if [ $file = 1 ]; then
	for (( i=0; i<${#programf}; i++ )); do
		a[$i]=$(printf "%d\n" \'"${programf:$i:1}")
		p=$(( $(printf "%d\n" \'"${programf:$i:1}" | lenght -c) + 1 ))
	done
fi

i(){
	[[ -z $REPLY ]] && read -r && REPLY+=$'\n'

	[[ $REPLY ]] && {
		printf -v 'a[$p]' %d "'${REPLY::1}"
		REPLY=${REPLY:1}
	}
}
o(){
	local hex
	printf -v hex %x "${a[$p]}"
	printf %b "\x$hex"
}
save(){
	storage="${a[$p]}"
}
insert(){
	tmpn=0
	for byt in "${a[@]}";{
		[ $tmpn -lt $p ] && a[$tmpn]="$byt"
		[ $tmpn = $p ] && a[$tmpn]="0" && tmpn=$(( tmpn + 1 ))
		[ $tmpn -gt $p ] && a[$tmpn]="$byt"
		tmpn=$(( tmpn + 1 ))
	}
}
uninsert(){
	a=( "${a[@]:0:$p}" "${a[@]:$(( p + 1 ))}" )
}
execat(){
	a=( "${a[@]:0:$p}" "${a[@]:$(( p + 1 ))}" )
}

EOF

for (( i = 0; i < ${#program}; ++i )); do
	case ${program:i:1} in
		'>'): '(( ++p ))' ;;
		'<'): '(( --p ))' ;;
		'+'): '(( a[$p] = a[$p]+1 & 255 ))' ;;
		'-'): '(( a[$p] = a[$p]-1 & 255 ))' ;;
		'.'): 'o' ;;
		','): 'i' ;;
		'['): 'while (( a[$p] )); do :' ;;
		']'): 'done' ;;
		'@'): 'exit' ;;
		'$'): 'save' ;;
		'!'): 'a[$p]=$storage' ;;
		'}'): 'a[$p]=$(( a[$p] >> 1 ))' ;;
		'{'): 'a[$p]=$(( a[$p] << 1 ))' ;;
		'o'): 'echo ${a[$p]}' ;; #for debugging
		'p'): 'echo ${a[@]}' ;; #for debugging
		'~'): 'a[$p]=$(( ~ a[$p] ))' ;;
		'^'): 'a[$p]=$(( a[$p] ^ $storage ))' ;;
		'&'): 'a[$p]=$(( a[$p] & $storage ))' ;;
		'|'): 'a[$p]=$(( a[$p] | $storage ))' ;;
		'?'): 'execat' ;;
		')'): 'insert' ;;
		'('): 'uninsert' ;;
		'*'): 'a[$p]=$(( $storage * a[$p] ))' ;;
		'/'): 'a[$p]=$(( a[$p] / $storage ))' ;;
		'='): 'a[$p]=$(( a[$p] + $storage ))' ;;
		'_'): 'a[$p]=$(( a[$p] - $storage ))' ;;
		'%'): 'a[$p]=$(( a[$p] % $storage ))' ;;
	esac
	translation+=$_$'\n'
done
eval "$translation"$'\n:' || exit
;;
cat)
#!/usr/bin/env bash
#
# cat in pure bash.

if [[ "$#" == 0 ]]; then
    while read -r; do echo "$REPLY"; done
else
    for file in "$@"; do
        if [[ -f $file ]]; then
            printf '%s\n' "$(<"$file")"
        else
            printf '%s\n' "cat: $file: No such file or directory" >&2
        fi
    done
fi
;;
chr)
#!/bin/bash
chr() {
  [ "$1" -lt 256 ] || return 1
  printf "\\$(printf '%03o' "$1")"
}

chr "$@"
;;
clear)
#!/usr/bin/env bash
printf "\033c"
#found this randomly and it seems to "work"
;;
colors)
#!/bin/bash
# colors - terminal color and attribute escape sequences
repeat() {
	[[ -z $1 ]] && {
	    printf '%s\n' "bashbox: colors: repeat: error: missing arguments." >&2
	    exit 1
	}
	
	[[ $2 ]] &&
	    first="$1"
	
	[[ $3 ]] &&
	    increment="$2"
	
	last="${*: -1}"
	
	for ((i=${first:=1};i<=last;i+=${increment:=1})); {
	    printf '%s\n' "$i"
	}
	
}
verbose() {
	for x in {0..9}; do
		echo -e "\e[$x""m\\\e[$x""m Example text\e[0;0;0m "
		for i in {30..37}; do
			echo -ne "\e[$x;$i""m\\\e[$x;$i""m\e[0;0;0m "
			for a in {40..47}; do
				echo -ne "\e[$x;$i;$a""m\\\e[$x;$i;$a""m\e[0;0;0m "
			done
			echo
		done
	done
	echo ""
	for x in {0..9}; do
		echo -e "\e[$x""m\\\e[$x""m Example Text\e[0;0;0m "
		for i in {90..97}; do
			echo -ne "\e[$x;$i""m\\\e[$x;$i""m\e[0;0;0m "
			for a in {100..107}; do
				echo -ne "\e[$x;$i;$a""m\\\e[$x;$i;$a""m\e[0;0;0m "
			done
			echo
		done
	done
	echo ""
}
#simple colors, similiar to how neofetch outputs them
simple() {
    for i in {0..15}; do
        ((i%8==0)) && printf "\\n"
        printf "%b" "\\e[48;05;${i}m  \\e[0m"
    done

    printf "\\n\\n"
}
linuxttyworkaroundsimple(){
	printf "
\\e[0;40m  \\e[0;41m  \\e[0;42m  \\e[0;43m  \\e[0;44m  \\e[0;45m  \\e[0;46m  \\e[0;47m  \\e[0m
\\e[5;100m  \\e[5;101m  \\e[5;102m  \\e[5;103m  \\e[5;104m  \\e[5;105m  \\e[5;106m  \\e[5;107m  \\e[0m
"
}
[ -z "$1" ] && verbose
[ "$1" = "-s" ] && simple
[ "$1" = "-t" ] && linuxttyworkaroundsimple
[ "$1" = "-h" ] && echo "usage: colors [ -s ]"
;;
colors256)
#!/bin/bash
# colors - terminal color and attribute escape sequences
repeat() {
	[[ -z $1 ]] && {
	    printf '%s\n' "bashbox: colors: repeat: error: missing arguments." >&2
	    exit 1
	}
	
	[[ $2 ]] &&
	    first="$1"
	
	[[ $3 ]] &&
	    increment="$2"
	
	last="${*: -1}"
	
	for ((i=${first:=1};i<=last;i+=${increment:=1})); {
	    printf '%s\n' "$i"
	}
	
}
echo '\033[48;5;<code>m - background'
echo '\033[38;5;<code>m - foreground'
for a in $(repeat 0 256); do
	printf "\033[38;5;${a}m ${a}"
done
printf "\n"
for a in $(repeat 0 256); do
	printf "\033[48;5;${a}m${a} "
done
printf "\n"
;;
command)
#!/bin/bash
command $@
;;
cp)
#!/bin/bash
if [ -z "$1" ]; then
  echo "cp: missing file name"
  exit
fi
if [ -z "$2" ]; then
  echo "cp: missing target file name"
  exit
fi
if [ ! -f "$1" ]; then
  echo "cp: file not found"
  exit
fi
printf '%s\n' "$(<"$1")" > "$2"
#cp in pure sh
#test
;;
curl)
#!/usr/bin/env bash
#
# Download a file in pure bash.

download() {
    IFS=/ read -r _ _ host query <<< "$1"

    # Send the HTTP request.
    exec 3<"/dev/tcp/${host}/$2"; {
        printf '%s\r\n%s\r\n\r\n' \
               "GET /${query} HTTP/1.0" \
               "Host: $host"
    } >&3

    # Strip the HTTP headers.
    while IFS= read -r line; do
        [[ "$line" == $'\r' ]] && break
    done <&3

    # Output the file.
    nul='\0'
    while IFS= read -d '' -r line || { nul=""; [[ -n "$line" ]]; }; do
        printf "%s%b" "$line" "$nul"
    done <&3

    exec 3>&-
}

if [ "$1" = "-o" ]; then
	if [ -z $4 ]; then
		download "$3" 80 > "$2"
	else 
		download "$3" "$4" > "$2"
	fi
else
	if [ -z $2 ]; then
		download "$1" 80
	else 
		download "$1" "$2"
	fi
fi
;;
cut)
#!/usr/bin/env bash
enc_hex() { local LC_ALL=C IFS=""
	    while read -r -d '' -n 1 c ; do printf "%02x" "'$c" ; done ; }
dec_hex() { while read -d '' -n 2 hl ; do printf "\x$hl" ; done ; }
cut() {
	local bs=$((64 * 1024)) off=$(($1 * 2)) size=$((($2 + 0) * 2))
	local sdb=$(((size / bs) * bs)) c i
	if ((off)) ; then read -N $off ; fi
	if ((size == 0)) ; then
		while read -N $bs c ; do echo -n "$c" ; done
		echo -n "$c" ; return ; fi
	for ((i = 0; i < sdb; i+=bs)) ; do
		if ! read -N $bs c ; then echo -n "$c" ; return ; fi
		echo -n "$c" ; done
	i=$((size - i)) ; if ((i)) ; then read -N $i c ; echo -n "$c" ; fi
}
binop() { enc_hex | $@ | dec_hex ; }
binop cut ${@:1}
;;
date)
#!/usr/bin/env bash
#
# date in pure bash.

date_format="$1"

[[ ${date_format:0:1} == + ]] &&
    date_format="${date_format/+}"

printf "%($date_format)T\\n"
;;
dialog)
#!/usr/bin/bash
shopt -s checkwinsize; (:;:)
hide() {
	printf '\e[?25l\e[?7l'
}
unhide() {
	printf "\e[?25h\e[?7h"
}
repeat() {
	for ((i=${first:=1};i<="${*: -1}";i+=${increment:=1})); {
	    printf '%s\n' "$i"
	}
}
get_cursor_posx() {
	# Usage: get_cursor_pos
	IFS='[;' read -p $'\e[6n' -d R -rs _ x _
	printf '%s\n' "$x"
}
get_cursor_posy() {
	# Usage: get_cursor_pos
	IFS='[;' read -p $'\e[6n' -d R -rs _ y _
	printf '%s\n' "$y"
}
render() {
	printhelp() {
	 echo "escape sequence wrapper error"
	}
	get_cursor_pos() {
	    # Usage: get_cursor_pos
	    IFS='[;' read -p $'\e[6n' -d R -rs _ y x _
	    printf '%s\n' "$y $x"
	}
	##colors
	modeput() {
	 printf "\033[$1;$2m"
	}
	rgbputf() {
	 printf "\033[38;2;$1;$2;$3m"
	}
	rgbputb() {
	 printf "\033[48;2;$1;$2;$3m"
	}
	if [ -z $1 ]; then
	 printhelp
	elif [ $1 = rsetf ]; then
	 printf "\033[38;2;$2;$3;$4m"
	elif [ $1 = rsetb ]; then
	 printf "\033[48;2;$2;$3;$4m"
	elif [ $1 = esetf ]; then
	 printf "\033[38;5;$2m"
	elif [ $1 = esetb ]; then
	 printf "\033[48;5;$2m"
	elif [ $1 = set ]; then
	 modeput $2 $3
	elif [ $1 = cup ]; then
	 printf "\033[$2;$3H"
	elif [ $1 = hsetf ]; then
	 r=$(printf "%d" "0x$(echo $2 | cut -c 1-2)")
	 g=$(printf "%d" "0x$(echo $2 | cut -c 3-4)")
	 b=$(printf "%d" "0x$(echo $2 | cut -c 5-6)")
	 rgbputf $r $g $b
	elif [ $1 = hsetb ]; then
	 r=$(printf "%d" "0x$(echo $2 | cut -c 1-2)")
	 g=$(printf "%d" "0x$(echo $2 | cut -c 3-4)")
	 b=$(printf "%d" "0x$(echo $2 | cut -c 5-6)")
	 rgbputb $r $g $b
	elif [ $1 = clear ]; then
	  printf "\033c"
	elif [ $1 = cols ]; then
	 echo $COLUMNS
	elif [ $1 = lines ]; then
	 echo $LINES
	elif [ $1 = pos ]; then
	 get_cursor_pos
	else
		echo "unknown sequence wrapper command error"
	fi
}
msgbox() {
	half=$(( ( COLUMNS / 2 ) - 6  ))
	msg="$1"
	render clear
	hide
	echo "$msg"
	render set 0 37
	render cup $(( LINES - 2 )) $half
	echo -n "┌──────────┐"; render cup $(( LINES - 1 )) $half
	echo -n "│    ok    │"; render cup $LINES $half
	echo -n "└──────────┘"
	render set 0 0
	read
}
yesno() {
	yes(){
		echo -n "$(render set 0 33)┌──────────┐    $(render set 0 0)┌──────────┐"; render cup $(( LINES - 1 )) $half
		echo -n "$(render set 0 33)│   yes    │    $(render set 0 0)│    no    │"; render cup $LINES $half
		echo -n "$(render set 0 33)└──────────┘    $(render set 0 0)└──────────┘"
	}
	no(){
		echo -n "┌──────────┐    $(render set 0 33)┌──────────┐$(render set 0 0)"; render cup $(( LINES - 1 )) $half
		echo -n "│   yes    │    $(render set 0 33)│    no    │$(render set 0 0)"; render cup $LINES $half
		echo -n "└──────────┘    $(render set 0 33)└──────────┘$(render set 0 0)"
	}
	half=$(( ( COLUMNS / 2 ) - 16  ))
	msg="$1"
	render clear
	hide
	#box
	#render cup 0 0
	echo "$msg"
	render set 0 37
	render cup $(( LINES - 2 )) $half
	yes
	escape=$(printf "\u1b")
	while true
	do
		read -rsn1 input
		if [[ $input == $escape ]]; then
		    read -rsn2 input
		fi
		if [ "$input" = '[D' ]; then
			render cup $(( LINES - 2 )) $half
			yes
			answer=0
		elif [ "$input" = '[C' ]; then
			render cup $(( LINES - 2 )) $half
			answer=1
			no
		elif [ "$input" = 'y' ]; then
			render cup $(( LINES - 2 )) $half
			yes
			unhide
			render cup $LINES 0
			exit 0
		elif [ "$input" = 'n' ]; then
			render cup $(( LINES - 2 )) $half
			no
			unhide
			render cup $LINES 0
			exit 1
		else
			unhide
			render cup $LINES 0
			exit $answer
		fi
	done
	render set 0 0
}
infobox() {
	render clear
	hide
	echo "$1"
	render cup $LINES 0
}
gauge() {
	hide
	echo "$1"
	if [ -n "$4" ]; then
		per=$4
	else
		per=$2
	fi
	render cup $(( LINES - 3 )) 0
	if [ $per -gt 99 ]; then
		echo "┌──────────┐"
		echo "│   $per%   │"
		echo "└──────────┘"
	elif [ $per -lt 10 ]; then
		echo "┌──────────┐"
		echo "│    $per%    │"
		echo "└──────────┘"
	else
		echo "┌──────────┐"
		echo "│   $per%    │"
		echo "└──────────┘"
	fi
	printf '%.s█' $(repeat $(( ( COLUMNS * "$per" ) / 100 )))
	read
}
pause() {
	if [ -n "$4" ]; then
		waittime=$4
	else
		waittime=$2
	fi
	printbar() {
		render clear
		hide
		per=$1
		render cup $(( LINES - 3 )) 0
		if [ $per -gt 99 ]; then
			echo "┌──────────┐"
			echo "│   $per%   │"
			echo "└──────────┘"
		elif [ $per -lt 10 ]; then
			echo "┌──────────┐"
			echo "│    $per%    │"
			echo "└──────────┘"
		else
			echo "┌──────────┐"
			echo "│   $per%    │"
			echo "└──────────┘"
		fi
		printf '%.s█' $(repeat $(( ( COLUMNS * "$per" ) / 100 )))
	}
	yes(){
		echo -n "$(render set 0 33)┌──────────┐    $(render set 0 0)┌──────────┐"; render cup $(( LINES - 2 )) $half
		echo -n "$(render set 0 33)│    ok    │    $(render set 0 0)│  cancel  │"; render cup $(( LINES - 1 )) $half
		echo -n "$(render set 0 33)└──────────┘    $(render set 0 0)└──────────┘"
	}
	no(){
		echo -n "┌──────────┐    $(render set 0 33)┌──────────┐$(render set 0 0)"; render cup $(( LINES - 2 )) $half
		echo -n "│    ok    │    $(render set 0 33)│  cancel  │$(render set 0 0)"; render cup $(( LINES - 1 )) $half
		echo -n "└──────────┘    $(render set 0 33)└──────────┘$(render set 0 0)"
	}
	half=$(( ( COLUMNS / 2 ) - 16  ))
	msg="$1"
	answer=0
	for a in $(repeat $waittime)
	do
		render clear
		hide
		#box
		#render cup 0 0
		#render set 0 37
		printbar $a
		render cup 0 0
		echo "$msg"
		render cup $(( LINES - 3 )) $half
		if [ $answer = 0 ]; then
			yes
		else
			no
		fi
		escape=$(printf "\u1b")
		end=$((SECONDS+1))
		while [ $SECONDS -lt $end ]
		do
			read -rsn1 -t 1 input
			readexit=$?
			if [[ $input == $escape ]]; then
			    read -rsn2 input
			fi
			if [ "$input" = '[D' ]; then
				render cup $(( LINES - 3 )) $half
				answer=0
				yes
			elif [ "$input" = '[C' ]; then
				render cup $(( LINES - 3 )) $half
				answer=1
				no
			elif [ "$input" = 'y' ]; then
				render cup $(( LINES - 3 )) $half
				yes
				unhide
				render cup $LINES 0
				exit 0
			elif [ "$input" = 'n' ]; then
				render cup $(( LINES - 3 )) $half
				no
				unhide
				render cup $LINES 0
				exit 1
			elif [ -z "$input" ] && [ ! $readexit = 142 ]; then
				unhide
				render cup $LINES 0
				exit $answer
			fi
		done
		render set 0 0
	done
	unhide
}
inputbox() {
	ok(){
		render cup $(( LINES - 3 )) $half
		render set 0 33
		echo -n "┌──────────┐"; render cup $(( LINES - 2 )) $half
		echo -n "│  enter   │"; render cup $(( LINES - 1 )) $half
		echo -n "└──────────┘"; render set 0 0
	}
	half=$(( COLUMNS / 2 ))
	msg="$1"
	render clear
	ok
	render cup 0 0
	box $msg
	render cup 7 2
	echo -n "(press ctrl-c to cancel):"
	render cup 8 0
	printf '│┌'; printf '%.s─' $(repeat $(( COLUMNS - 4 ))); printf '┐│'
	render cup 9 0
	printf "││"
	render cup 9 $(( COLUMNS - 1 ))
	printf "││"
	render cup 10 0
	printf '│└'; printf '%.s─' $(repeat $(( COLUMNS - 4 ))); printf '┘│'
	render cup 9 3
	read idklmao
	printf '%.s─' $(repeat $(( COLUMNS - 2 )))
	render set 0 0
}
box() {
	render cup 0 0
	printf '┌'; printf '%.s─' $(repeat $(( COLUMNS - 2 ))); printf '┐'
	render cup $LINES 0
	printf '└'; printf '%.s─' $(repeat $(( COLUMNS - 2 ))); printf '┘'
	render cup 2 0
	printf '%.s│\n' $(repeat $(( LINES - 2 )))
	render cup 1 0
	#render cup $(( $(get_cursor_posy) + 1 )) $(( COLUMNS - 1 )); printf '%.se│\n' $(repeat $(( LINES - 2 )))
	for ((i=1;i<="$(( LINES - 2 ))";i+=1)); {
		render cup $(( $(get_cursor_posy) + 1 )) $COLUMNS
		printf "│"
	}
	title="$1"
	boxhalf=$(( ( COLUMNS / 2 ) - ( title / 2 )  ))
	render cup 0 $boxhalf; echo -n $title; render cup 0 0
}
if [ "$1" = "--msgbox" ]; then
	shift
	msgbox "$@"
elif [ "$1" = "--yesno" ]; then
	shift
	yesno "$@"
elif [ "$1" = "--infobox" ]; then
	shift
	infobox "$@"
elif [ "$1" = "--gauge" ]; then
	shift
	gauge "$@"
elif [ "$1" = "--programbox" ]; then
	render clear
	shift
	box "$@"
elif [ "$1" = "--pause" ]; then
	shift
	pause "$@"
elif [ "$1" = "--inputbox" ]; then
	shift
	inputbox "$@"
else
	msgbox "bashbox: dialog: help:
	--msgbox --yesno --infobox --gauge"
	unhide
fi
unhide
;;
dir)
#!/usr/bin/bash
#!/usr/bin/env bash
infofile() {
	if [ -L $1 ]; then
		echo -n l
	elif [ -d $1 ]; then
		echo -n d
	else
		echo -n '-'
	fi
	[ -r $1 ] && echo -n r || echo -n '-'
	[ -w $1 ] && echo -n w || echo -n '-'
	[ -x $1 ] && echo -n x || echo -n '-'
	[ -L $1 ] && [ -d $1 ] && cd -P "$1" && echo " $1 -> $PWD" && cd .. || echo " $1"
}
infofiles() {
	for f in $(printf '%s\n' *); {
		infofile "$f"
	}
}
infofilesall() {
	for f in $(printf '%s\n' .* && printf '%s\n' *); {
		infofile "$f"
	}
}
[ -z "$1" ] && printf '%s\n' *
[ "$1" = "-a" ] && printf '%s\n' .* && printf '%s\n' *
[ "$1" = "-l" ] && infofiles
[ "$1" = "-la" ] && infofilesall
[ "$1" = "-al" ] && infofilesall
;;
dirname)
#!/usr/bin/env bash
#
# dirname in pure bash.

for file in "$@"; do
     # Usage: dirname "path"
     tmp=${file:-.}
    
     tmp=${tmp%%"${tmp##*[!/]}"}
    
     [[ ${tmp##*/*} ]] && tmp=.
    
     tmp=${tmp%/*}
     tmp=${tmp%%"${tmp##*[!/]}"}
    
     printf '%s\n' "${tmp:-/}"
done
;;
ebashs)
#!/bin/bash

ebashs_version='0.9.2'

### BUFFERMAKER START

#!/bin/bash
buffermaker_version="0.10.4.1-ebashs-internal"
log_buffer+=('' 'START')
## Buffermaker
# Pure bash tui framework (wip)

shopt -s lastpipe # For syntax highlighting
shopt -s extglob # Ensure advanced pattern matching is available
shopt -s checkwinsize && (:;:) # Enable and then trigger a terminal size refresh

declare -r DEFIFS="$IFS"
declare -A highlight faces faces_raw options charmap alias descriptions
declare -A menulineedit diredmenu menulinedebug
declare -A menufancy
declare -A keys_def keys_global
declare -a k_hex buffers_l log_buffer extensions modes=('keys_global')
declare -n buffer bf_s bf_e bf_d
declare -i menuloc_x menuloc_y toplines bottomlines hidden ismenu comment current_count _isdone
declare -n menucon
declare message reset readin

function load-default-config {
	## Configuration
	#		The magic :: function
	#			:: sets value to option depending on current context:
	#				set-options → define-options() → ass. array options
	#				global-set → global-set-key → define-key global → as. ar. keys_global
	#				add-mode → local-set-key → define-key <keys> → a. a. keys_<keys>
	#					mode-options → local-set-mode-option → define-mode-option → a. a. key_options_<keys>
	#				set-alias → add-alias → a. a. alias
	#				add-menu → local-set-menu → define-menu <menu> → menu_<menu>_0 & menu_<menu>_1
	#				set-highlight → add-highlight → a. a. highlight
					  
	options=(
		[mouse]=0
		[todonote]=0
		[menu-line]=0
		[mode-line]=0
		[command-line]=0 # note that disabling this means that any message will instead be draw on top of buffer
		[line-number-mode]=0
		[empty-line-char]=''
		[tabchar]='    '
		[keep-message]=0
		[log]=0
		[log-functions]=0
		[tty-linuxfb]=1 # enable truecolor support for framebuffer
		[full-redraw]=0 # redraws whole buffer, can fix artifacting in linuxfb at cost of performance
		[esc-to-meta]=0
	)
		
	## Key bindings configuration
	#		A keybinding is defined via either
	#		global-set; :: ... ... or add-mode <mode>; :: ... ...
	#		:: <key> <command>
	#			<key> is defined either via
	#				Hexadecimal format (with ' 0' added as suffix).
	#				Name of key like '[<key>]'
	#				Emacsy "$(kbd <key> )" (<key> being something like C-s M-e ...)
	#			The name of key and $(kbd) get translated into hex. format on startup.
	#
	#			mode-options sets magic :: to defining mode options
	#			:: option value

	add-mode empty
		mode-options
			:: else :
			:: disable-global 1
	
	## Faces
	#		Defined in escape codes
	#		Helper functions:
	#			:weight
	#				normal
	#				bold
	#			:slant
	#				normal
	#				italic
	#			:background & :foreground
	#				either hex. colour, colour name, or c<index> for 256 indexed colours
	#		See extensions/gruvboxdark for another example
default_faces=(
		reset '\e[m'
		default "$(:weight normal)"
		menu "$(:mode inverse)"
		menu-highlight '\e[7;30;43m'
		menu-back '\e[4m\e[1m'
		menu-enabled-face  "$(:mode inverse)"
		menu-selected-face "$(:foreground yellow :mode inverse :weight bold)"
		button "$(:foreground light-cyan)"
		link '\e[4;96m'
		link-highlight '\e[1;4;96m'
		title "$(:weight bold)"
		highlight "$(:weight bold :foreground light-red)"
		dim "$(:weight dim)"
		name "$(:foreground magenta)"
		hint "$(:foreground light-yellow)"
		hint-highlight '\e[4;93m'
		line-number "$(:foreground gray)"
		line-number-empty "$(:weight dim :foreground gray)"
		line-number-current-line "$(:weight bold :foreground light-red)"
		tab-face "$(:weight dim :foreground gray)"
		region "$(:weight bold :background gray)"
		minibuffer-prompt "$(:weight normal)"
		#
		TODO "$(:background magenta)"
		NOTE "$(:background gray)"
		mode-line "$(:mode inverse)"
		file-name "$(:weight bold)"
		# common colors for format stuff
		black      '\e[30m' gray          '\e[90m'
		red        '\e[31m' light-red     '\e[91m'
		green      '\e[32m' light-green   '\e[92m'
		yellow     '\e[33m' light-yellow  '\e[93m'
		blue       '\e[34m' light-blue    '\e[94m'
		magenta    '\e[35m' light-magenta '\e[95m'
		cyan       '\e[36m' light-cyan    '\e[96m'
		light-gray '\e[37m' white         '\e[97m'

		bg-black      '\e[40m' bg-gray          '\e[100m'
		bg-red        '\e[41m' bg-light-red     '\e[101m'
		bg-green      '\e[42m' bg-light-green   '\e[102m'
		bg-yellow     '\e[43m' bg-light-yellow  '\e[103m'
		bg-blue       '\e[44m' bg-light-blue    '\e[104m'
		bg-magenta    '\e[45m' bg-light-magenta '\e[105m'
		bg-cyan       '\e[46m' bg-light-cyan    '\e[106m'
		bg-light-gray '\e[47m' bg-white         '\e[107m'
)
	load-theme default_faces
}

## syntaxy sugar sugary syntax
log_buffer+=('- LOADING BASH EXTENSIONS -')
function @ifs { IFS="$DEFIFS"; }
	
# Make bash not be bashy enough
function @doc {
	mapfile -t "description_${desc_count}"
	descriptions["function_${1}_description"]="description_${desc_count}"
	((desc_count++))
}

# reverse of defun :D
function nufed {
	((_addfragment==1)) && {
		@add '='
		_addfragment=0
	}
	IFS=
	local -a fn
	local deffn="function $_function"$'\n'
	mapfile fn <<<"$(declare -f '=')"
	for ((i=1; i<${#fn[@]}; i++)) {
		deffn+="${fn[i]}"
	}
	eval "$deffn"
	_isdone=0
	@ifs
	unset '='
}
	
	
@doc copy-function <<'+'
copies function \$1 to function \$2
advantage of copying instead of creating wrapper alias functions should be in theory performance(?)

Little test script:
    1() {
    	echo hi > /dev/null
    }
    echo 1
    time for e in {0..100000}; do
    	1
    done
    
    2() {
    	1
    }
    echo 2
    time for e in {0..100000}; do
    	2
    done
    
    3() {
    	2
    }
    echo 3
    time for e in {0..100000}; do
    	3
    done
    
    4() {
    	3
    }
    echo 4
    time for e in {0..100000}; do
    	4
    done

output:
    1
    
    real	0m1,636s
    user	0m1,081s
    sys	0m0,540s
    2
    
    real	0m1,986s
    user	0m1,453s
    sys	0m0,518s
    3
    
    real	0m2,380s
    user	0m1,873s
    sys	0m0,491s
    4
    
    real	0m2,768s
    user	0m2,154s
    sys	0m0,595s

It seems like there's small performace gain.
+
function copy-function {
	local -a fn
	local deffn="function $2"$'\n'
	mapfile fn <<<"$(declare -f "$1")"
	for ((i=1; i<${#fn[@]}; i++)) {
		deffn+="${fn[i]}"
	}
	eval "$deffn"
}

function defun {
	if [ -z "$1" ]; then
		nufed
	else
		((desc_count++))
		log_buffer+=("    DEFUN: $1")
		((_isdone)) && nufed
		_addfragment="${_pass_addfragment}"
		descriptions["function_${1}_description"]="description_${desc_count}"
		_function="$1"
		_isdone=1
		_last_add=add-doc
	fi
}

function ::
case "$_last_add" in
	add-menu) local-set-menu "$@";;
	set-alias) add-alias "$@";;
	set-highlight) add-highlight "$@";;
	global-set) global-set-key "$@";;
	set-options) define-option "$@";;
	add-doc) add-doc "$@";;
	add-mode) local-set-key "$@";;
	mode-options) local-set-mode-option "$@";;
	set-buffer) local-set-buffer-data "$@"
esac

function add-doc {
	local -n cdoc="description_${desc_count}"
	cdoc+=("${_indent}$*")
}
function doc {
	((desc_count++))
	descriptions["function_${1}_description"]="description_${desc_count}"
	_function="$1"
	_last_add=add-doc
	_indent=''
	shift
	[ -n "$*" ] &&
		:: "$*"
}
copy-function doc @@

## :+ Add documentation indent
function :+ {
	_indent+="    "
	# "$*"
}
## :- Remove documentation indent
function :- {
	_indent="${_indent:0:${#_indent}-4}"
	# "$*"
}
# hell

## focus set magic # function
function focus {
	_last_add="$1"
}

## declare-new-buffer Create new text buffer
function declare-new-buffer {
	_last_add='set-buffer'
	((current_count++))
	set-buffer "bf_${current_count}"
	buffers_l+=("$current_buffer")
	last_line=1
	declare -Ag "${current_buffer}_bf_d"
	bf_d=(
		# some sane default values
		[line]=0
		[base]=1
		[column]=0
		[modified]=0
	)
}

## local-set-buffer-data
# set bf_d[] array of currently \"focused\" buffer
function local-set-buffer-data {
	while [ -n "$2" ]; do
		bf_d["$1"]="$2"
		shift 2
	done
}

## [auto] Checks bf_d[] array and set\'s needed missing values automatically
function [auto] {
	[ -z "${bf_d[loc-x]}" ] && bf_d[loc-x]=1
	[ -z "${bf_d[loc-y]}" ] && bf_d[loc-y]=1
	[ -z "${bf_d[size-x]}" ] && bf_d[size-x]=$COLUMNS
	[ -z "${bf_d[size-y]}" ] && bf_d[size-y]=$((LINES - 1))
	[ -z "${bf_d[syntax]}" ] && set-syntax 
}

## defun-fragment Same as defun but includes fragments for the function
function defun-fragment {
	_pass_addfragment=1
	defun "$@"
}

# fragments act basically like macros but with cooler name
# see redraw-buffer function for example usage
## fragment Creates a function-insertable macro
function fragment {
	log_buffer+=("        FRAGMENT: $1")
	declare -ag "_fragment_$1"
	mapfile "_fragment_$1"
}
	
## @add Adds fragment to a function
function @add {
	local -a _add_fn
	local -a _add_nfn
	local -i _add_f
	local -i _add_hf
	local _add_nfnline
	mapfile _add_fn < <(declare -f -- "$1")
	IFS=' '
	for _add_l in "${!_add_fn[@]}"; {
		_add_f=0
		_add_hf=0
		_add_nfnline=
		for _add_w in ${_add_fn[_add_l]}; {
			if [ "$_add_w" = '@' ]; then
				_add_f=1
			elif ((_add_f)); then
				_add_f=0
				_add_hf=1
				local -n _add_fragment="_fragment_${_add_w//[^[:alnum:]]/}"
				for _add_l1 in "${!_add_fragment[@]}"; {
					_add_nfnline+=" ${_add_fragment[_add_l1]}"
				}
			else
				_add_nfnline+=" $_add_w"
			fi
		}
		((_add_hf)) || _add_nfn+="${_add_fn[_add_l]}"
		((_add_hf)) && _add_nfn+="$_add_nfnline"
	}
	eval "${_add_nfn[*]}"
}

## @def Defines a function template
function @def {
	local -n _tpl="_template_$1"
	local _fn
	local -i _n=0
	shift
	for _w in $_tpl; {
		case "$_w" in
			'@var')
				_n=1;;
			*)
				((_n)) && {
					_n=0
					_fn+="${!_w} "
					continue
				}
				_fn+="$_w "
		esac
	}
	eval "$_fn"
}

## _ Variable refernce helper
function _ {
	# this function is here to simplify stuff as writing overlong variables indexed by overloong variable index...
	# ...is quite tiring <3
	[ -z "$1" ] && {
		for n in "${refalias[@]}"; do
			unset "$n"
		done
		unset refalias
		return
	}
	declare -gn "$1"="$2"
	refalias+=("$1")
}

## __ Swap variable references
function __ {
	# swap two references
	local -n _swap_1="$1"
	local _swap_copy_1="${!_swap_1}"
	local -n _swap_2="$2"
	local _swap_copy_2="${!_swap_2}"
	declare -gn "$1"="${_swap_copy_2}"
	declare -gn "$2"="${_swap_copy_1}"
}

## @fn Shorthand for one line functions
function @fn {
	[ -z "$*" ] && exit 1 # error if empty
	local name="$1"
	shift
	eval "function $name { $@; }"
}

## copy-array
# A univeral function to copy both normal and associative arrays
function copy-array {
	local -n source="$1"
	local -n target="$2"
	target=()
	for idx in "${!source[@]}"; {
		target[idx]="${source[idx]}"
	}
}

## append-array
# Append array \$1 to \$2  
function append-array {
	local -n source="$1"
	local -n target="$2"
	for idx in "${!source[@]}"; {
		target+=("${source[idx]}")
	}
}

## setface Convert colors to escape codes
# '$1' can be either one of colors:
:+     black
#     red
#     green
#     yellow
#     blue
#     magenta
#     cyan
#     ligth-gray
#     gray
#     light-red
#     light-green
#     light-yellow
#     light-blue
#     light-magenta
#     light-cyan
#     white
:- 'or hex. color (like "#bb2040")'
# 'or indexed 256 color with "c" as prefix (like c127)'
# 'for background color $mode has to be 48 and for foreground 38'
::
# If \$TERM \(current "$TERM"\) is \'linux\' \& option tty-linuxfb is 1 try to use true color even for tty
# Instead of normal '\e[$mode;r;g;bm' is used '\e]P$~1mode$Hexcode\e[$~2modem'
:+     '$mode 38 → $~1mode 2 & $~2mode 32'
#     '$mode 48 → $~1mode 1 & $~2mode 41'
:- Note that the linuxfb colors are very experimental and suffer from cursor implicitly overwriting them on movenment
function setface {
	[ -z "$1" ] && return
	case "$1" in
		black)      [ "$mode" = '38' ] && printf '\\e[30m' || printf '\\e[40m';;
		red)        [ "$mode" = '38' ] && printf '\\e[31m' || printf '\\e[41m';;
		green)      [ "$mode" = '38' ] && printf '\\e[32m' || printf '\\e[42m';;
		yellow)     [ "$mode" = '38' ] && printf '\\e[33m' || printf '\\e[43m';;
		blue)       [ "$mode" = '38' ] && printf '\\e[34m' || printf '\\e[44m';;
		magenta)    [ "$mode" = '38' ] && printf '\\e[35m' || printf '\\e[45m';;
		cyan)       [ "$mode" = '38' ] && printf '\\e[36m' || printf '\\e[46m';;
		light-gray) [ "$mode" = '38' ] && printf '\\e[37m' || printf '\\e[47m';;

		gray)          [ "$mode" = '38' ] && printf '\\e[90m' || printf '\\e[100m';;
		light-red)     [ "$mode" = '38' ] && printf '\\e[91m' || printf '\\e[101m';;
		light-green)   [ "$mode" = '38' ] && printf '\\e[92m' || printf '\\e[102m';;
		light-yellow)  [ "$mode" = '38' ] && printf '\\e[93m' || printf '\\e[103m';;
		light-blue)    [ "$mode" = '38' ] && printf '\\e[94m' || printf '\\e[104m';;
		light-magenta) [ "$mode" = '38' ] && printf '\\e[95m' || printf '\\e[105m';;
		light-cyan)    [ "$mode" = '38' ] && printf '\\e[96m' || printf '\\e[106m';;
		white)         [ "$mode" = '38' ] && printf '\\e[97m' || printf '\\e[107m';;
		*) case "${1::1}" in
			   '#')
				   if [ "$TERM" = 'linux' ] && ((options[tty-linuxfb])); then # Hack for linux framebuffer tty
					   case "$mode" in
						   38) printf '\\e]P2%s\\e[32m' "${1:1:6}" ;;
						   48) printf '\\e]P1%s\\e[41m' "${1:1:6}"
					   esac
				   else
					   local r="${1:1:2}"
					   local g="${1:3:2}"
					   local b="${1:5:2}"
					   printf '\\e[%d;2;%d;%d;%dm' "${mode}" $((16#$r)) $((16#$g)) $((16#$b))
				   fi;;
			   'c')
				   printf '\\e[%d;5;%dm' "${mode}" "${1:1}"
		   esac
	esac
	shift
	[ -n "$1" ] && "$@";
}

## :foreground
# Set foreground color.
# 'See <a> doc-goto setface : <f> link setface </f> </a> for more info.'
function :foreground { mode=38; setface "$@"; }

## :background
# Set background color.
# 'See <a> doc-goto setface : <f> link setface </f> </a> for more info.'
function :background { mode=48; setface "$@"; }

## :mode Sets text mode:
# '	inverse - inverses background and foreground'
function :mode {
	case "$1" in
		inverse) printf '\\e[7m';;
	esac
	shift
	[ -n "$1" ] && "$@";
}
	
## :weight Sets thickness of text:
:+     bold
#     dim
#     normal
function :weight {
	case "$1" in
		bold) printf '\\e[1m';;
		dim) printf '\\e[2m';;
		normal) printf '\\e[m'
	esac
	shift
	[ -n "$1" ] && "$@";
}

## :slant Sets slant of text:
:+     italic
#     normal
function :slant {
	case "$1" in
		italic) printf '\\e[3m';;
		normal) printf '\\e[m'
	esac
	shift
	[ -n "$1" ] && "$@";
}
	
## kbd Converts Emacs like key notation into hex.
function kbd {
	local -i i=0
	local out
	local in
	local -i ch=1
	# Surely there is better solution...
	case "$1" in
		C-a) printf '1 0' ;; C-b) printf '2 0' ;;
		C-c) printf '3 0' ;; C-d) printf '4 0' ;;
		C-e) printf '5 0' ;; C-f) printf '6 0' ;;
		C-g) printf '7 0' ;; C-h) printf '8 0' ;;
		C-i) printf '9 0' ;; C-j) printf 'a 0' ;;
		C-k) printf 'b 0' ;; C-l) printf 'c 0' ;;
		C-m) printf 'd 0' ;; C-n) printf 'e 0' ;;
		C-o) printf 'f 0' ;; C-p) printf '10 0';;
		C-q) printf '11 0';; C-r) printf '12 0';;
		C-s) printf '13 0';; C-t) printf '14 0';;
		C-u) printf '15 0';; C-v) printf '16 0';;
		C-w) printf '17 0';; C-x) printf '18 0';;
		C-y) printf '19 0';; C-z) printf '1a 0';;
		*)  ch=0
			case "${1:0:2}" in
				M-) in="${1:2:1}";;
				*) in="$1"
			esac
	esac
	((ch)) && return
	echo "$in" | {
		while read -rsn1; do
			out+="$(printf "%x\n" "'${in:$i}") "
			((i++))
		done
	}
	out=${out::-1}
	printf '%s' "${out}"
}

## define-key defines keybinding
:+     '$1' can be either:
#     '[function-key]'
#     '[arrow-key]'
#     '[prior | next]'
#     'RET'
#     'DEL'
#     '[delechar]'
#     'hex code ending with 0'
function define-key {
	local -n keys="keys_$1"
	case "$2" in
		#function keys
		'[f1]') keys[1b 4f 50 0]="$3";;
		'[f2]') keys[1b 4f 51 0]="$3";;
		'[f3]') keys[1b 4f 52 0]="$3";;
		'[f4]') keys[1b 4f 53 0]="$3";;
		'[f5]')  keys[1b 5b 31 35 7e 0]="$3";;
		'[f6]')  keys[1b 5b 31 37 7e 0]="$3";;
		'[f7]')  keys[1b 5b 31 38 7e 0]="$3";;
		'[f8]')  keys[1b 5b 32 39 7e 0]="$3";;
		'[f9]')  keys[1b 5b 32 30 7e 0]="$3";;
		'[f10]') keys[1b 5b 32 31 7e 0]="$3";;
		'[f11]') keys[1b 5b 32 33 7e 0]="$3";;
		'[f12]') keys[1b 5b 32 34 7e 0]="$3";;
		#arrow keys
		'[left]')  keys[1b 5b 44 0]="$3";;
		'[up]')    keys[1b 5b 41 0]="$3";;
		'[right]') keys[1b 5b 43 0]="$3";;
		'[down]')  keys[1b 5b 42 0]="$3";;
		#pg up & down
		'[prior]') keys[1b 5b 36 7e 0]="$3";;
		'[next]')  keys[1b 5b 35 7e 0]="$3";;
		#return
		'RET') keys[a 0]="$3";;
		#backspace & delete
		'DEL') keys[7f 0]="$3";;
		'[deletechar]') keys[1b 5b 33 7e 0]="$3";;
		'ESC') keys[1b 0 0]="$3";;
		'[deletechar]') keys[1b 5b 33 7e 0]="$3";;
		*) keys["$2"]="$3"
	esac
}

## local-set-key
# Sets keybinding of lastly defined mode
# See define-key for details
@fn local-set-key 'define-key "$_last_keys" "$@"'

## global-set-key
# Sets keybinding of global mode
# See define-key for details
@fn global-set-key 'define-key global "$@"'

## define-mode-option
# Sets option of mode '$1'
function define-mode-option {
	local -n ko="key_options_$1"
	ko["$2"]="$3"
}

## local-set-mode-option See define-mode-option
@fn local-set-mode-option 'define-mode-option "$_last_keys" "$@"'

## mode-options Brings mode-options of lastly defined mode into \"focus\"
@fn mode-options '_last_add="mode-options"'


## add-alias Adds alias '$1' of command '$2...' to M-x
function add-alias {
	local name="$1"
	shift
	alias["$name"]="$@"
}

## set-alias Brings into \"focus\" alias setting
@fn set-alias '_last_add=set-alias'

## add-highlight Sets highlighting mode '$1' for file types '$2...'
function add-highlight {
	local name="$1"
	shift
	for i in "$@"; {
		highlight["$i"]="$name"
	}
}

## set-alias Brings into \"focus\" highlight setting
@fn set-highlight '_last_add=set-highlight'

## clear-screen clears screen
@fn clear-screen "printf '\033c'"

## add-mode
# Adds keybing mode
function add-mode {
	log_buffer+=("        ADD MODE $1")
	_last_keys="$1"
	_last_add='add-mode'
	modes+=("keys_$1")
	declare -Ag "keys_$1"
	declare -Ag "key_options_$1"
}

## add-menu
# Adds menu
function add-menu {
	# create new menu function & array
	log_buffer+=("        ADD MENU $1")
	eval "function menu-${1} { menu $1; }"
	declare -ag "menu_${1}_0"
	declare -ag "menu_${1}_1"
	_last_menu="$1"
	_last_add='add-menu'
}

## local-set-menu Sets \"focused\" menu item
@fn local-set-menu 'define-menu "$_last_menu" "$1" "$2"'

## global-set Brings into \"focus\" global mode
@fn global-set '_last_add=global-set'

## define-option Defines options[] buffer
@fn define-option 'options["$1"]="$2"'

## set-options Brings into \"focus\" options setting
@fn set-options '_last_add=set-options'

## define-menu
# Defines item in menu '$1' with name '$2' with command '$3'
# '    If command is "menu-top_menu" face menu-back is used.'
function define-menu {
	local -n menu_0="menu_${1}_0"
	local -n menu_1="menu_${1}_1"
	local item_0
	case "$3" in
		'menu-top_menu') item_0="$(printf '%b' "${faces[menu-back]}")$2";;
		*) item_0="$2"
	esac
	menu_0+=("$item_0")
	menu_1+=("$3")
}

## load-theme Loads theme from array
function load-theme {
	local -i t=0
	local k
	local -n theme="$1"
	for i in "${theme[@]}"; {
		((t==0)) && {
			k="$i"
			t=1
		} || {
			faces["$k"]="$i"
			faces_raw["$k"]="$(printf '%b' "$i")"
			t=0
		}
	}
	((t)) && errno=1 die
	# aliases for nicer formating
	faces+=(
		[bl]="${faces[black]}"
		[dr]="${faces[red]}"
		[dg]="${faces[green]}"
		[dy]="${faces[yellow]}"
		[db]="${faces[blue]}"
		[dm]="${faces[magenta]}"
		[dc]="${faces[cyan]}"
		[dw]="${faces[light-gray]}"
		[gr]="${faces[gray]}"
		[lr]="${faces[light-red]}"
		[lg]="${faces[light-green]}"
		[ly]="${faces[light-yellow]}"
		[lb]="${faces[light-blue]}"
		[lm]="${faces[light-magenta]}"
		[lc]="${faces[light-cyan]}"
		[lw]="${faces[light-white]}"
	)
	faces_raw+=(
		[bl]="${faces_raw[black]}"
		[dr]="${faces_raw[red]}"
		[dg]="${faces_raw[green]}"
		[dy]="${faces_raw[yellow]}"
		[db]="${faces_raw[blue]}"
		[dm]="${faces_raw[magenta]}"
		[dc]="${faces_raw[cyan]}"
		[dw]="${faces_raw[light-gray]}"
		[gr]="${faces_raw[gray]}"
		[lr]="${faces_raw[light-red]}"
		[lg]="${faces_raw[light-green]}"
		[ly]="${faces_raw[light-yellow]}"
		[lb]="${faces_raw[light-blue]}"
		[lm]="${faces_raw[light-magenta]}"
		[lc]="${faces_raw[light-cyan]}"
		[lw]="${faces_raw[light-white]}"
	)
}

## extension Set properites of extension
function extension {
	log_buffer+=("- LOADING EXTENSION $1 -")
	extensions+=("$1")
	declare -Ag "${1}_ext_d"
	declare -ng ext_d="${1}_ext_d"
}
## version: Set version of extension
function version: {
	ext_d[version]="$1"
}

log_buffer+=('- LOADING BASH EXTENSIONS DONE -')

## rest of this garbageware

## refresh Refreshes buffer
# 'clears screen, reset syntax, redraws'
# 'See <a> doc-goto clear-screen : <f> link clear-screen </f> </a> for more info.'
function refresh {
	clear-screen
	bf_s=''
	
	message="reloaded..."
	redraw
}

## switch-mode
# Change current mode of buffer into '$1'
function switch-mode {
	bckmode="${bf_d[mode]}"
	bf_d[mode]="$1"
	redraw-statusline
}

## mode-back
# Restores previous mode
function mode-back {
	bf_d[mode]="$bckmode"
	unset bckmode
	redraw-statusline
}

## read-command
# Works like normal "'read'" but for bottom commanline
function read-command {
	printf '\e[%s;0H' $((bf_d[size-y] + bf_d[loc-y]))
	printf '\e[?25h'
	read -re -p "$1" -i "$3" "$2" || return 1
}

## base-name
# Basically equivalent to the "'basename'" coreutil		
function base-name
	for file in "$@"; {
		file="${file%/}"
		printf '%s\n' "${file##*/}"
	}

### TODO: make this make sense

## make-render Creates syntax highlighting for currently visible lines
function make-render {
	make-render-area "${bf_d[base]}" $((bf_d[base] + bf_d[size-y] + bf_d[loc-y]))
}

## make-render-area
# Creates syntax highlighting for lines from '$1' to '$2'
function make-render-area {
    local -i line="$1"
	local -i syntaxline=$line
	local -n linearray="${current_buffer}_syntax${syntaxline}"
	linearray=()
	bckeIFS="${IFS}"
	IFS=
	for ((l=syntaxline;l<${2};l++)); do
		((l > $2)) && break
		local -n linearray="${current_buffer}_syntax${syntaxline}"
		linearray=()
		bf_s[syntaxline]="${current_buffer}_syntax${syntaxline}"
		((syntaxline++))
		line="$l"
		make-render-line-loop
	done
	IFS="$bckeIFS"
}
	
## make-render-line
# Syntax highlights single line '$1'
# Defaults to currently selected line if no argument is passed
function make-render-line {
	local -i line=${1:-bf_d[line]}
	local -i syntaxline=$line
	local -n linearray="${current_buffer}_syntax${syntaxline}"
	bf_s[syntaxline]="${current_buffer}_syntax${syntaxline}"
	linearray=()
	bckeIFS="${IFS}"
	IFS=
	make-render-line-loop
	IFS="$bckeIFS"
}



## make-render-line-loop
# Backend for make-render-area \& make-render-line
# Also creates bf_e charmap for movenment
:+     "Tab is 't'"
#     "Space is 's'"
#     "Any unmaped char is '0'"
function make-render-line-loop {
	local -i comment=0
	local -i skip_next_space=0
	local word=''
	bf_e[line]=''

	for _link in ${bf_c[line]}; do
		unset "$_link"
	done
	unset bf_c[line]
		
	column=0
	while read -rsn1 char; do	
		case "$char" in
			' ')
				syntax-word
				word=''
				((skip_next_space==1)) && skip_next_space=0 && continue
				bf_e[line]+='s'
				face-no-expand "${facename:-${bf_d[background]:-default}}" ' '
				((column++));;
			'	')
				syntax-word
				word=''
				local -i i
				for ((i = ${#options[tabchar]}; i > 0 ; i--)); do
					bf_e[line]+="${charmap[	]}"
				done
				face-no-expand tab-face "${options[tabchar]}"
				((column+=${#options[tabchar]}));;
			'')
				syntax-word
				word=''
				skip_next_space=0
				face-no-expand "${bf_d[background]:-default}" ' '
				newline=1 # tell syntax functions that the previous char was newline # used for format thing
				return;;
			*)
				word+="${char}"
		esac
	done  <<< "${buffer[line]}"
}

## syntax-word
# Decides what a word should highlighted as:
:+     'If todonote option is enabled, highlight "NOTE:" & "TODO:"'
#     'If the word is supposed to be comment highlight it as it'
#     'Else pass it to current syntax function'
function syntax-word {
	(("${options[todonote]}"==1)) && {
		case "$word" in
			'NOTE:') face NOTE "${word}"; return ;;
			'TODO:') face TODO "${word}"; return ;;
		esac
	}
	((comment)) && set-face font-lock-comment-face ||
		"${bf_d[syntax]}"
	((bf_d[syntax-exec])) || face "$syntax_face" "$word" # s_ex controls syntax extended
}

## face
# Add highlighted word to multidimensional nonsense "'bf_s'" arry
function face {
	IFS=' '
	[[ "$2" =~ ${2//?/(.)} ]]
	linearray+=("${faces_raw[reset]}${faces_raw[${1}]}${BASH_REMATCH[@]:1}")
	IFS=''
	for ((iw=0; iw < ${#2}; iw++)); do
		bf_e[line]+='0'
	done
}

## face-no-expand
# Add highlighted word to multidimensional nonsense "'bf_s'" arry without adding anything to bf_e[] array
function face-no-expand {
	IFS=' '
	[[ "$2" =~ ${2//?/(.)} ]]
	linearray+=("${faces_raw[reset]}${faces_raw[${1}]}${BASH_REMATCH[@]:1}")
	IFS=''
}

## set-face Sets face for syntax highlighting
@fn set-face 'syntax_face="$1"'

## size-full
# Sets size of buffer to be fullscreen
function size-full {
	bf_d+=(
		[loc-x]=1
		[loc-y]=1
		[size-x]=$COLUMNS
		[size-y]=$((LINES - 1))
	)
}

## set-buffer
# Switch to buffer \$1 
function set-buffer {
	log info "switch to buffer [$1]"
	current_buffer="$1"
	declare -ng buffer="${current_buffer}_buffer"
	declare -ng bf_s="${current_buffer}_bf_s"
	declare -ng bf_e="${current_buffer}_bf_e"
	declare -ng bf_d="${current_buffer}_bf_d"
	declare -ng bf_c="${current_buffer}_bf_c"
}

## add-to-list
# Adds a buffer into currently active buffer list
function add-to-list {
	log info "added into buffer list: $current_buffer"
	buffers_l+=("$current_buffer")
}

## clear-buffer
# Empties buffer bf_s bf_e \& bf_d
function clear-buffer {
	buffer=()
	for l in "${bf_s[@]}"; {
		unset "$l"
	}
	bf_s=()
	bf_e=()
	for l in "${bf_c[@]}"; {
		unset "$l"
	}
	bf_c=()
}

## list-directory
# Basically like ls command 
function list-directory {
	((hidden==1)) && shopt -s dotglob
	((hidden==0)) && shopt -u dotglob
	printf '..\n'
	printf '%s\n' *
}

## current-time
# Basically like coreutil "'date'"
@fn current-time 'printf "%($1)T\\n"'

## log
# Adds message into log
# '    info -- everything *should* be well'
# '    warn -- something is wrong but it *should* not break entire Ebashs'
# '    error -- something is wrong and anything can break, but it *can* still run(?)'
# '    fatal -- something is mega wrong and only thing left to do is to die'
# Is disabled when log wasn\'t initialised, see init-log for info
function log {
	((log)) || return
	local type="$1"
	shift
	tooktime="$(( $(current-time '%s') - lasttime ))"
	bufferlog+=("<f> title [$type] </f> <f> font-lock-comment-face ${tooktime}s </f> <f> name [${FUNCNAME[1]}] </f> $*")
	lasttime="$(current-time '%s')"
}

## log-echo
# Adds message into log without any special formating	
function log-echo {
	((log)) || return
	bufferlog+=("<f> font-lock-comment-face > </f>    $*")
}

## debug
# +debug -- basically like set -x but reports stuff into log
## +log	
# Debug function to add logging to function it\'s called from
function +log {
	((log)) || return
	((options[log-functions])) && log '*' "${FUNCNAME[1]}"
	trap 'log bash $? $LINENO ${BASH_COMMAND}' ERR
}
## +debug
# Debug function to add extensive \(set -x like\) logging to function it\'s called from
function +debug {
	((log)) || return
	trap 'log DEBUG "${BASH_COMMAND}"' DEBUG
}

## goto Load array into buffer
function goto {
	clear-buffer
	bf_d[line]=1
	bf_d[column]=0
	copy-array "$1" buffer
	redraw
}

@doc syntax-format <<'EOF'
Convert formated text into Ebashs buffer understandable format.

<f> title <u> Specifications </u> </f>

<[> name <f> <f> hint face_name text... </f> <[> name </f>
<-> Set <f> hint text </f> to face <f> hint face_name </f-> .

<[> name <h> <f> hint text... </f> <[> name </h>
<-> Make <f> hint text </f> into title.

<[> name <a> <f> hint command </f> <[> name : <f> hint text </f> <[> name </a>
<-> Create clickable area that executes <f> hint command </f> on click and is labeled <f> hint text </f-> .
<-> See <a> doc-goto link-enter : <f> link link-enter </f> </a> 

<[> name <link> <f> hint command </f> <[> name : <f> hint text </f> <[> name </link>
<-> Create clickable area that executes <f> hint command </f> on click and is labeled <f> hint text </f-> .
<-> <[> name <link> also automatically adds <f> link link </f> face to text.

<[> name <u> <f> hint text </f> <[> name </u>
<-> Make <f> hint text </f> <u> uppercase. </u>

<[> name <i> <f> hint number_of_spaces hint text </f-> ...\n...\n...\n... <[> name </i>
<i-tab> Indent lines by <f> hint number of spaces </f-> .

<[> name <i-tab>
<-> Indent by tab (default 4 spaces).
<-> Tab size is controlled via tab_format variable. </i>

<[> name <s> <f> hint number_of_spaces </f>
<-> Insert <f> hint number of spaces </f-> .

<[> name <tab>
<-> Insert tab.
<-> <[> name <-> is alias for <[> name <tab>.

<[> name <v> <f> hint variable_name </f> <[> name </v>
<-> Insert contents of <f> hint variable </f> into text at formating time.

<[> name <\> <f> hint text </f>
<-> Escape <f> hint text </f>

<[> name <[> <f> hint face_name text </f>
<-> Escape <f> hint text </f> with <f> hint face </f-> .


Some of these keywords also include versions to glue together with other words.
For example:
<-> text <[> name <-f> <f> name face </f> color! <[> name </f-> text
Will turn into text <-f> lr c <-f> ly o <-f> lg l <-f> lc o <-f> lb r <-f> lm ! </f> </f> </f> </f> </f> </f-> text.
EOF
function syntax-format {
	((skip_word==1)) && {
		skip_next_space=1
		[ "$word" = '-->' ] && skip_word=0
		return
	}
	[ "$word" = '<!--' ] && {
		skip_next_space=1
		skip_word=1
		return
	}
	((newline==1)) && {
		ichar="${indent_spaces}"
	}
	((newline==0)) && {
		ichar=
	}

	((escape==2)) && {
		escape=1
		facename="$word"
		skip_next_space=1
		return
	}
	((escape==1)) && {
		escape=0
		face "$facename" "${ichar}$word"
		return
	}
	[ "$word" = '<\>' ] && {
		escape=1
		skip_next_space=1
		facename='unknown'
		return
	}
	[ "$word" = '<[>' ] && {
		escape=2
		skip_next_space=1
		return
	}
	
	((variable==1)) && {
		variable=0
		word="${!word}"
	}
	[ "$word" = '<v>' ] && {
		variable=1
		varname=
		skip_next_space=1
		return
	}

	[ "$word" = '</u>' ] && {
		upper=0
		skip_next_space=1
		return
	}
	[ "$word" = '<u>' ] && {
		upper=1
		skip_next_space=1
		return
	}
	[ "$word" = '</f>' ] && {
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		((column--))
		unset facename
		[ -n "$bckfacename" ] && {
			facename="$bckfacename"
			unset bckfacename
		}
		return
	}
	[ "$word" = '</f->' ] && {
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		((column--))
		skip_next_space=1
		[ -n "$bckfacename" ] && {
			facename="$bckfacename"
			unset bckfacename
		}
		return
	}
	((facedef==1)) && {
		skip_next_space=1
		facedef=0
		facename="$word"
		return
	}
	[ "$word" = '<f>' ] && {
		bckfacename="$facename"
		skip_next_space=1
		facedef=1
		return
	}
	[ "$word" = '<-f>' ] && {
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		((column--))
		bckfacename="$facename"
		skip_next_space=1
		facedef=1
		return
	}
	
	[ "$word" = '</h>' ] && {
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		((column--))
		unset facename
		upper=0
		[ -n "$bckfacename" ] && {
			facename="$bckfacename"
			unset bckfacename
		}
		return
	}
	[ "$word" = '<h>' ] && {
		bckfacename="$facename"
		skip_next_space=1
		facename=title
		upper=1
		return
	}
	
	((sethighlight==2)) && {
		sethighlight=1
		skip_next_space=1
		tmp_sex="$word"
		return
	}
	((sethighlight==1)) && {
		sethighlight=0
		skip_next_space=1
		bf_d[syntax-exec]="$tmp_sex"
		bf_d[syntax]="syntax-$word"
		return
	}
	[ "$word" = '<change-syntax>' ] && {
		skip_next_space=1
		sethighlight=2
		return
	}
	((space_next==1)) && {
		space_next=0
		skip_next_space=1
		for ((if=0; if< word; if++)) {
			linearray+=(' ')
			bf_e[line]+='s'
			((column++))
		}
		return
	}
	[ "$word" = '<s>' ] && {
		space_next=1
		skip_next_space=1
		return
	}
	[ "$word" = '<tab>' ] || [ "$word" = '<->' ] && {
		skip_next_space=1
		for ((if=0; if< format_tab; if++)) {
			linearray+=(' ')
			bf_e[line]+='s'
			((column++))
		}
		return
	}
	[ "$word" = '</i>' ] && {
		indent_spaces=
		return
	}
	((indent==1)) && {
		indent=0
		skip_next_space=1
		indent_spaces=
		indent_spaces_e=
		for ((if=0; if< word; if++)) {
			indent_spaces+=' '
			indent_spaces_e+='s'
		}
		return
	}
	[ "$word" = '<i>' ] && {
		indent=1
		skip_next_space=1
		return
	}
	[ "$word" = '<i-tab>' ] && {
		skip_next_space=1
		indent_spaces=
		indent_spaces_e=
		for ((if=0; if< format_tab; if++)) {
			indent_spaces+=' '
			indent_spaces_e+='s'
		}
		return
	}
	((link==2)) && {
		[ "$word" = ':' ] && {
			((
				skip_next_space=1,
				link=1
			))
			return
		}
		skip_next_space=1
		linkfn+="$word "
		return
	}
	[ "$word" = '</a>' ] && {
		((lc++))
		((column--))
		link=0
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		bf_c[line]+="bf_c_${lc}_${current_buffer} "
		declare -Ag "bf_c_${lc}_${current_buffer}"
		local -n bf_c_line="bf_c_${lc}_${current_buffer}"
		bf_c_line=(
			[start]="$lsx"
			[end]=$((column - 1))
			[exec]="$linkfn"
		)
		return
	}
	[ "$word" = '<a>' ] && {
		((
			link=2,
			lsx=column,
			skip_next_space=1
		))
		linkfn=
		return
	}
	((facelink==2)) && {
		[ "$word" = ':' ] && {
			((
				skip_next_space=1,
				facelink=1
			))
			facename='link'
			return
		}
		skip_next_space=1
		linkfn+="$word "
		return
	}
	[ "$word" = '</link>' ] && {
		((lc++))
		((column--))
		facelink=0
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		bf_c[line]+="bf_c_${lc}_${current_buffer} "
		declare -Ag "bf_c_${lc}_${current_buffer}"
		local -n bf_c_line="bf_c_${lc}_${current_buffer}"
		bf_c_line=(
			[start]="$lsx"
			[end]=$((column - 1))
			[exec]="$linkfn"
		)
		unset facename
		[ -n "$bckfacename" ] && {
			facename="$bckfacename"
			unset bckfacename
		}
		return
	}
	[ "$word" = '<link>' ] && {
		((
			facelink=2,
			lsx=column,
			skip_next_space=1
		))
		linkfn=
		return
	}
	
	((object==1)) && {
		skip_next_space=1
		[ "$word" = 'text:' ] && {
			object=0
			set_obj=0
			return
		}
		[ "$word" = 'select:' ] && { set_obj=1; obj_select=; return; }
		[ "$word" = 'id:' ] && { set_obj=2; obj_id=; return; }
		[ "$word" = 'left:' ] && { set_obj=3; obj_left=; return; }
		[ "$word" = 'up:' ] && { set_obj=4; obj_up=; return; }
		[ "$word" = 'right:' ] && { set_obj=5; obj_right=; return; }
		[ "$word" = 'down:' ] && { set_obj=6; obj_down=; return; }

		((set_obj==1)) && obj_select+="$word "
		((set_obj==2)) && obj_id+="$word "
		((set_obj==3)) && obj_left+="$word "
		((set_obj==4)) && obj_up+="$word "
		((set_obj==5)) && obj_right+="$word "
		((set_obj==6)) && obj_down+="$word "
		return
	}
	[ "$word" = '</o>' ] && {
		((lc++))
		((column--))
		link=0
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		bf_c[line]+="bf_c_${lc}_${current_buffer} "
		declare -Ag "bf_c_${lc}_${current_buffer}"
		local -n bf_c_line="bf_c_${lc}_${current_buffer}"
		bf_c_line=(
			[start]="$lsx"
			[end]=$((column - 1))
			[exec]="$obj_select"
			[id]="$obj_id"
			[left]="$obj_left"
			[up]="$obj_up"
			[right]="$obj_right"
			[down]="$obj_down"
		)
		return
	}
	[ "$word" = '<o>' ] && {
		((
			object=1,
			lsx=column,
			skip_next_space=1
		))
		obj_id=
		obj_text=
		obj_select='true'
		obj_left='backward-char'
		obj_up='previous-line'
		obj_right='forward-char'
		obj_down='next-line'
		set_obj=0
		return
	}
	
	((newline==1)) && newline=0
	((column+=${#ichar} + ${#word}))
	((upper==1)) && {
		word="${word^^}"
	}
	face "${facename:-unknown}" "${ichar}$word"
}

@doc link-enter <<'EOF'
Executes <f> name clickable area </f> of formated text to which current position
of cursor points.
Mostly used for <f> name hyperlinks </f-> .

Internally <f> name clickable area </f> is defined via bf_c 2d array. Each line contains
the <f> name clickable areas </f-> . Each of these is it's own associative array.
Each <f> name clickable area </f> contains:
<i-tab> <[> hint start - the first column of the area
<[> hint end   - the last column of the area
<[> hint exec  - what command should be executed when this function,
<-> <f> name link-enter </f> is ran. </i>
EOF
function link-enter {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"
		#echo "    $link" >> d
		#echo "${bf_c_line[start]}" >> d
		#echo "${bf_c_line[end]}" >> d
		#echo "${bf_c_line[exec]}" >> d
		
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				has=1
				${bf_c_line[exec]}
				return
			}
	}
	${bf_d[format-else]}
}

function format-left {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				${bf_c_line[left]:-backward-char}
				return
			}
	}
	backward-char
}
function format-up {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				${bf_c_line[up]:-previous-line}
				return
			}
	}
	previous-line
}
function format-right {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				${bf_c_line[right]:-forward-char}
				return
			}
	}
	forward-char
}
function format-down {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				${bf_c_line[down]:-next-line}
				return
			}
	}
	next-line
}

function obj {
	for y in "${!bf_c[@]}"; {
		for obj in ${bf_c[y]}; {
			local -n bf_c_line="$obj"
			[ "${bf_c_line[id]}" = "$1 " ] && {
				((bf_d[line]=y, bf_d[column]=bf_c_line[start]))
				redraw-cursor
			}
		}
	}
}
	
@fn is-function 'declare -F -- "$1" > /dev/null'

## Dumps current buffer into a file	
function dump-buffer {
	true >"$1" # Set the file to an empty text file
	for ln in "${buffer[@]}"; do # Write in the buffer to the file
		echo "$ln" >>"$1"
	done
}

## die
# Closes Ebashs with exit code \$errno, if errno is empty exit with 0
# If \$nocleanup is 1, do not restore the terminal to sane mode and do not cleanup 
# Else restore to sane mode 
function die {
	((nocleanup)) && exit "${errno:-0}"
	${on_die:-true}
	echo -e "\e[?1000;1006;1015l" #disable mouse tracking
	clear-screen # TODO fix the buffer switching
	printf '\e[?25h\e[?7h\e[?1049l' # Reset terminal to sane mode
	exit "${errno:-0}" # Assume that we are exiting without an error
}

# Sets \$nocleanup to 1 and dies	
function abort {
	((nocleanup=1)) && die "$@"
}

fragment keepcolumn <<'+'
	[ -z "$bckrl" ] && bckrl="${bf_d[column]}"	
	(( ${#bf_e[bf_d[line]]} < bf_d[column] )) && bf_d[column]=${#bf_e[bf_d[line]]}
	(( ${#bf_e[bf_d[line]]} > bckrl )) && bf_d[column]=${bckrl}
+

# Moves up \$1 lines, if \$ is empty move up 1 line
function move-previous-line {
	for ((i = 0; i < ${1:-1}; i++)); do
		((bf_d[line] > 1)) && ((bf_d[line]--)) # As long as we can keep going up, go up
		((bf_d[line] < bf_d[base] + 1)) && {
			((bf_d[base]--)) # Push back the top if we need to
			move_base=1 # Send signal to redraw-cursor that the buffer was moved, thus needs to be redraw fully
			((bf_d[base] <= 0)) && bf_d[base]=1 # Don't push back if our base is at 1
		}
		[ -z "$bckrl" ] && bckrl="${bf_d[column]}"	
		(( ${#bf_e[bf_d[line]]} < bf_d[column] )) && bf_d[column]=${#bf_e[bf_d[line]]}
		(( ${#bf_e[bf_d[line]]} > bckrl )) && bf_d[column]=${bckrl}
	done
}

# Moves down \$1 lines, if \$ is empty move down 1 line
function move-next-line {
	for ((i = 0; i < ${1:-1}; i++)); do
		((bf_d[line] < ${#buffer[@]}+1)) && ((bf_d[line]++)) # If we can go down, go down
		# Move window down if needed
		((bf_d[line] > bf_d[base] + bf_d[size-y] - 3 - bottomlines)) && {
			((bf_d[base]++))
			move_base=1
		}
		[ -z "$bckrl" ] && bckrl="${bf_d[column]}"	
		(( ${#bf_e[bf_d[line]]} < bf_d[column] )) && bf_d[column]=${#bf_e[bf_d[line]]}
		(( ${#bf_e[bf_d[line]]} > bckrl )) && bf_d[column]=${bckrl}
	done
}

function previous-line {
	move-previous-line "$@"
	redraw-statusline
	if ((bf_d[selection])); then
		redraw
	else
		redraw-cursor
	fi
}
function next-line {
	move-next-line "$@"
	redraw-statusline
	if ((bf_d[selection])); then
		redraw
	else
		redraw-cursor
	fi
}
function scroll-down {
	move-previous-line $((bf_d[size-y] - 3))
	redraw-statusline
	if ((bf_d[selection])); then
		redraw
	else
		redraw-cursor
	fi
}
function scroll-up {
	move-next-line $((bf_d[size-y] - 3))
	redraw-statusline
	if ((bf_d[selection])); then
		redraw
	else
		redraw-cursor
	fi
}
	
@fn move-beginning-of-line 'bf_d[column]=0; redraw'
@fn move-end-of-line 'bf_d[column]="${#bf_e[${bf_d[line]}]}"; redraw'


function move-select {
	((bf_d[selection])) || {
		bf_d[selection_start_y]="${bf_d[line]}"
		bf_d[selection_start_x]="${bf_d[column]}"
		bf_d[selection]=1
	}
}

function select-forward {
	move-select
	forward-char
}
function select-backward {
	move-select
	backward-char
}
function select-next {
	move-select
	next-line
}
function select-previous {
	move-select
	previous-line
}

function forward-char {
	for ((i = 0; i < ${1:-1}; i++)); do
		case "${bf_e[${bf_d[line]}]:${bf_d[column]}+1:1}" in
			't') bf_d[column]=$(( bf_d[column]+${#options[tabchar]}));;
			*) ((bf_d[column]++));;
		esac
		((bf_d[column] > ${#bf_e[${bf_d[line]}]})) && {
			bf_d[column]=0
			next-line
			return
		}
		bckrl=
	done
	if ((bf_d[selection])); then
		redraw
	else
		redraw-cursor-line
	fi
}

function backward-char {
	for ((i = 0; i < ${1:-1}; i++)); do
		case "${bf_e[${bf_d[line]}]:${bf_d[column]}-1:1}" in
			't') bf_d[column]=$(( bf_d[column]-${#options[tabchar]}));;
			*) ((bf_d[column]--));;
		esac
		((bf_d[column] < 0)) && ((bf_d[line]==1)) && {
			bf_d[line]=1
			bf_d[column]=0
		}
		((bf_d[column] < 0)) && {
			bf_d[column]="${#bf_e[${bf_d[line]}-1]}"
			previous-line
			return
		}
		bckrl=
	done
	if ((bf_d[selection])); then
		redraw
	else
		redraw-cursor-line
	fi
}
	
## forward-word
# Moves forward to next word
function forward-word {
	((bf_d[column] == ${#bf_e[bf_d[line]]})) && {
		next-line
		move-beginning-of-line
	}
	while :; do
		((bf_d[column] < ${#bf_e[bf_d[line]]})) && ((bf_d[column]++)) || break
		case "${bf_e[bf_d[line]]:${bf_d[column]}:1}" in
			't'|'s') break
		esac
	done
	redraw
}

## backward-word
# Moves backward to previous word
function backward-word {
	((bf_d[column] == 0)) && {
		previous-line
		move-end-of-line
	}
	while :; do
		((bf_d[column] > 0)) && ((bf_d[column]--)) || break
		case "${bf_e[bf_d[line]]:${bf_d[column]}:1}" in
			't'|'s') break
		esac
	done
	redraw
}


@doc to-line <<'+'
Move cursor to line number $1 and move the line into middle of visible buffer area.
+
function to-line {
	bf_d[line]="$1"
	bf_d[base]=$((bf_d[line] - bf_d[size-y] / 2 ))
	redraw
}
			
# Handle clicking on top menu with mouse		
function menuline-mouse {
	local -n top_0="menu_${bf_d[menuline]}_0"
	local -n top_1="menu_${bf_d[menuline]}_1"
	#determine which item should be triggered
	[ -z "$1" ] && menuloc_x=0 || menuloc_x=$1
	local cx="${bf_d[loc-x]}"
	i=0
	for i in "${!top_0[@]}"; {
		la="${#top_0[i]}"
		((menuloc_x>cx)) && ((menuloc_x<(cx + la + 1))) && {
			${top_1[$i]}
			return
		}
		cx=$(( cx + la + 1 ))
	}
}
# Redraw popup menu
function redraw-menu {
	printf '\e[?25l' # hide cursor (again)
	printf '\e[%s;0H' $menuloc_y
	for i in "${!menu_0[@]}"; {
		if ((i == menuselection)); then
			printf "\e[%sC${faces[menu-selected-face]}%s${reset}\n" $menuloc_x "${menu_0[i]}"  
		else
	   		printf "\e[%sC${faces[menu-enabled-face]}%s${reset}\n" $menuloc_x "${menu_0[i]}"
		fi
	}
}


function menuup {
	((menuselection > 0)) && ((menuselection--));
	redraw-menu;
}
function menudown {
	((menuselection < ${#menu_0[@]} -1)) && ((menuselection++));
	redraw-menu;
}

# Execute selected item in menu
function menuselect
for i in "${!menu_1[@]}"; {
	((i == menuselection)) && "${menu_1[i]}"
}

# Closes a menu
function menuleave {
	ismenu=0
	bf_d[mode]="${modebackup}"
	redraw
}

# Opens a menu \$1	
function menu {
	declare -ng menu_0=menu_${1}_0
	declare -ng menu_1=menu_${1}_1
	((ismenu == 0 )) && modebackup="${bf_d[mode]}"
	ismenu=1
	declare -ig menuselection=0
	bf_d[mode]='menu'
	redraw
}

# deletes current buffer
function delete-buffer {
	local -a copy
	local i=0
	local index
	for b in "${buffers_l[@]}"
	do
		[[ "$b" != "$current_buffer"  ]] && copy+=("$b")
		[[ "$b" = "$current_buffer"  ]] && index="$i"
		((i++))
	done
	unset buffers_l
	copy-array copy buffers_l
	current_buffer="${buffers_l[index-1]}"
	redraw
}
						
# Draw multiline region
function selection-draw
if ((i == bf_d["${1}_y"])); then
	printf "${ln}%*s\e[%sG%b%s%b%s%b%b"\
		   ${lnargs[@]}\
		   $((bf_d[size-x] - bf_d[number-length]))\
		   ''\
		   $((bf_d[loc-x] + bf_d[number-length] + space))\
		   "${faces[default]}"\
		   "${linearray[*]:bf_d[basecolumn]:bf_d[${1}_x]}"\
		   "\e[m${faces[region]}"\
		   "${buffer[i]:bf_d[${1}_x]:bf_d[size-x] - (bf_d[number-length] + 1)}"\
		   "${faces[default]}" "$nlchar"
elif ((i == bf_d["${2}_y"])); then
	printf "${ln}%*s\e[%sG%b%b%s%b%s%b%b"\
		   ${lnargs[@]}\
		   $((bf_d[size-x] - bf_d[number-length]))\
		   ''\
		   $((bf_d[loc-x] + bf_d[number-length] + space))\
		   "${faces[default]}"\
		   "${faces[region]}"\
		   "${buffer[i]:bf_d[basecolumn]:bf_d[${2}_x]}"\
		   "\e[m"\
		   "${linearray[*]:bf_d[${2}_x]:bf_d[size-x]}"\
		   "${faces[default]}" "$nlchar"
else
	printf "${ln}%*s\e[%sG%b%b%s%b%b"\
		   ${lnargs[@]}\
		   $((bf_d[size-x] - bf_d[number-length]))\
		   ''\
		   $((bf_d[loc-x] + bf_d[number-length] + space))\
		   "${faces[default]}"\
		   "${faces[region]}" "${buffer[i]:bf_d[basecolumn]:bf_d[size-x] - (bf_d[number-length] + 1)}"\
		   "${faces[default]}" "$nlchar"
fi

# Handle changing size of terminal
function change-size-screen {
	bf_d[size-x]="$COLUMNS"
	bf_d[size-y]=$((LINES-1))
	redraw
}
	
## redraw
# Redraw screen
function redraw {
	[ -n "${bf_d[redraw]}" ] && {
		"${bf_d[redraw]}" "$@"
		return
	}
	printf '\e[?25l'

	# the first line should be always empty 
	unset buffer[0]
	
	# Handle changing size of buffer
	((bf_d[size-x]!=bcksize_x)) || ((bf_d[size-y]!=bcksize_y)) && {
		# Make the statusline full of dashes
		dashline=$(
			for ((i=0; i<bf_d[size-x]; i++)) {
				printf '-'
			}
		)
		bcksize_x=${bf_d[size-x]}
		bcksize_y=${bf_d[size-y]}
	}
		
	# Get length of line-number of lines
	bf_d[length]="${#buffer[@]}"
	((bf_d[length]==0)) &&((bf_d[length]++))
	
	((options[line-number-mode])) && {
		bf_d[number-length]=${#bf_d[length]}
		bf_d[number-space]=1
	} || ((bf_d[number-length]=0, bf_d[number-space]=0))
	
	# Update selection ends to current cursor
	((bf_d[selection]==1)) &&
		((bf_d[selection_end_y]=bf_d[line], bf_d[selection_end_x]=bf_d[column]))
	
	# Move the buffer horizontally if needed
	((bf_d[column] +3 < bf_d[size-x] - bf_d[number-length] - 1)) &&
		bf_d[basecolumn]=0
	((bf_d[column] +3 > bf_d[size-x] - bf_d[number-length] - 1)) &&
		bf_d[basecolumn]=$((bf_d[column] - (bf_d[size-x] + bf_d[loc-x] - bf_d[number-length] - 1) +3))

	# Draw top menuline
	(("${options[menu-line]}"==1)) && {
		"${bf_d[menuline-function]:-redraw-menuline}"
	} || printf "\e[%s;%sH" "${bf_d[loc-y]}" "${bf_d[loc-x]}"

	# IFS has to be empty in order to bufferarray multiarray be printed as words instead of chars
	IFS=''

	# Handle line number displaying
	# the resulting line has to be printed in one go to prevent flicker
	# space stores if the position of actuall text should be offset by +1
	# ln stores printf print line
	# args stores printf arguments
	local -i space
	local ln
	local -a lnargs
	
	# Iterate over shown lines
	local -i max=$((bf_d[size-y] - (toplines + bottomlines) + 1))
	for ((i = bf_d[base]; i - bf_d[base] < max; i++)); do
	# if the line is last, do not add newline

		ln="\e[%dG"
		lnargs=(
			"${bf_d[loc-x]}"
		)
		if ((options[line-number-mode])); then
			space=1
			ln="\e[%dG%b%*s"
			lnargs=(
				"${bf_d[loc-x]}"
				"${faces[line-number]}"
				"${bf_d[number-length]}"
				"$i"
			)
			((i == bf_d[line])) && lnargs[1]="${faces[line-number-current-line]}"
		fi
		
		((i - bf_d[base] > max - 2)) && nlchar='' || nlchar='\n'

		((i > ${#buffer[@]})) &&
			printf '\e[%sG%b%*s%s%b%*s%b'\
				   "${bf_d[loc-x]}"\
				   "${faces[line-number-empty]}"\
				   $((bf_d[number-length]/2)) ''\
				   "${options[empty-line-char]}"\
				   "${faces[default]}"\
				   $((bf_d[size-x] - bf_d[number-length]))\
				   ''\
				   "$nlchar" &&
			continue
		
		# to improve speed syntaxing has to be "lazy" -- having to be heavily cached as ram is far less expensive to waste
		[ -z "${bf_s[base+i]}" ] && {
			make-render-line $((base + i))
		}
		local -n linearray="${bf_s[i]}"
		
		# draw the selection area
		((bf_d[selection])) && {
			((i == bf_d[selection_start_y])) &&
				((bf_d[selection_start_y] == bf_d[selection_end_y])) && {
					((bf_d[selection_start_x] <= bf_d[selection_end_x])) && {
						local -n sx=bf_d[selection_start_x]
						local -n ex=bf_d[selection_end_x]
					} || {
						local -n sx=bf_d[selection_end_x]
						local -n ex=bf_d[selection_start_x]
					}
					printf "${ln}%*s\e[%sG%b%s%b%s%b%s%b"\
						   ${lnargs[@]}\
						   $((bf_d[size-x] - bf_d[number-length]))\
						   ''\
						   $((bf_d[loc-x] + bf_d[number-length] + space))\
						   "${faces[default]}"\
						   "${linearray[*]:bf_d[basecolumn]:sx}"\
						   "\e[m${faces[region]}"\
						   "${buffer[i]:sx:ex-sx}"\
						   "\e[m"\
						   "${linearray[*]:ex:bf_d[size-x]}"\
						   "$nlchar"
					continue
				}
			((i >= bf_d[selection_start_y])) && ((i <= bf_d[selection_end_y])) && {
				selection-draw selection_start selection_end
				continue
			}
			((i <= bf_d[selection_start_y])) && ((i >= bf_d[selection_end_y])) && {
				selection-draw selection_end selection_start
				continue
			}
		}
		# due to escape codes present in bf_s,
		# the bf_s has to be multidimensional nonsense for perfomance reasons
		printf "${ln}%b%*s\e[%sG%b%s\e[m%b"\
			   ${lnargs[@]}\
			   "${faces[${bf_d[background]:-default}]}"\
			   $((bf_d[size-x] - bf_d[number-length]))\
			   ''\
			   $((bf_d[loc-x] + bf_d[number-length] + space))\
			   "${faces[${bf_d[background]:-default}]}"\
			   "${linearray[*]:bf_d[basecolumn]:bf_d[size-x] - (bf_d[number-length])}"\
			   "$nlchar"
	done
	redraw-statusline
	redraw-commandline
	((no_cursor)) || redraw-cursor		
	@ifs		
	# redraw menu if open
	[ "${bf_d[mode]}" = 'menu' ] && redraw-menu
}

## print-buffer-line
function print-buffer-line {
	IFS=''
	local -n linearray="${bf_s[bf_d[line]]}"
	printf '%s' "${linearray[*]:bf_d[basecolumn]:bf_d[size-x] - (bf_d[number-length])}"
	@ifs
}

## redraw-menuline Redraws top menu line
function redraw-menuline {
	local -n top_0="menu_${bf_d[menuline]}_0"
	printf "\e[0m\e[%s;%sH${faces[menu]}\e[?25l%*s\r%s"\
		   "${bf_d[loc-y]}"\
		   "${bf_d[loc-x]}"\
		   "${bf_d[size-x]}"\
		   "${bf_d[info]}"
	printf '\e[%sG%s\e[0m\n' "${bf_d[loc-x]}" "${top_0[*]}"
}

# Draw cursor on the line
function redraw-cursor-line {
	((options[full-redraw]==0)) && {
		# redraw if buffer needs to be moved horizontally
		((bf_d[column] > bf_d[size-x] - bf_d[number-lenght] - space)) && {
			redraw
			return
		}
		((bf_d[basecolumn]==0)) || {
			redraw
			return
		}
		printf '\e[%sG\e[?25h'\
			   $((bf_d[column] - bf_d[basecolumn] + bf_d[number-length] + bf_d[loc-x] + bf_d[number-space])) ||
			redraw
	}
}
	
# Draw cursor and if move_base is 1 redraw
function redraw-cursor {
	((options[full-redraw])) && {
		no_cursor=1
		redraw
		no_cursor=0
	}
	((move_base)) && {
		move_base=0
		redraw
		return
	}
	local -i y=$((bf_d[line] + options[menu-line] - bf_d[base] + bf_d[loc-y]))
	((options[line-number-mode])) && {
		printf '\e[%s;%sH%b%*s\e[m'\
			   $((last_line + options[menu-line] - bf_d[base] + bf_d[loc-y]))\
			   "${bf_d[loc-x]}"\
			   "${faces[line-number]}"\
			   ${bf_d[number-length]}\
			   $last_line
		printf '\e[%s;%sH%b%*s\e[m'\
			   $y\
			   "${bf_d[loc-x]}"\
			   "${faces[line-number-current-line]}"\
			   ${bf_d[number-length]}\
			   ${bf_d[line]}
	}
	printf '\e[%s;%sH\e[?25h'\
		   $y\
		   $((bf_d[column] - bf_d[basecolumn] + bf_d[number-length] + bf_d[loc-x] + bf_d[number-space]))
	last_line=${bf_d[line]}
}

# Draw bottom mode/status line
function redraw-statusline {
	((options[mode-line])) &&
		printf "\e[%s;%sH\e[%sG%b%s\e[%sG%s %b%s\e[m%b %d%% (%d,%d) (%s[%s]) (screen: %s) \e[m" \
			   $((bf_d[size-y] - 1 + bf_d[loc-y]))\
			   $((bf_d[size-x] + bf_d[loc-x]))\
			   "${bf_d[loc-x]}"\
			   "${faces[mode-line]}"\
			   "$dashline"\
			   "${bf_d[loc-x]}" \
			   "${bf_d[mode]}"\
			   "${faces[file-name]}"\
			   "$(base-name "${bf_d[file]}")"\
			   "${faces[mode-line]}"\
			   $((100 * bf_d[line] / bf_d[length]))\
			   "${bf_d[line]}"\
			   "${bf_d[column]}"\
			   "${highlight[${bf_d[filetype]}]}"\
			   "${bf_d[filetype]}"\
			   "$current_buffer"
}

# Draw bottomest command line message echo area
function redraw-commandline {
	# clear message if it has been printed before already
	((options[keep-message]==0)) && 
		((clrmsg)) && {
			message=
			clrmsg=0
		} || clrmsg=1
	if ((options[command-line])); then
		printf "\e[%s;%sH\n${faces[minibuffer-prompt]}%*s\r%s\e[m" \
			   $((LINES-1)) 1 $((COLUMNS)) ' ' "$message"
	else
		[ -n "$message" ] &&
			printf "\e[%s;%sH%s" \
				   $((LINES)) 1 "$message"
	fi
}

## handle-mouse
# Handle mouse click
function handle-mouse {
	local -i x y
	#parse mouse stuff somewhatish weirdly
	[ "${k_hex[*]:0:5}" = '1b 5b 3c 36 34' ] && previous-line && return
	[ "${k_hex[*]:0:5}" = '1b 5b 3c 36 35' ] && next-line && return
	[ "${k_hex[*]:0:5}" = '1b 5b 3c 38 30' ] && previous-line 9 && return
	[ "${k_hex[*]:0:5}" = '1b 5b 3c 38 31' ] && next-line 9 && return
	((skipnext==1)) && skipnext=0 && return
	((skipnext==0)) && [ "${k_hex[*]:0:2}" = '1b 5b' ] && {
		mapfile -t -d '' inputarray <<< "${1}"
		inputarray[-1]="${inputarray[-1]%?}"
		[ -z "${inputarray[2]}" ] && skipnext=1
		mapfile -t -d ';' inputarray <<< "${inputarray[1]}"
		inputarray[-1]="${inputarray[-1]%?}"	
		mousemode="${inputarray[0]}"
		x="${inputarray[1]}"
		y="${inputarray[2]::-1}"
		#limitations of movenment
		#TODO:
		[ $y = "${bf_d[loc-y]}" ] && menuline-mouse $x && return #handle menuline
		((x < (bf_d[number-length] + bf_d[loc-x] + 2))) && {
			if [ "$mousemode" = '[<0' ]; then
				bf_d[line]=$(( bf_d[base] + ( (y - bf_d[loc-y]) - toplines) ))
				redraw
			elif [ "$mousemode" = '[<2' ]; then #VERY BAD SOLUTION, TODO: FIX
				clear-screen
				echo 'Enter the index: '
				read -re line
				redraw
			fi
			return
		}
		bf_d[line]=$(( bf_d[base] + ( y - bf_d[loc-y] - 1) ))
		bf_d[column]=$(( x - (bf_d[loc-x] + bf_d[number-length] + 1) ))
		((bf_d[line] > ${#bf_e[@]})) &&
			bf_d[line]=${#bf_e[@]}
		((bf_d[column] > ${#bf_e[bf_d[line]]})) &&
			bf_d[column]=${#bf_e[bf_d[line]]}
		redraw
	}
}

## insert-word
# Insert \$1 to buffer
function insert-word {
	((options[save-states])) && save-state
	local -i rlr
	unset ta
	local ta
	ta=${bf_e[${bf_d[line]}]:0:${bf_d[column]}}
	ta=${ta//[^t]}
	ta=${#ta}
	rlr=$((bf_d[column] + ta / 4 - ta))
	buffer[bf_d[line]]="${buffer[${bf_d[line]}]:0:${rlr}}$1${buffer[${bf_d[line]}]:${rlr}}"
	#add at cursor position - amount of tabs * tab size
	make-render-line
	forward-char "${#1}"
	bf_d[selection]=0
	redraw
	bf_d[modified]=1
}

## input-key Handles input
# Either \$1 raw character input or k_hex array containing hex values of characters is used
function input-key {
	#arg $1 is the pressed key in normal text form
	#k_hex is pressed key in hex array ending with 0
		
	local -i mode_contains=0
	local -n modekeys="keys_${bf_d[mode]}"\
	         key_options="key_options_${bf_d[mode]}"

	# global keys
	((key_options[disable-global])) ||
		for str in "${!keys_global[@]}"
		{
			[ "$str" = "${k_hex[*]}" ] && {
				"${keys_global[$str]}"
				return
			}
		}

	# Execute the 'always' key option
	((${#key_options[@]})) &&
		[ -n "${key_options[always]}" ] && "${key_options[always]}"

	# Loop over current mode keybindings to match current keypress
	for str in "${!modekeys[@]}"
	{
		[ "$str" = "${k_hex[*]}" ] && {
			"${modekeys[$str]}"
			mode_contains=1
		}
	}

	# If mode keybinding doesn't contain current keypress, execute this
	((${#key_options[@]})) &&
		((mode_contains == 0)) &&
		[ -n "${key_options[else]}" ] && {
			[ "${key_options[else]}" = 'insert' ] || {
				"${key_options[else]}" && return
			}
		}

	# Do not continue if mode contains keypress to prevent control chars flooding file
	((mode_contains==1)) && return

	# If mouse is enabled, do whatever the hell that ugly piece of code does
	(("${options[mouse]}"==1)) && {
		handle-mouse "$1"
		return
	}

	# Insert the pressed character
	[[ $1 =~ [[:cntrl:]] ]] && return # If char is control char, return
	insert-word "$1"
}

function init-var {
	((options[log])) && init-log || unset buffer_log # set up log buffer (M-x log)


	log info setting traps...
	trap change-size-screen WINCH ALRM # Attach WINCH and ALRM to redraw the screen
	trap die EXIT HUP USR1 # Attach most exit codes to cleanup and exit
	trap 'k_hex=(3 0); input-key' INT
	trap quit SIGTERM

	format_tab=4

	menuloc_y=0; menuloc_x=0 # menu positions
	log info 'Setting menu-line'
	toplines=${toplines:-0}
	((toplines=toplines + options[menu-line]))

	# this is reverse because the value is added to buffer redrawing size
	log info 'Setting mode-line'
	bottomlines=${bottomlines:-0}
	((options[mode-line]==0)) && ((bottomlines--))
	log info 'Setting command-line'
	((options[command-line]==0)) && ((bottomlines--))
	((bottomlines+=2))
	
	log-echo "toplines $toplines"
	log-echo "bottomlines $bottomlines"
	
	log info 'Setting reset'
	reset='\e[0;0m'
	log info 'Setting charmap'
	charmap=(
		#[0] is reserved for any unmapped char
		[	]='t' # tab
		[ ]='s' # space
	)
	if ((options[esc-to-meta])); then
		esc_timeout=123456789 # a very big number
	else
		esc_timeout=0.01
	fi
	log info 'Setting nlchar'
	nlchar='\n'
	printf '\e[?1049h'
	log info 'Setting mouse'
	((options[mouse])) && echo -ne "\e[?1000;1006;1015h" #enable mouse tracking
}

## main Main keyboard loop
function main
	while :; do
		local -a k=()
		local -i i=1
		k_hex=() # Also convert the input sequence into hex for way easier handling
		# Check for ready input
		read -rsN1 k[0] && {
			k_hex[0]="$(printf "%x\n" "'${k[0]}")"

			# Hack to try preventing arrow codes being split into multiple and inserting garbage to buffer
			[ "${k_hex[0]}" = '1b' ] && {
				read -rsN1 -t "${esc_timeout}" k[1]
				k_hex[1]="$(printf "%x\n" "'${k[1]}")"
				[ "${k_hex[1]}" = '5b' ] && {
					read -rsN1 k[2]
					k_hex[2]="$(printf "%x\n" "'${k[2]}")"
					case "${k_hex[2]}" in
						'41'|'42'|'43'|'44')
							k_hex[3]='0'
							input-key "${k[@]}"
							continue
					esac
					i=2
				}
				((i++))
			}
			# Multibyte hack
			while read -rsN1 -t0.0001 k[$i]; do
				k_hex[$i]="$(printf "%x\n" "'${k[$i]}")"
				((i++))
			done
			k_hex[$i]='0'
			input-key "${k[@]}" # Handle keypress event
		}
	done	

### BUFFERMAKER END

## Ebashs
#		Emacs-like editor written in pure Bash
#		Had been tested properly only on Bash 5.2, and will propably be broken on 4.x versions and definitelly on 3 and older.

function load-default-config-ebashs {
	## Configuration
	#		The magic :: function
	#			:: sets value to option depending on current context:
	#				set-options → define-options() → ass. array options
	#				global-set → global-set-key → define-key global → as. ar. keys_global
	#				add-mode → local-set-key → define-key <keys> → a. a. keys_<keys>
	#					mode-options → local-set-mode-option → define-mode-option → a. a. key_options_<keys>
	#				set-alias → add-alias → a. a. alias
	#				add-menu → local-set-menu → define-menu <menu> → menu_<menu>_0 & menu_<menu>_1
	#				set-highlight → add-highlight → a. a. highlight
					  
	set-options
		:: mouse 0
		:: todonote 1
		:: menu-line 1
		:: mode-line 1
		:: command-line 1 # note that disabling this means that any message will instead be draw on top of buffer
		:: line-number-mode 1
		:: empty-line-char '~'
		:: tabchar '│   '
		:: file-prompt 'Path: '
		:: command-prompt 'M-x '
		:: cancelhex '18 0'
		:: default_mode 'edit'
		:: keep-message 0
		:: help-message "Ebashs $version"
		:: dired-message 'Pick a file'
		:: log 0
		:: log-functions 0
		:: tty-linuxfb 1 # enable truecolor support for framebuffer
		:: full-redraw 0 # redraws whole buffer, can fix artifacting in linuxfb at cost of performance
		:: welcome-buffer 1 # show welcome message instead of scratch
		:: esc-to-meta 1
		
	## Key bindings configuration
	#		A keybinding is defined via either
	#		global-set; :: ... ... or add-mode <mode>; :: ... ...
	#		:: <key> <command>
	#			<key> is defined either via
	#				Hexadecimal format (with ' 0' added as suffix).
	#				Name of key like '[<key>]'
	#				Emacsy "$(kbd <key> )" (<key> being something like C-s M-e ...)
	#			The name of key and $(kbd) get translated into hex. format on startup.
	#
	#			mode-options sets magic :: to defining mode options
	#			:: option value

	global-set
		:: "$(kbd C-x)" 'prefix'
		:: "$(kbd M-x)" 'execute-extended-command'
		:: '[f10]' 'menu-top_menu'
		:: "$(kbd C-g)" 'mode-back'
		:: '[up]' 'previous-line'
		:: '[down]' 'next-line'
		:: '[right]' 'forward-char'
		:: '[left]' 'backward-char'
		:: '[next]' 'scroll-down'
		:: '[prior]' 'scroll-up'
		:: "$(kbd C-a)" 'move-beginning-of-line'
		:: "$(kbd C-e)" 'move-end-of-line'
		:: "$(kbd C-p)" 'previous-line'
		:: "$(kbd C-n)" 'next-line'
		:: "$(kbd C-f)" 'forward-char'
		:: "$(kbd M-f)" 'forward-word'
		:: "$(kbd C-b)" 'backward-char'
		:: "$(kbd M-b)" 'backward-word'
		:: "$(kbd M-v)" 'scroll-down'
		:: "$(kbd C-v)" 'scroll-up'

	add-mode edit
		:: '1b 5b 31 3b 32 41 0' select-previous
		:: '1b 5b 31 3b 32 42 0' select-next
		:: '1b 5b 31 3b 32 43 0' select-forward
		:: '1b 5b 31 3b 32 44 0' select-backward
		:: '1b 20 0' set-mark-command # in gnu emacs this is C-SPC but i cant get that to be detected in bash so M-SPC will suffice
		:: '20 0' insert-space
		:: "$(kbd C-h)" prefix-help
		:: 'RET' newline
		:: "$(kbd C-l)" newline
		:: "$(kbd M-d)" duplicate-line
		:: "$(kbd C-t)" execute
		:: "$(kbd C-d)" delete-line
		:: 'DEL' backspace
		:: '[deletechar]' delete
		:: "$(kbd M-g)" menu-key
		:: '1b 5b 48 0' move-beginning-of-line
		:: "$(kbd C-i)" indent-for-tab-command
		:: '1b 5b 46 0' move-end-of-line
		mode-options
			:: else 'insert'

	add-mode dired
		:: RET 'dired-select'
		:: "$(kbd h)" 'toggle_hidden'
	
	add-mode view
		:: RET 'quit-view'

	add-mode doc
		:: RET 'doc-select'
		:: "$(kbd C-c)" 'quit-doc'
	
	add-mode list_buffers
		:: RET 'buffer-select'
		mode-options
			:: else 'true'
	
	add-mode prefix
		:: "$(kbd C-c)" 'quit'
		:: "$(kbd C-s)" 'write_buffer'
		:: "$(kbd C-f)" 'find-file'
		:: "$(kbd C-b)" 'list-buffers'
		:: "$(kbd b)" 'switch-to-buffer'
		:: "$(kbd 0)" 'delete-buffer'
		:: "$(kbd u)" 'undo'
		mode-options
			:: always 'mode-back'
			:: disable-global 1
	
	add-mode prefix_help
		:: "$(kbd C-g)" 'mode-back'
		:: "$(kbd C-a)" 'about'
		:: "$(kbd r)" 'manual'
		:: "$(kbd f)" 'describe-function'
		:: "$(kbd C-f)" 'describe'
		mode-options
			:: disable-global 1

	add-mode menu
		:: '[up]' 'menuup'
		:: '[down]' 'menudown'
		:: 'RET' 'menuselect'
		mode-options
			:: else 'menuleave'
			:: disable-global 1

	add-mode format
		:: '[left]' format-left
		:: '[up]' format-up
		:: '[right]' format-right
		:: '[down]' format-down
		:: 'RET' link-enter
		:: "$(kbd C-c)" quit-view
		:: '[next]' 'scroll-down'
		:: '[prior]' 'scroll-up'
		:: "$(kbd C-a)" 'move-beginning-of-line'
		:: "$(kbd C-e)" 'move-end-of-line'
		:: "$(kbd C-p)" 'previous-line'
		:: "$(kbd C-n)" 'next-line'
		:: "$(kbd C-f)" 'forward-char'
		:: "$(kbd M-f)" 'forward-word'
		:: "$(kbd C-b)" 'backward-char'
		:: "$(kbd M-b)" 'backward-word'
		:: "$(kbd M-v)" 'scroll-down'
		:: "$(kbd C-v)" 'scroll-up'
		:: "$(kbd C-x)" 'prefix'
		:: "$(kbd M-x)" 'execute-extended-command'
		:: '[f10]' 'menu-top_menu'
		:: "$(kbd C-g)" 'mode-back'
		mode-options
			:: else :
			:: disable-global 1

	add-mode welcome
		:: 'RET' link-enter
		:: "$(kbd f)" find-file
		:: "$(kbd b)" dired
		:: "$(kbd m)" manual
		:: "$(kbd d)" view-page
		:: "$(kbd a)" about
		:: "$(kbd i)" inputcodes
		:: "$(kbd c)" list-faces-display
		:: "$(kbd l)" view-log
		:: "$(kbd C-c)" quit-view
		mode-options
			:: else :
		
	## Faces
	#		Defined in escape codes
	#		Helper functions:
	#			:weight
	#				normal
	#				bold
	#			:slant
	#				normal
	#				italic
	#			:background & :foreground
	#				either hex. colour, colour name, or c<index> for 256 indexed colours
	#		See extensions/gruvboxdark for another example
edit_faces=(
		# syntax highlighting
		sh-quoted-exec "$(:foreground light-yellow)"
		font-lock-variable-string-face "$(:foreground cyan)"
		font-lock-comment-face "$(:weight dim)"
		font-lock-variable-name-face "$(:foreground light-cyan)"
		font-lock-argument-face "$(:foreground light-yellow)"
		font-lock-flow-face "$(:foreground ligth-yellow)"
		font-lock-pipe-face "$(:weight bold :foreground light-blue)"
		font-lock-bracket-face "$(:weight bold :foreground light-gray)"
		font-lock-constant-face "$(:foreground light-green)"
		font-lock-string-face "$(:foreground green)"
		font-lock-assign-face "$(:foreground light-blue)"
		font-lock-function-name-face "$(:weight bold :foreground light-cyan)"
		font-lock-keyword-face "$(:foreground light-red)"
		font-lock-util-face "$(:foreground light-magenta)"
		font-lock-declare-face "$(:foreground red)"
	)
	load-theme edit_faces

	## Aliases
	#		List of aliases for M-x.
	set-alias
		:: set-buffer-file 'find-file'
		:: read-file 'read-buffer'
		:: write-file 'write-buffer'
		:: force-quit 'die'
		:: menul 'menu-top_menu'
		:: menu-file 'menu-file'
		:: input 'inputcodes'
		:: log 'view-log'

	## Menus
	#		Defined via ordered pseudo-associative double-arrays
	#			All menu items calling 'menu-top' get applied the 'menu-back' face
	#
	#		Menu top is the top menuline & f10 menu	
	#		Menu dired is the top menuline in dired buffers	
	add-menu top
		:: File menu-file
		:: Keys menu-key
		:: Help menu-help
		:: Debug menu-debug
		:: Redraw refresh

	add-menu top_menu
		:: 'File   ' menu-file
		:: 'Keys   ' menu-key
		:: 'Help   ' menu-help
		:: 'Debug  ' menu-debug
		:: 'Redraw ' refresh

	add-menu file
		:: '        BACK        ' menu-top_menu
		:: 'Quit        C-x C-c ' quit
		:: 'Visit file  C-x C-f ' find-file
		:: 'Execute         C-t ' execute
		:: 'Save        C-x C-s ' write-buffer
		:: 'Dired               ' dired
	add-menu help
		:: '        BACK        ' menu-top
		:: 'Keybinding          ' menu-key
		:: 'About               ' about

	add-menu key
	    :: '        BACK        ' menu-top_menu
		:: 'Exit        C-x C-c ' quit
		:: 'New Line    C-l | ⏎ ' newline
		:: 'Visit file  C-x C-f ' find-file
		:: 'Save file   C-x C-s ' write-buffer
		:: 'Delete Line     C-d ' delete-line
		:: 'Prev Line       C-p ' previous-line
		:: 'Next Line       C-n ' next-line
		:: 'Prev Page       C-y ' scroll-down
		:: 'Next Page       C-v ' scroll-up
		:: 'Execute         C-t ' execute
		:: 'Shell           C-s ' shell
		:: 'Force exist     M-q ' die
    add-menu debug
		:: '   BACK   ' menu-top_menu
		:: 'clear     ' clear-screen
		:: 'refresh   ' refresh
		:: 'backspace ' backspace
		:: 'right     ' forward-char
		:: 'left      ' backward-char
		:: 'inputcodes' inputcodes
		:: 'faces     ' list-faces-display

	## Syntax highlighting
	set-highlight
		:: 'shell' bash ksh dash sh mksh zsh ash oksh i\*bash 'busybox sh'
		:: 'ebashs' ebashs
		:: 'config' conf
		:: 'execline' execlineb
		:: 'format-edit' format
		:: 'dired' i\*dired
		:: 'unknown' unknown

	add-menu dired
		:: 'toggle hidden (h)' "toggle_hidden"

	add-menu dialog
		:: quit 'quit-view'

	add-menu welcome
		:: about 'about'
		:: manual 'manual'
		:: docs 'view-page'
		:: quit 'quit-view'
	
	# Navigation used in some inbuild buffers
	#format_nav="<a> about : <f> link About </f> </a> "
	#format_nav+="<a> manual : <f> link Manual </f> </a> "
	#format_nav+="<a> view-page : <f> link Documentation </f> </a>"
	format_nav="<o> id: about select: about right: obj manual text: <f> link About </f> </o> "
	format_nav+="<o> id: manual select: manual left: obj about right: obj doc text: <f> link Manual </f> </o> "
	format_nav+="<o> id: doc select: view-page left: obj manual right: next-line text: <f> link Documentation </f> </o>"
}

## Documentation
function load-doc {
	mapfile -t -O 1 top_doc <<'EOF'
<h> Documentation </h>

<tab> <link> goto doc_control : Controls </link>
<tab> <link> describe : Functions </link>
<tab> <link> goto doc_faces : Face setting </link>
EOF

	mapfile -t -O 1 doc_control <<'EOF'
<link> goto top_doc : Back </link>
<h> [ Controls ] </h>

Automatically generated list of keybindings. Click on function name to view it's documentation.
Note that currently only key set via $(kbd C-char or M-char) will show up.
EOF
	for mode in "${modes[@]}"; do
		doc_control+=(
			'</i>'
			"<h> ${mode} </h>"
			'<i-tab>'
		)
		local -n moderef="$mode"
		for ch in\
			C-a C-b C-c C-d C-e C-f C-g C-h C-i C-j C-k C-l C-m C-n C-o C-p C-q C-r C-s C-t C-u C-v C-w C-x C-y C-z :\
			M-a M-b M-c M-d M-e M-f M-g M-h M-i M-j M-k M-l M-m M-n M-o M-p M-q M-r M-s M-t M-u M-v M-w M-x M-y M-z	
		do
			[ "$ch" = ':' ] && {
				doc_control+=('')
				continue
			}
			key=${moderef[$(kbd ${ch})]}
			[ -z "$key" ] && continue
			doc_control+=(
				"<f> highlight ${ch} </f> <a> doc-select $key : <f> font-lock-function-name-face $key </f> </a>"
			)
		done
	done
	doc_control+=(
		'</i>'
	)

	mapfile -t -O 1 doc_faces <<'EOF'
<link> goto top_doc : Back </link>
<h> [ Face configuration ] </h>

Faces are set via theme arrays. Theme array consists pairs of name and value.
The first is name, second is value, then again first... second... ... ... . The
Theme array has to be then loaded via <link> doc-select load-theme : load-theme </link> function.

Faces configured via escape codes, for example:
<-> <f> blue perfectblue '\e[44m' </f>
Produces blue colored face

But <[> title Ebashs is civilised and so has nicer settings for this:
<-> <f> blue perfecterblue "$(:background blue)" </f>
or one of 256 colors:
<-> <f> blue blue256 "$(:background c18)" </f>
or if you use nice terminal even full 24 bit hex. color:
<-> <f> blue TRUEBLUE "$(:background " <-f> ansi-color-blue #0000ff </f-> ")" </f>

The face-setting functions can be combined:
<-> <f> red red <-f> cyan cyan </f> </f> <f> cyan "$(:background <f> ansi-color-cyan c44 </f> </f> <f> red :foreground <f> ansi-color-red c196 </f-> )" </f>

<-> <-> see <link> doc-select :foreground : :foreground </link> <link> doc-select :background : :background </link> <link> doc-select setface : setface </link>

The boldness and dimness can be set via <a> doc-select :weight : <f> link :weight </f> </a> function.
The inverseness can be set via <a> doc-select :mode : <f> link :mode </f> </a> function.
The slant can be set via <a> doc-select :slant : <f> link :slant </f> </a> function.

<h> Example </h>

To change faces used on this page

<-> <f> title misleading_theme </f-> =( <i> 8
<[> title title "$(:weight bold :background "#ffffff")"
<[> link link "$(:weight bold :background light-yellow)"
<[> ansi-color-blue ansi-color-blue "$(:background cyan)"
<[> ansi-color-cyan ansi-color-cyan "$(:background green)"
<[> blue blue "$(:foreground cyan)"
<[> red red "$(:foreground yellow)"
<[> font-lock-keyword-face font-lock-keyword-face ''
<[> cyan cyan "$(:foreground green)" </i>
<-> )
<-> <f> font-lock-keyword-face load-theme </f> <f> title misleading-theme </f>
EOF
}

@@ execute-extended-command
:: 'Handles M-x command prompt & execution'
function execute-extended-command {
	read-command "${options[command-prompt]}" readin || return 1
	for lcmd in "${!alias[@]}"; {
		[ "$readin" = "$lcmd" ] && {
			${alias[$lcmd]}
			return
		}
	}
	$readin			
	((noredraw)) && noredraw=0 || redraw
}

function prefix { switch-mode prefix; }
function prefix-help { switch-mode prefix_help; }

@@ save Saves current buffer references data as '$1'
function save {
	local name="$1"
	local -n savedcurrent_buffer="current_buffer${name}"
	savedcurrent_buffer="$current_buffer"
}

@@ restore Restores '$1' buffer references data to current
function restore {
	local name="$1"
	local -n savedcurrent_buffer="current_buffer${name}"
	set-buffer "${savedcurrent_buffer}"
}

@@ set-syntax
:: Picks syntax highlighting function for current filetype
function set-syntax
	if [ -n "${highlight[*]}" ] && bf_d[syntax]="syntax-${highlight[unknown]}"
	then
		for syntax_setting in "${!highlight[@]}"; {
			[ "$syntax_setting" = "${bf_d[filetype]}" ] && {
				bf_d[syntax]="syntax-${highlight[$syntax_setting]}"
			}
		}
	else
		log warn 'no highlight array... using unknown'
	fi

@@ syntax-shell
:: Syntax function for shell
:: Used faces:
	:+ '* sh-quoted-exec'
	:: '* font-lock-declare-face'
	:: '* font-lock-variable-string-face'
	:: '* font-lock-comment-face & sets comment to 1 for syntax-word function'
	:: '* font-lock-variable-name-face'
	:: '* font-lock-argument-face'
	:: '* font-lock-function-name-face'
	:: '* font-lock-flow-face'
	:: '* font-lock-pipe-face'
	:: '* font-lock-bracket-face'
	:: '* font-lock-constant-face'
	:: '* font-lock-string-face'
	:: '* font-lock-assign-face'
	:: '* font-lock-keyword-face'
	:: '* font-lock-default-face'
function syntax-shell
	case "${word}" in
		'$('*|'"$('*) set-face sh-quoted-exec;;
		*'=()'|'declare'|'local'|'typeset') set-face font-lock-declare-face;;
		'"$'*) set-face font-lock-variable-string-face;;
		'#'*) set-face font-lock-comment-face && comment=1;;
		'$'*) set-face font-lock-variable-name-face;;
		'-'*) set-face font-lock-argument-face;;
		*'()') set-face font-lock-function-name-face;;
		'||'|'&&'|';'|'&') set-face font-lock-flow-face;;
		'>'|'<'|'|'|'>>'|'<<'|'<<<') set-face font-lock-pipe-face;;
		'('|')'|'{'|'}'|'[['|']]'|'['|']') set-face font-lock-bracket-face;;
		'function') set-face font-lock-function-name-face;;
		*"'"*) set-face font-lock-constant-face;;
		*'"'*) set-face font-lock-string-face;;
		*'='*) set-face font-lock-assign-face;;
		'echo'|'return'|'case'|'esac'|'for'|'while'|'do'|'done'|'if'|'elif'|\
		'else'|'printf'|'fi'|'continue'|'exit'|'bind'|'then'|'break'|'read'|\
		'let'|'shopt'|'trap'|'set'|'eval'\
			) set-face font-lock-keyword-face;;
		*) set-face default;;
	esac

@@ syntax-ebashs
:: Syntax function for shell
:: Used faces:
	:+ '* sh-quoted-exec'
	:: '* font-lock-declare-face'
	:: '* font-lock-variable-string-face'
	:: '* font-lock-comment-face & sets comment to 1 for syntax-word function'
	:: '* font-lock-variable-name-face'
	:: '* font-lock-argument-face'
	:: '* font-lock-function-name-face'
	:: '* font-lock-flow-face'
	:: '* font-lock-pipe-face'
	:: '* font-lock-bracket-face'
	:: '* font-lock-constant-face'
	:: '* font-lock-string-face'
	:: '* font-lock-assign-face'
	:: '* font-lock-keyword-face'
	:: '* font-lock-default-face'
function syntax-ebashs
	case "${word}" in
		'$('*|'"$('*) set-face sh-quoted-exec;;
		*'=()'|'declare'|'local'|'typeset') set-face font-lock-declare-face;;
		'"$'*) set-face font-lock-variable-string-face;;
		'#'*) set-face font-lock-comment-face && comment=1;;
		'$'*|'@') set-face font-lock-variable-name-face;;
		'-'*|'::') set-face font-lock-argument-face;;
		*'()') set-face font-lock-function-name-face;;
		'||'|'&&'|';'|'&') set-face font-lock-flow-face;;
		'>'|'<'|'|'|'>>'|'<<'|'<<<') set-face font-lock-pipe-face;;
		'('|')'|'{'|'}'|'[['|']]'|'['|']') set-face font-lock-bracket-face;;
		'new'|'template'|'@def'|'@fn'|'@:') set-face font-lock-function-name-face;;
		*"'"*) set-face font-lock-constant-face;;
		*'"'*) set-face font-lock-string-face;;
		*'='*|'function') set-face font-lock-assign-face;;
		'echo'|'return'|'case'|'esac'|'for'|'while'|'do'|'done'|'if'|'elif'|\
		'else'|'printf'|'fi'|'continue'|'exit'|'bind'|'then'|'break'|'read'|\
		'let'|'shopt'|'trap'|'set'|'eval'\
			) set-face font-lock-keyword-face;;
		'set-options'|'global-set'|'define-key'|'local-set-key'|'add-mode'|'mode-options'|\
		'load-theme'|'set-alias'|'add-menu'|'@ifs'|'doc'|'_'|'__'|'copy-array'|\
		':foreground'|':background'|':mode'|'weight'|':slant'|'kbd'|'add-highlight'\
			) set-face font-lock-keyword-face;;
		*) set-face default;;
	esac

@@ syntax-execline
:: Syntax function for execline
function syntax-execline
	case "${word}" in
		'"$'*) set-face font-lock-variable-string-face;;
		'#'*) set-face font-lock-comment-face && comment=1;;
		'$'*) set-face font-lock-variable-name-face;;
		'-'*) set-face font-lock-argument-face;;
		'{'|'}') set-face font-lock-bracket-face;;
		*'"'*) set-face font-lock-string-face;;
		'execlineb'|'execline-cd'|'posix-cd'|'cd'|'execline-umask'|'posix-umask'|'umask'|\
		'emptyenv'|'envfile'|'export'|'unexport'|'fdclose'|'fdblock'|'fdmove'|'fdswap'|'fdreserve'|\
		'redirfd'|'piperw'|'heredoc'|'wait'|'getcwd'|'getpid'|'exec'|'tryexec'|'exit'|'trap'|'withstdinas'|\
		'foreground'|'background'|'case'|'if'|'ifelse'|'ifte'|'ifthenelse'|'backtick'|'pipeline'|'runblock'|\
		'define'|'importas'|'elglob'|'elgetpositionals'|'multidefine'|'multisubstitute'|\
		'fox'|'forstdin'|'forbacktickx'|'loopwhilex'|\
		'elgetopt'|'shift'|'dollarat'|\
		'eltest'|'homeof'|\
		'execline') set-face font-lock-keyword-face;;
		's6-basename'|'s6-cat'|'s6-chmod'|'s6-chown'|'s6-clock'|'s6-cut'|'s6-dirname'|'s6-dumpenv'|\
		's6-echo'|'s6-env'|'s6-expr'|'s6-false'|'s6-format-filter'|'s6-grep'|'s6-head'|'s6-hiercopy'|\
		's6-linkname'|'s6-ln'|'s6-ls'|'s6-maximumtime'|'s6-mkdir'|'s6-mkfifo'|'s6-nice'|'s6-nuke'|\
		's6-pause'|'s6-printenv'|'s6-quote-filter'|'s6-quote'|'s6-rename'|'s6-rmrf'|'s6-seq'|\
		's6-sleep'|'s6-sort'|'s6-sync'|'s6-tai64ndiff'|'s6-tail'|'s6-touch'|'s6-true'|'s6-uniquename'|\
		's6-unquote-filter'|'s6-unquote'|'s6-update-symlinks'|'seekablepipe'|\
		's6-portable-utils') set-face font-lock-util-face;;
		'rngseed'|'s6-chroot'|'s6-freeramdisk'|'s6-hostname'|'s6-logwatch'|'s6-mount'|\
		's6-pivotchroot'|'s6-ps'|'s6-swapoff'|'s6-swapon'|'s6-umount') set-face font-lock-util-face;;
		*) set-face default;;
	esac

@@ syntax-format-edit
:: Syntax function for ebashs\'s formatter
function syntax-format-edit
	case "${word}" in
		'<f>'|'<-f>'|'</f>'|'</f->'|'<u>'|'</u>'|'<tab>'|'<i>'|'</i>'|'<i-tab>'|'<h>'|'<s>'\
			)set-face font-lock-keyword-face;;
		*) set-face default;;
	esac
@@ syntax-unknown Default syntax function
:: Sets everything to default face
@fn syntax-unknown 'set-face default'

@@ syntax-list-buffers
:: Syntax function for list-buffers
function syntax-list-buffers {
	((syntaxline==2)) && {
		face hint "$word"
		return
	}
	local -n cbf_d="${word}_bf_d"
	face link "$(printf '%*s' -6 "$word")"
	face file-name "$(printf '%*s' -16 "${cbf_d[file]}")"
	face default "$(printf '%*s' -10 "${cbf_d[mode]}")"
	face font-lock-comment-face "${cbf_d[modified]} "
}

@@ syntax-dired
:: Highlighting for dired buffers
:+     '* Directories → link'
::     '* Files → default'
function syntax-dired {
	[ -d "$word" ] && set-face link
	[ -f "$word" ] && set-face default
}

@@ syntax-config
:: Basic syntax function for config files
:: Used faces:
:+     '* default'
::     '* font-lock-comment-face & sets comment to 1 for syntax-word function'	
function syntax-config
	case "${word}" in
		'#'*) set-face font-lock-comment-face && comment=1;;
		*) set-face default;;
	esac

@@ filetype
:: Detect type of file '$1':					
:+     "* If file doesn't exist → unknown"
::     "* If is COMMIT_EDITMSG → conf"
::     "* If is ebashs → ebashs"
::     "* Extension →"
::     "* Shebang →"
::     "* Special shebang #@ →"
::     "* unknown →"
function filetype {
	[ ! -f "$1" ] && {
		echo unknown
		return
	}
	#very ugly, TODO: redo this
	local filename shebang extension
	local -a filenamesplit shebangsplit
	[ $# = 0 ] && return
	[ "${1:0:1}" = '.' ] || {
		IFS='.'
		filename="${1%/}"
		filename="${filename##*/}"
		[ "$filename" = 'COMMIT_EDITMSG' ] && echo conf && return
		[ "$filename" = 'ebashs' ] && echo ebashs && return
		filenamesplit=($filename)
		extension="${filenamesplit[-1]}"
		[ "${#filenamesplit[@]}" -gt 1 ] && echo "$extension" && return
	}
	mapfile -n 1 file_data < "$1"
	shebang="$(echo -n "${file_data[@]}")"
	case "${shebang:0:2}" in
		'#!')
			shebang="${shebang%/}"
			IFS=' '
			shebangsplit=("${shebang##*/}")
			local shebangss=(${shebangsplit[-1]})
			case "${shebangss[0]}" in
				env)
					printf '%s\n' "${shebangss[1]}";;
				*)
					printf '%s\n' "${shebangsplit[-1]}";;
			esac
			;;
		'! ')
			mapfile -d ' ' -t split <<< "${shebang}"
			printf '%s\n' "${split[1]}"
			;;
		'##')
			mapfile -d ' ' -t split <<< "${shebang}"
			printf '%s\n' "${split[1]}"
			;;
		*) echo unknown
	esac
	@ifs
}

@@ find-file
:: Asks for file and opens it
function find-file {
	printf '\e[%s;0H' $((bf_d[size-y] + bf_d[loc-y]))
	printf '\e[?25h'
	bind 'set disable-completion off' 2>/dev/null # Enable completion
	read -re -p "${options[file-prompt]}" command && {
		read-buffer "$command"
		[ -n "$bckmode" ] && bf_d[mode]="$bckmode" || bf_d[mode]=edit
		redraw
	}
	bind 'set disable-completion on' 2>/dev/null
}

@@ view-format
:: Open file as formated document
function view-format {
	save openfile
	printf '\e[%s;0H' $((bf_d[size-y] + bf_d[loc-y]))
	printf '\e[?25h'
	bind 'set disable-completion off' 2>/dev/null # Enable completion
	read -re -p "${options[file-prompt]}" command && {
		read-buffer "$command"
		bf_d[syntax]=syntax-format
		bf_d[syntax-exec]=1
		[ -n "$bckmode" ] && bf_d[mode]="$bckmode" || bf_d[mode]=view
		redraw
	}
	bind 'set disable-completion on' 2>/dev/null
}

@@ insert-debug-hex
:: Adds hex code of keypress into buffer
function insert-debug-hex {
	buffer+=(
		"${k_hex[*]}"
	)
	next-line
	make-render-line
	redraw
}

@@ switch-to-buffer
:: Interactive wrapper for set-buffer
function switch-to-buffer {
	redraw
	read-command "Switch to buffer: " readin
	set-buffer "$readin"
	redraw
}

@@ list-buffers
:: Displays currently active buffers
function list-buffers {
	save openfile
	set-buffer list_buffers
	declare -Ag "${current_buffer}_bf_d"
	focus set-buffer
		:: line 1
		:: base 1
		:: column 0
		:: modified 0
		:: mode 'list_buffers'
		:: info 'Currently open buffers'
		:: filetype 'i*buffer-list'
		:: file '*Buffer List*'
		:: syntax syntax-list-buffers
		:: syntax-exec 1
		:: menuline 'about'
	[auto]
	buffer=(
		''
		'ID    FILENAME        MODE      MODIFIED'
	)
	bf_s=('')
	append-array buffers_l buffer
	redraw
	}
	
@@ buffer-select
:: Is ran on RET inside list_buffers buffer
function buffer-select {
	((bf_d[line]==1)) && return
	set-buffer "${buffer[bf_d[line]]}"
	[ "${bf_d[mode]}" = 'prefix' ] && bf_d[mode]="$bckmode"
	redraw
}

add-mode debuginput
	local-set-key "$(kbd C-x)" 'quit-view'
	local-set-mode-option else 'insert-debug-hex'
	local-set-mode-option disable-global 1
add-menu debuginput
	local-set-key 'quit-debuginput'

@@ inputcodes
:: Opens debug input buffer
function inputcodes {
	save openfile
	declare-new-buffer
		:: mode 'debuginput'
		:: info 'C-x (18 0) to close'
		:: filetype 'i*term'
		:: file '*debuginput*'
		:: modified 0
		:: syntax syntax-unknown
		:: menuline 'debuginput'
		[auto]
		
	buffer=(
		''
		'[ KEY DEBUGGER ]'
		''
		"Press any key to see Ebashs's native hex. representation of it."
		"See C-h f define-key & C-h f kbd for fancier key settings"
		''
	)
	bf_d[line]=7
	redraw
}

@@ read-buffer
:: Reads file \$1 into new buffer
function read-buffer {
	log info "reading $* ..."
	declare-new-buffer
		:: mode "${options[default_mode]}"
		:: info "${options[help-message]}"
		:: filetype "$(filetype "$1")"
		:: file "$1"
		:: menuline 'top'
		:: current_state 0
	[auto]
	((options[view])) &&	
		[ "${bf_d[filetype]}" = 'format' ] && {
			:: mode format
			:: syntax syntax-format
			:: syntax-exec 1
		}
		
	[ -f "${bf_d[file]}" ] && mapfile -t -O 1 "${current_buffer}_buffer" <"${bf_d[file]}" # Read file into an array
	
	
	# Ensure that something was actually read into the file
	[[ -n "${buffer[*]}" ]] && {
		message="Read ${#buffer[@]} lines from '${bf_d[file]}'"
	} || {
		message="'${bf_d[file]}' is empty"
	}
	bf_d[line]=1 # Indicate that we have a buffer loaded
	bf_d[modified]=0
}

@@ toggle_hidden
:: Toggles hidden files in dired buffer
function toggle_hidden {
	((hidden==0)) && hidden=1 || hidden=0
	dired
}

@@ dired
:: Open file manager in current working directory
function dired {
	declare-new-buffer
		:: info 'Dired'
		:: mode 'dired'
		:: filetype 'i*dired'
		:: file '*dired*'
		:: menuline 'dired'
		[auto]
		
	mapfile -t -O 1 buffer <<< "$(list-directory)"
	make-render
	if [[ "${buffer[1]}" ]]; then # Ensure that something was actually read into the file
		bf_d+=(
			[line]=1
			[info]="$PWD"
		)
	else
		bf_d[info]="error: empty"
	fi
	redraw
}

@@ dired-select
:: Select a item in dired buffer
	:+     '* If it is a directory cd into it and open new dired'
	::     '* If it is a file open it via read-buffer function'
function dired-select
	if [ -d "${buffer[bf_d[line]]}" ]; then
		cd "${buffer[bf_d[line]]}"
		dired
	else
		read-buffer "${buffer[bf_d[line]]}" || exit 1
		redraw
	fi

@@ init-log
:: Initializes M-x view-log buffer
function init-log {
	log=1
	declare -Ag "log_bf_d"
	declare -ng bufferlog="log_buffer"
	declare -ng bf_d="log_bf_d"
	focus set-buffer
		:: base 1
		:: column 0
		:: info 'LOG'
		:: mode 'view'
		:: help-message 'LOG'
		:: filetype 'i*view'
		:: file '*log*'
		:: modified 0
		:: syntax syntax-format
		:: syntax-exec 1
		:: menuline 'menulog'
	add-menu
		:: 'quit' 'quit-view'

	size-full

	bufferlog+=(
		''
		"<f> title Ebashs version $version </f>"
		"<tab> <f> highlight [ LOG START ] </f>"
		''
		'<f> title System info: </f> <i-tab>'
		"Bash version:  ${BASH_VERSION}"
		"System:        ${OSTYPE}"
		"Terminal type: ${TERM}"
		"Locale:        ${LANG} </i>" 
		''
		'<f> title Loaded extensions: </f>'
	)
	for e in "${extensions[@]}"; {
		local -n ext_d="${e}_ext_d"
		bufferlog+=("    $e - ${ext_d[version]}")
	}
	bufferlog+=(
		''
		'<f> hint level time function message </f>'
	)
	lasttime="$(current-time '%s')"
}

@@ view-log
:: Opens log buffer
function view-log {
	((log)) || {
		message='Error: log is not initialised'
		return
	}
	save openfile
	set-buffer log
	copy-array buffer bf_e
	clear-screen
	redraw
}

@@ buffer-dialog
:: Helper functions for creating simple popup buffers
function buffer-dialog {
	save openfile
	declare-new-buffer
		:: line 1
		:: info "$1"
		:: mode view
		:: filetype 'i*view'
		:: file "$2"
		:: modified 0
		:: syntax syntax-unknown
	size-full
}

@@ buffer-dialog-draw
:: Draws buffer created by buffer-dialog
# NOTE: To be removed
function buffer-dialog-draw {
	clear-screen
	redraw
}
	
@@ about
:: Shows about information	
function about {
	save openfile
	declare-new-buffer
		:: line 1
		:: info "About"
		:: mode format
		:: filetype 'i*format'
		:: file "*about*"
		:: modified 0
		:: syntax syntax-format
		:: syntax-exec 1
	size-full
	mapfile -t -O 1 buffer <<EOF
$format_nav

<h> Ebashs $ebashs_version </h>
Buffermaker $buffermaker_version

Copyright(č)ˇ 2022-2024 <f> title Netkv </f-> .
( <-f> title bed </f-> : Copyright(č)ˇ 2020 <f> title Comfies </f-> .)

This is Ebashs, one component of the Bash/Bash operating system.

An editor written in pure bash via nonsense sphagetti code trying copying emacs.

Repo <s> 19 <f> link https://github.com/aeknt/spis </f>
<s> 24 Ebashs comes with ABSOLUTELY NO WARRANTY




Based on <s> 15 <f> link https://github.com/comfies/bed </f>


<tab> <f> hint For more information about usage of Ebashs, press <f> light-gray C-h C-r </f> to view </f> <link> manual : manual </link>

<i> 5
<f> dr                          .............. </f>
<f> lr                       @***%@@@@@@@@@@@@... </f>
<f> dr                ** .*@@@@@@@@@@@@@@@@@@@@@.. </f>
<f> dy                .       @@&....,,#@@@@@@@@ </f>
<f> ly                 ....,@@@@@@@@@@@@@@@@@@ </f>
<f> dy             /@@@@@@@@@@@@@@@@@@@@@@. </f>
<f> dg           @@@@@@@,,...@@@&.. </f>
<f> lg         .@@@@@@@@@@@,,@@@&. </f>
<f> dg         ..@@@@@@@@@@@@@@@&.. </f>
<f> dc           .../@@@@@@@@@@@@@@..... </f>
<f> lc              ....@@@@@@@@@@@@@@@&.... </f>
<f> dc              ..(#@@@@@@@@@@@@@@@@@@@ </f>                                    
<f> db         ./@@@@@@@@@@@@@@@@%...... </f>
<f> lb     .@@@@@@@@@@@@@@@@.@@@&. </f>
<f> db   @@@@@@@@@@@@@@..   .@@@&. </f>
<f> dm  .@@@@@@@@@@@@.      .@@@&. </f>
<f> lm ..@@@@@@@@@@@@/.......@@@&. </f>
<f> dm  ...,@@@@@@@@@@@@@@@@@@@@&................. </f>
<f> gr      ...@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@.. </f>
<f> dw          ....../@@@@@@@@@@@@@@@@@@@@@@@@@@@@@# </f>
<f> lw                   ..,,,,*##@@@@@@@@@@@@@@@.      .###################. </f>
<f> dw                 @@@@@@@@@@@@@@@@@@@@..        @@@@@@@@@@@@@@@@@@@@@@ </f>
<f> gr              /@@@@@@@/........              @@@@@@@@@@@@@@@@@@@@. </f>
</i>                                                                              
                                                                                

<i> 2 <f> hint ─[ <-f> light-cyan bsd0 </f-> ]───────────────────────────────────────────────────────────────────────────────────── </f->
Permission to use, copy, modify, and/or distribute this software for any purpose
with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
<f> hint ──────────────────────────────────────────────────────────────────────────────────────────── </f> </i>

EOF
	redraw
}

@@ view-page
:: Display formated text nicely	
function view-page {
	save openfile
	declare-new-buffer
		:: line 3
		:: column 4
		:: info "view"
		:: mode format
		:: filetype 'format'
		:: file "*view*"
		:: modified 0
		:: isfile 0
		:: syntax syntax-format
		:: syntax-exec 1
	size-full
	clrmsg=0	
	message='loading...'
	redraw-commandline
	load-doc
	copy-array top_doc buffer
	redraw
}

@@ list-faces-display
:: Displays list of faces
function list-faces-display {
	save openfile
	declare-new-buffer
		:: line 1
		:: info "$1"
		:: mode view
		:: filetype 'i*view'
		:: file '*format*'
		:: modified 0
		:: syntax syntax-format
		:: syntax-exec 1
	size-full
	buffer=('')
	for face in "${!faces[@]}"; do
		buffer+=(
			"$(printf '%*s' -40 "${face}") <f> ${face} abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ </f>"
		)
	done
	buffer-dialog-draw
}

@@ list-data-display
:: Displays list of data of buffer from bf_d array	
function list-data-display {
	read-command "List data of buffer: " readin
	local -n bdata="${readin}_bf_d"
	buffer-dialog faces 'data' '*list-data-display*'
	buffer=('')
	for datum in "${!bdata[@]}"; do
		buffer+=(
			"$(
			printf '%*s%s' -20 "${datum}" "${bdata[${datum}]}"
		)"
		)
	done
	buffer-dialog-draw
}

@@ list-options-display
:: Displays list of options
function list-options-display {
	buffer-dialog faces '*list-data-display*'
	buffer=('')
	for option in "${!options[@]}"; do
		buffer+=(
			"$(
				printf '%*s%s' -20 "${option}" "${options[${option}]}"
			)"	
		)
	done
	buffer-dialog-draw
}

@@ table-init
:: Initializes bml \(bash markup language\) table
function table-init {
	table_columns="$1"
	shift
	local -i i=0
	for col in "$@"; do
		local -n n="table_column_$i"
		n="$col"
		((i++))
	done
}

@@ table-char
:: Sets style of bml table
function table-char
	if (( ${#@} == 11 )); then
		table_char=("$@")
	else
		table_char=(─ │ ┌ ┬ ┐ ├ ┼ ┤ └ ┴ ┘)
	fi

@@ table-top
:: Prints top line of bml table
function table-top {
	printf '%s' "<f> hint ${table_char[2]}"
	for ((i=0; i<table_columns; i++)); do
		local -n n="table_column_$i"
		for ((ii=1; ii-1<n; ii++)); do
			printf '%s' "${table_char[0]}"
		done
		((i==table_columns-1)) || printf '%s' "${table_char[3]}"
		((i==table_columns-1)) && printf '%s' "${table_char[4]}"
	done
	printf '%s\n' ' </f->'
}

@@ table-title-line
:: Prints bml table title divider
function table-title-line {
	printf '%s' "<f> hint ${table_char[5]}"
	for ((i=0; i<table_columns; i++)); do
		local -n n="table_column_$i"
		for ((ii=1; ii-1<n; ii++)); do
			printf '%s' "${table_char[0]}"
		done
		((i==table_columns-1)) || printf '%s' "${table_char[6]}"
		((i==table_columns-1)) && printf '%s' "${table_char[7]}"
	done
	printf '%s\n' ' </f->'
}
@fn table-divider 'table-title-line "$@"'

@@ table-bottom
:: Prints bottom line of bml table
function table-bottom {
	printf '%s' "<f> hint ${table_char[8]}"
	for ((i=0; i<table_columns; i++)); do
		local -n n="table_column_$i"
		for ((ii=1; ii-1<n; ii++)); do
			printf '%s' "${table_char[0]}"
		done
		((i==table_columns-1)) || printf '%s' "${table_char[9]}"
		((i==table_columns-1)) && printf '%s' "${table_char[10]}"
	done
	printf '%s\n' ' </f->'
}

@@ table-item
:: Prints line of table
function table-item {
	local -i i=0
	for item in "$@"; do
		local -n n="table_column_$i"
		printf '%s' "<f> hint ${table_char[1]} </f-> "
		printf '%s' "$item"
		printf '%*s' $(( n - ${#item} )) ''
		((i++))
	done
	printf '%s' "<f> hint ${table_char[1]}"
	printf '%s\n' ' </f->'
}

@@ table-title
:: Prints title of table
function table-title {
	local -i i=0
	for title in "$@"; do
		local -n n="table_column_$i"
		printf '<f> hint %s' "${table_char[1]} </f->"
		printf '%*s' $(( n / 2 - ( ${#title} / 2 ) )) ''
		printf '%s' " <-f> title $title </f-> "
		if ((${#title}%2==0)) && ((n%2==1)); then
			printf ' %*s' $(( ( n / 2 - ( ${#title} / 2 ) ) + 1 )) ''
		else
			printf ' %*s' $(( n / 2 - ( ${#title} / 2 ) )) ''
		fi
		((i++))
	done
	printf '%s' "<f> hint ${table_char[1]}"
	printf '%s\n' ' </f->'
}

@@ code-block
:: Prints code in bml document
function code-block while read -r; do echo " <-f> light-cyan $REPLY </f-> "; done

@@ print-stdin
:: Basically like coreutil "'cat'"
function print-stdin while read -r; do echo "$REPLY"; done

@@ text
:: Prints normal text in bml document
function text
	while read -r; do
		l=${#REPLY}
		for ((i=0; i<l; i+=(bf_d[size-x]/3)*2)); do
			printf '%s%s\n' "$1" "${REPLY:i:(bf_d[size-x]/3)*2}"
		done
	done

@fn title 'printf "[ <f> title %s </f> ]" "$@"'
@fn code 'printf "$@"'

@@ header
:: Prints header of bml document
function header {
	arg=$*
	table-init 1 $(( ${#arg} * 2 ))
	table-char ═ ║ ╔ X ╗ X X X ╚ X ╝
	print-stdin <<-EOF2
                                 $(table-top)
                                 $(table-title "${1}")
                                 $(table-bottom)
	EOF2
}

@@ manual
:: 'Displays C-h r manual buffer'
function manual {
	save openfile
	declare-new-buffer
		:: line 1
		:: info "About"
		:: mode view
		:: filetype 'i*format'
		:: file "*about*"
		:: modified 0
		:: syntax syntax-format
		:: syntax-exec 1
	size-full
	get-manual
	redraw
}
	
@@ get-manual
:: Parses manual bml document
function get-manual {
	#DO NOT edit following lines, makedoc handles them automatically
	# MAKEDOC INSERT README START
mapfile -t -O 1 buffer <<EOF
$(text <<EOF2
This is Ebashs, one component of the Bash/Bash operating system.
… or even better an attempt to clone GNU Emacs in bash.
EOF2
)

$(text '    '<<EOF2
Note that the readme, may be currently outdated as I am changing the core functioning of Ebashs.

Versions of Ebashs ending in WIP-x are and will be broken, you can check version via M-x about or by reading the second line of Ebashs script.
EOF2
)

$(text '    '<<EOF2
For more updated help run inside Ebashs $(code 'M-x describe') or $(code 'C-h C-f')
EOF2
)

$(text <<EOF2
Update: Ebashs was split into two parts, the editor (Ebashs) and the underlying tui framework (Buffermaker). This split isn't yet complete and using Buffermaker for programs other than Ebashs is very experimental (see testapp example).

Update 2: Buffermaker has been separated into https://github.com/aeknt/BufferMaker. Ebashs now includes its internal version of BufferMaker library to prevent breaking when I randomly decide to change core functions, and to make using Ebashs easier.
EOF2
)

$(header EBASHS)

$(title DESCRIPTION)

$(text <<EOF2
An attempt to clone GNU Emacs but in bash.
EOF2
)

$(title FEATURES)

$(text <<EOF2
syntax highlighting
custom keybindings
custom modes -- so you can implement the evil too
file picker
mouse support
EOF2
)

$(title CONFIG)

$(text <<EOF2
Ebashs is configured via variables defined at start, you can separate it into file and then source it.
EOF2
)

    $(title 'OPTIONS ARRAY')

$(table-init 3 19 19 39; table-char
print-stdin <<EOF2
    $(table-top)
    $(table-title NAME DEFAULT DESCRIPTION)
    $(table-title-line)
    $(table-item mouse ' 0' 'enable mouse at launch')
    $(table-item todonote ' 1' "highlight 'TODO:' & 'NOTE:'")
    $(table-item menuline ' 1' 'display menuline')
    $(table-item tabchar "$(code '|   ')" 'what should tab display as')
    $(table-item file_prompt "'Path: '" 'file setting prompt')
    $(table-item cmd_prompt "'M-x '" 'command line prompt')
    $(table-item cancelhex "'18 0' (C-x)" 'keybinding to exit debug input menu')
    $(table-item default_mode ' edit' 'what mode should be set on launch')
    $(table-item help_message "'F10 to open menu'" 'top right help message')
    $(table-item dired_message "'Pick a file'" 'same as above but for dired buffer')
    $(table-bottom)
EOF2
)

    $(title 'KEYBINDING ARRAYS')

$(text '    ' <<EOF2
Keybinding arrays match with modes. The array has to be associative and nammed $(code 'keys_<mode>'). $(code 'keys_def') is reserved and used as reference for other arrays, it's also reversed compared to other keybinding arrays.
EOF2
)

$(text '     ' <<EOF2
Keybindings are defined via hexadecimal syntax suffixed with ' 0'. Function $(code '@kbd field') is equivalent to $(code '${keys_def[field]}') but nicer. Function kbd provides Emacsy keybinding syntax.
EOF2
)

$(text '    ' <<EOF2
There is also a optionable option array possible for all keybinding arrays. Currently only defined option is [else] which defines what should happen if no key is matched from the keybinding. These arrays have to be named $(code 'key_options_<mode>').
EOF2
)

    $(title MODES)

$(text '    ' <<EOF2
Modes determine used keybinding and other properties of buffer.
EOF2
)

$(table-init 2 19 43; table-char
print-stdin <<EOF2
    $(table-top)
    $(table-title NAME DESCRIPTION)
    $(table-title-line)
    $(table-item edit "general editing mode")
    $(table-item dired "mode used in file picker")
    $(table-item view "read-only mode")
    $(table-item menu "mode of menus")
    $(table-item debuginput "for getting input codes (M-x input)")
    $(table-item prefix "for C-x prefix")
    $(table-item prefix_help "for C-h prefix")
    $(table-item quit "for quit confirmation")
    $(table-item list_buffers "used in buffer switcher")
    $(table-bottom)
EOF2
)

    $(title STYLE)

$(text '    ' <<EOF2
Style of stuff is defined as escape code. See extensions/gruvboxdark for example of custom theme.
EOF2
)

$(table-init 3 32 19 39; table-char
print-stdin <<EOF2
    $(table-top)
    $(table-title NAME DEFAULT DESCRIPTION)
    $(table-title-line)
    $(table-item default ' \e[m' 'Default face')
    $(table-item TODO ' \e[0;97;45m' "Highlighting of 'TODO: '")
    $(table-item NOTE ' \e[0;97;100m' "Highlighting of 'NOTE: '")
    $(table-item menu ' \e[0;37;40' 'Menuline')
    $(table-item menu-enabled-face ' \e[0;37;40' 'Items of menuline')
    $(table-item selected ' \e[30;45m' 'Selected item')
    $(table-item link ' \e[94m' 'Redirects')
    $(table-item menu-selected-face ' \e[30;45m' 'Selected item of menu')
    $(table-item mode-line ' \e[40;97m' 'Bottom statusline')
    $(table-item line-number ' \e[0;90m' 'Line count')
    $(table-item line-number-empty ' \e[0;90m' 'Lines that do not exist')
    $(table-item line-number-current-line ' \e[0;91m' 'Currently selected line')
    $(table-item tab-face ' \e[0;90m' 'Tabs')
    $(table-item minibuffer-prompt ' \e[m' 'Bottom commandline')
    $(table-divider)
    $(table-item font-lock-variable-string-face ' \e[0;36;48m' 'Quoted variables')
    $(table-item font-lock-comment-face ' \e[3;37;48m' 'Comments')
    $(table-item font-lock-variable-name-face ' \e[0;96m' 'Variables')
    $(table-item font-lock-argument-face ' \e[0;93m' 'Options')
    $(table-item font-lock-flow-face ' \e[0;93m' 'Control flow')
    $(table-item font-lock-pipe-face ' \e[1;94m' 'Pipes')
    $(table-item font-lock-bracket-face ' \e[1;95m' 'Brackets')
    $(table-item font-lock-constant-face ' \e[0;92m' 'Constants')
    $(table-item font-lock-string-face ' \e[0;32m' 'Strings')
    $(table-item font-lock-assign-face ' \e[0;94;108m' 'Variable assignments')
    $(table-item font-lock-function-name-face ' \e[0;30;44m' 'Function definitions')
    $(table-item font-lock-declare-face ' \e[0;91m' 'Keywords')
    $(table-bottom)
EOF2
)
$(text '    ' <<EOF2
Ebashs also includes the ansi-color-* faces, see M-x list-faces-display for full list.
EOF2
)

    $(title SYNTAX)

$(text '    ' <<EOF2
Defines which syntax functions should be used for which file types.
EOF2
)

    $(title MENULINE)

$(text '    ' <<EOF2
Defines items in menuline, content of keys defines which functions should be ran on invocation.
EOF2
)

    $(title MENUS)

$(text '    ' <<EOF2
Each menu has to have helper function to set it up on request:
EOF2
)
$(code-block bash <<EOF2
        <menu>() { declare -ng menucon=<menu>; menu; }
EOF2
)
$(text '    ' <<EOF2
The contents of menu are defined by an associative  array.
EOF2
)

    $(title ALIAS)

$(text '    ' <<EOF2
Defines aliases that can be used in $(code 'M-x').
EOF2
)
$(text '    ' <<EOF2
Use function $(code add-alias name command) to define.
EOF2
)

$(title EXTENDING)

$(text <<EOF2
Some of useful variables and for extending Ebashs
EOF2
)

$(table-init 2 19 43; table-char
print-stdin <<EOF2
$(table-top)
$(table-title NAME DESCRIPTION)
$(table-title-line)
$(table-item buffer 'File data')
$(table-item buffersyntax 'Multidimensional buffer for rendering')
$(table-item bufferexpand 'Special characters filtered out')
$(table-item bufferdata 'Options of current buffer')
$(table-item charmap 'Definitions for bufferexpand')
$(table-item mode 'Current mode')
$(table-item commands 'List of M-x commands')
$(table-bottom)
EOF2
)

$(title 'SYNTAX HIGHLIGHTING')

$(text <<EOF2
Ebashs handles highlighting via checking 'syntax' array which consists of $(code '[file type]=syntax-function')
EOF2
)

    $(title 'SYNTAX FUNCTIONS')

$(text '    ' <<EOF2
Here is sample bash syntax function included with Ebashs:
EOF2
)

$(code-block bash <<EOF2
    set-highlight
        :: shell bash ksh dash sh mksh zsh ash oksh i*bash

	defun syntax-shell
		:: Syntax function for shell
		:: Used faces:
		:: '    * font-lock-declare-face'
		:: '    * font-lock-variable-string-face'
		:: '    * font-lock-comment-face & sets comment to 1 for syntax-word function'
		:: '    * font-lock-variable-name-face'
		:: '    * font-lock-argument-face'
		:: '    * font-lock-function-name-face'
		:: '    * font-lock-flow-face'
		:: '    * font-lock-pipe-face'
		:: '    * font-lock-bracket-face'
		:: '    * font-lock-constant-face'
		:: '    * font-lock-string-face'
		:: '    * font-lock-assign-face'
		:: '    * font-lock-keyword-face'
		:: '    * font-lock-default-face'
		function =
			case "${word}" in
				*'=()'|'declare'|'local'|'typeset') set-face font-lock-declare-face;;
				'"$'*) set-face font-lock-variable-string-face;;
				'#'*) set-face font-lock-comment-face && comment=1;;
				'$'*) set-face font-lock-variable-name-face;;
				'-'*) set-face font-lock-argument-face;;
				*'()') set-face font-lock-function-name-face;;
				'||'|'&&'|';'|'&') set-face font-lock-flow-face;;
				'>'|'<'|'|'|'>>'|'<<'|'<<<') set-face font-lock-pipe-face;;
				'('|')'|'{'|'}'|'[['|']]'|'['|']') set-face font-lock-bracket-face;;
				'function') set-face font-lock-function-name-face;;
				*"'"*) set-face font-lock-constant-face;;
				*'"'*) set-face font-lock-string-face;;
				*'='*) set-face font-lock-assign-face;;
				'echo'|'return'|'case'|'esac'|'for'|'while'|'do'|'done'|'if'|'elif'|\\
					'else'|'printf'|'fi'|'continue'|'exit'|'bind'|'then'|'break'|'read'|\\
					'let'|'shopt'|'trap'|'set'|'eval'\\
						) set-face font-lock-keyword-face;;
				*) set-face default;;
			esac
EOF2
)

$(text '    ' <<EOF2
The comments are handled specially via comment variable which gets reseted at every newline.
EOF2
)

$(title EXAMPLES)

$(text <<EOF2
A simple function to jump to line 11 when $(code 'C-x M-e') is pressed:
EOF2
)

$(code-block bash <<EOF2
    keys_prefix+=( # prefix is the mode for C-x
        [1b 65 0]='jump-to-11' # '1b 65 0' is the M-e in hex.
                               # You can use the M-x input to convert to hex. format.
    )
    jump-to-11() {
        [[ -n "${buffer[11]}" ]] && line=11 # If line 11 exists, set current line to 11.
        [[ "${bufferdata[mode]}" = 'prefix' ]] && quit-prefix
                                    # Since the key stroke contains C-x as prefix,
                                    # quit-prefix is is required as otherwise
                                    # it would stay in 'prefix' mode.
        redraw # Redraw whole buffer.
    }
EOF2
)

$(text <<EOF2
A function to write $(code 'Hello world!') at current cursor position when $(code 'M-x hi') is typed
EOF2
)

$(code-block bash <<EOF2
    commands+=(
        [hi]='hello-world' # Add command 'hi' invoking 'hello-world' function:
    )
    hello-world() {
        insert-word 'Hello-world!' # The function 'insert-word' handles insertion
                                   # of stuff, so no redraw or other magic is needed.
    }
EOF2
)

$(text '    ' <<EOF2
Create a menu containing previous functions $(code 'jump-to-11') & $(code 'hello-world'):
EOF2
)

$(code-block bash <<EOF2
    example-menu-function() { declare -ng menucon='example_menu'; menu; }
    # A function with which the menu will be invoked.

    declare -A example_menu
    example_menu=(
        [Jump to 11  ]='jump-to-11'  # The names of items in menu should have
        [Hello world!]='hello-world' # same width to display correctly.
    )

    # Add the example_menu into default menuline
    menulineedit+=(
        [Example]='example-menu-function'
    )
EOF2
)

$(title ETC)

$(text <<EOF2
Logo and it's krita file is in etc/

This readme is generated from doc/README.bml via makedoc script.
EOF2
)

$(title CREDITS)

$(text '    ' <<EOF2
Based on https://github.com/comfies/bed
EOF2
)

$(text '    '<<EOF2
fff by Dylan Araps https://github.com/dylanaraps/fff as base for extensions/efff
Licensed under the MIT license see extensions/efff for details
EOF2
)

$(text '    '<<EOF2
Early versions of Ebashs/Bano can be found at
https://github.com/aeknt/bashbox/blob/master/bin/nano
https://github.com/aeknt/bashbox/blob/master/bin/bano
EOF2
)
EOF
	# MAKEDOC INSERT README STOP
}

defun describe-function
	:: Displays help and info of function
	function = {
		redraw
		read-command 'Describe function: ' function || return 1
	    doc-select "$function"
	}

defun describe
	:: Displays help and info of all functions
	function = {
	    save openfiledoc
		declare-new-buffer
			:: line 9
			:: base 1
			:: column 0
			:: info "Documentation"
			:: mode format
			:: filetype 'format'
			:: file "*functions*"
			:: modified 0
			:: syntax syntax-format
			:: syntax-exec 1
			:: menuline 'dialog'
		size-full
		buffer=(
			''
		    "$format_nav"
			''
			'<f> title <u> Functions </u> </f>'
			'<i-tab>'
			'Documentation of these function is defined via internal pseudo-comments.'
			'It consists of the description and the source code. The source code is formated automatically'
			'by Bash and differs greatly from the formating of real source code.'
			'</i>'
)
		while read -r fn;  do
			buffer+=("<a> doc-select ${fn:11} : <f> link ${fn:11} </f> </a>")
		done <<< "$(declare -F)"
		buffer+=(
			''
			"<tab> <f> font-lock-comment-face Ebashs $version </f>"
		)
		redraw
}

defun doc-select	
	:: Select documentation item
	function = {
		local function="$@"
	    save openfile
		declare-new-buffer
			:: line 5
			:: info "Describe"
			:: mode format
			:: format-else quit-view
			:: filetype 'format'
			:: file "*describe*"
			:: modified 0
			:: syntax syntax-format
			:: syntax-exec 1
			size-full
		buffer=(
			''
			"$format_nav"
			''
		)
		mapfile -t -O 3 buffer <<< "$(get-description "$function")"
	    redraw
	}
nufed

@@ doc-goto
:: Replace function documentation with function \$1.
:: 'See <a> doc-goto get-description : <f> link get-description </f> </a> for more details.'
function doc-goto {
	clear-buffer
	bf_d[line]=1
	bf_d[column]=0
    buffer=(
		''
		"$format_nav"
		''
	)
	mapfile -t -O 3 buffer <<< "$(get-description "$1")"
	redraw
}

defun quit-doc
	:: Quits and restores previous buffer.
	function = {
		restore openfiledoc
		redraw
	}

defun get-description
	:: Prints desciption of function \$1
	function = {
		is-function "$1" || {
			echo "<f> highlight $1 is not a Ebashs function </f>"
			return
		}
		printf "%s\n" "<f> title [ $1 ] </f>"
		[ -z "${descriptions[function_${1}_description]}" ] && {
			echo 'Function has no documentation'
			return
		}
		local -n fn_desc="${descriptions[function_${1}_description]}"
		((${#fn_desc[@]})) && {
			echo
			for l in "${fn_desc[@]}"; {
				printf "%s\n" "$l"
			}
			#for i in {0..8}; {
			#	printf '\n'
			#}
			#printf '<f> title [ Source ] </f>\n <change-syntax> 0 shell\n'		 
			#declare -f -- "$1"
		}
	}

defun quit-view
	:: Quits and restores previous buffer.
	:: Used mainly for dialog buffers.
	function = {
		restore openfile
		redraw
	}
nufed

@@ duplicate-line Copies line
function duplicate-line {
	newline # create new empty line
	buffer[bf_d[line]-1]="${buffer[bf_d[line]]}" # copy current line to previous line
	#make-render-area $((bf_d[line]-1)) $((bf_d[line]))
	local -n lap="${current_buffer}_syntax$((bf_d[line]-1))"
	local -n lac="${current_buffer}_syntax$((bf_d[line]))"
	copy-array lac lap
	redraw
}
	
@@ newline
:: Inserts newline to current buffer at current cursor position, shift lines
:: below one line down and go down one line.
function newline {
	bf_d[modified]=1
	save-state
	buffer=('' "${buffer[@]:1:${bf_d[line]}-1}" '' "${buffer[@]:${bf_d[line]}}")
	buffer[bf_d[line]]="${buffer[${bf_d[line]}+1]:0:${bf_d[column]}}"
	buffer[bf_d[line]+1]="${buffer[${bf_d[line]}+1]:${bf_d[column]}:${#buffer[${bf_d[line]}+1]}}"
	bf_d[column]=0
	syntax-shift
	no_cursor=1
	redraw
	no_cursor=0
	next-line
}

@@ syntax-shift
:: Moves syntax multibuffer from current cursor position one line to the bottom.
:: Used in newline function.
::
:: Is currently very badly implemented, TODO: fix.
function syntax-shift {
	local -a tmp1
	local -a tmp2
	local extmp1
	local extmp2
	for ((l=bf_d[line];l<${#buffer[@]}+1;l++)); do
		local -n linearray="${current_buffer}_syntax${l}"
		copy-array linearray tmp1
		copy-array tmp2 linearray
		copy-array tmp1 tmp2
		extmp1="${bf_e[l]}"
		bf_e[l]="$extmp2"
		extmp2="$extmp1"
	done
	bf_s[buffer_length]="${current_buffer}_syntax${bf_d[number-length]}"
	unset tmp1 tmp2
	make-render-area $((bf_d[line])) $((bf_d[line]+2))
}

defun delete-line
	:: Deletes line at current cursor position
	function = {
		bf_d[modified]=1
		buffer-delete-line "${bf_d[line]}"
		((bf_d[line] == 1)) || previous-line
		redraw
	}

defun buffer-delete-line
	:: Deletes line at \$1
	function = {
		local -i l=$1
		save-state
		buffer=("" "${buffer[@]:1:l-1}" "${buffer[@]:l+1}")
		bf_s=("" "${bf_s[@]:1:l-1}")
	}

fragment getrlr <<'+'
	local -i rlr
	unset ta
	local ta
	ta=${bf_e[${bf_d[line]}]:0:${bf_d[column]}}
	ta=${ta//[^t]}
	ta=${#ta}
	rlr=$((bf_d[column] + ta / 4 - ta))
+

fragment predelete <<'+'
	((bf_d[selection])) && {
		delete-selection
		return
	}
	((${#buffer[${bf_d[line]}]} == 0 )) && {
		delete-line
		bf_d[column]="${#buffer[${bf_d[line]}]}"
		redraw
		return 0
	}
+

defun-fragment backspace
	:: Deletes previous character
	function = {
		save-state
		@ predelete
		@ getrlr
		((rlr==0)) && {
			buffer[bf_d[line]-1]="${buffer[bf_d[line]-1]}${buffer[bf_d[line]]}"
			delete-line
			bf_d[column]=${#bf_e[${bf_d[line]}]}
			redraw
			return 0
		}
		buffer[${bf_d[line]}]="${buffer[${bf_d[line]}]:0:$(( rlr - 1 ))}${buffer[${bf_d[line]}]:${rlr}}"
		backward-char #go back with cursor
		make-render-line # copy the buffer into bf_s and bf_e
		redraw #draw it
		bf_d[modified]=1
	}

defun-fragment delete
	:: Deletes next character
	function = {
		save-state
		@ predelete
		@ getrlr
		((rlr==${#buffer[bf_d[line]]})) && {
			buffer[bf_d[line]]="${buffer[bf_d[line]]}${buffer[bf_d[line]+1]}"
			move-next-line
			delete-line
			bf_d[column]=${#bf_e[${bf_d[line]}]}
			redraw
			return 0
		}
		buffer[bf_d[line]]="${buffer[bf_d[line]]:0:rlr}${buffer[bf_d[line]]:rlr+1:${#buffer[bf_d[line]]}}"
		make-render-line # copy the buffer into bf_s and bf_e
		redraw #draw it
		bf_d[modified]=1
	}

defun delete-selection
	:: Deletes region
	function = {
		_ sy bf_d[selection_start_y]
		_ ey bf_d[selection_end_y]
		_ sx bf_d[selection_start_x]
		_ ex bf_d[selection_end_x]
		((sy == ey)) && {
			((sx > ex)) && __ sx ex
			buffer[sy]="${buffer[sy]:0:sx}${buffer[sy]:ex}"
			bf_d[column]=$sx
			make-render-area $sy $((sy+1))
		} || {
			((sy > ey)) && {
				__ sy ey
				__ sx ex
			}
			buffer[sy]="${buffer[sy]:0:sx}"
			buffer[ey]="${buffer[ey]:ex}"
			buffer=("" "${buffer[@]:1:sy}" "${buffer[@]:ey}")
			bf_s=("" "${bf_s[@]:1:sy-1}")
			buffer[sy+1]="${buffer[sy]}${buffer[sy+1]}"
			buffer=("" "${buffer[@]:1:sy-2}" "${buffer[@]:sy}")
			bf_d[line]=$sy
			bf_d[column]=$sx
		}
		bf_d[selection]=0
		redraw
		_ # unset reference aliases
	}

defun write-buffer
	:: Writes current buffer into its target file	
	function =
		if [ -w "${bf_d[file]}" ]; then
			dump-buffer "${bf_d[file]}"
			bf_d[modified]=0
			message="Wrote ${#buffer[@]} lines to \'${bf_d[file]}\'"
		else
			return 1
		fi

add-mode quit
	local-set-key "$(kbd y)" 'save-quit'
	local-set-key "$(kbd n)" 'die'
	local-set-key "$(kbd c)" 'quit-quit'
	local-set-key "$(kbd C-y)" 'save-quit-force'

defun save-quit-force
	:: Force saving file
	function = {
		dump-buffer "${bf_d[file]}"
		die
	}
	
defun save-quit
	:: Writes buffer if target is writable
	function =
		if write-buffer; then
			die
		else
			message='File is not writable! [n/c] (to force save C-y)'
			redraw-commandline
		fi

defun quit-quit
	:: Quits quit message
	function = {
		bf_d[mode]="$bckmode"
		message='Quit canceled'
		redraw
	}

defun quit
	:: Displays quit message and sets mode to \'quit\'
	function = {
		[ -n "${bf_d[isfile]}" ] && ((bf_d[isfile]==0)) || ((bf_d[modified]==0)) && {
			die
		}
		
		[ -z "$bckmode" ] && bckmode="${bf_d[mode]}"
		bf_d[mode]='quit'
		redraw-statusline
		printf '\e[%s;0H' $((bf_d[size-y] + bf_d[loc-y]))
		printf '%s' 'Buffer modified, save before close? [y/n/c]'
	}

defun set-mark-command
	:: Begins selection	
	function =
		if ((bf_d[selection])); then
			log info 'selection disable'
			bf_d[selection]=0
		else
			bf_d[selection]=1
			bf_d[selection_start_y]="${bf_d[line]}"
			bf_d[selection_start_x]="${bf_d[column]}"
			log info 'selection enable'
		fi

defun shell
	:: Spawns bash as subprocess
	function = {
		clear-screen
		bash # NOTE: in theory an external command
		redraw
	}

defun execute
	:: Executes a command and inserts its output into buffer	
	function = {
		((bf_d[line] == 0)) && return # If the line is not possible, do nothing
		printf '\e[?25h\e[%sH' "$((bf_d[line] + 2 - bf_d[base]))" # Reset cursor position and enable cursor
		read -re -p "$(printf '%4s ' "$")" # Present editable line
		if [[ "$REPLY" != "${buffer[${bf_d[line]}]}" ]]; then # If the line is changed, update and inform
			buffer[${bf_d[line]}]="$($REPLY)"
			bf_d[modified]=1
		fi
		make-render-line
		redraw
	}

defun diff-buffer-syntax
	:: Deletes highlighting on modified lines, comparing two buffers
	function = {
		# remove outdated lines from bf_s to set them for resyntaxing
		local -n source="$1"
		local -n target="$2"
		for idx in "${!target[@]}"; do
			[ "${source[idx]}" = "${target[idx]}" ] || bf_s[idx]=
		done
	}

defun diff-buffer-copy
	:: Compares two buffers and copies the difference into \$3 buffer
	function = {
		local -n source="$1"
		local -n check="$2"
		local -n target="$3"
		[ -z "${source[*]}" ] && return 1 # | indicate that there's no previous buffer state to check against 
		[ -z "${check[*]}"  ] && return 1 # | should indicate save-state() to just copy the whole buffer
		target=()
		for idx in "${!source[@]}"; do
			[ "${source[idx]}" = "${check[idx]}" ] || target[idx]="${source[idx]}"
			[ "${source[idx]}" = "${check[idx]}" ] && target[idx]=''
		done
	}

defun diff-buffer-merge
	:: Add buffer \$1 on top of \$2
	function = {
		local -n source="$1"
		local -n target="$2"
		for idx in "${!source[@]}"; do
			[ -n "${source[idx]}" ] && target[idx]="${source[idx]}"
		done
	}

defun save-state
	:: Saves current buffer for undo function
	function = {
		((bf_d[current_state]++))
		declare -ga "${current_buffer}_buffer_state_${bf_d[current_state]}"
		diff-buffer-copy\
			buffer\
			"${current_buffer}_buffer_state_$((bf_d[current_state]-1))"\
			"${current_buffer}_buffer_state_${bf_d[current_state]}" || {
			copy-array buffer "${current_buffer}_buffer_state_${bf_d[current_state]}"
		}
	}

defun undo
	:: Undo a change
	function = {
		((bf_d[current_state]--))
		((bf_d[current_state]<0)) && {
			bf_d[current_state]=0
			bf_d[modified]=0
		}
		diff-buffer-syntax buffer "${current_buffer}_buffer_state_${bf_d[current_state]}"
		diff-buffer-merge "${current_buffer}_buffer_state_${bf_d[current_state]}" buffer
		redraw
	}

defun toggle-mouse
	:: 'Changes options[mouse]'
	function =
		case "${options[mouse]}" in
			0)
				printf '\e[?1000;1006;1015h'
				options[mouse]=1
				message='Enabled options[mouse]';;
			1)
				printf '\e[?1000;1006;1015l'
				options[mouse]=0
				message='Disabled options[mouse]'
		esac

defun toggle-mode-line
	:: 'Changes options[mode-line]'
	function =
		case "${options[mode-line]}" in
			0)
				options[mode-line]=1
				((bottomlines++))
				redraw;;
			1)
				options[mode-line]=0
				((bottomlines--))
				redraw
		esac

defun toggle-command-line
	:: 'Changes options[command-line]'
	function =
		case "${options[command-line]}" in
			0)
				options[commandline]=1
				((bottomlines++))
				redraw;;
			1)
				options[command-line]=0
				((bottomlines--))
				redraw
		esac

defun toggle-line-number-mode
	:: 'Changes options[line-number-mode]'
	function = {
		case "${options[line-number-mode]}" in
			0) options[line-number-mode]=1;;
			1) options[line-number-mode]=0
		esac
		redraw
	}

defun toggle-menu-line
	:: 'Changes options[menu-line]'
	function = {
		case "${options[menu-line]}" in
			0) options[menu-line]=1;;
			1) options[menu-line]=0
		esac
		toplines="${options[menu-line]}"
		redraw
	}
nufed
	
@fn self-insert 'insert-word $@'
@fn insert-space 'insert-word " "'
@fn indent-for-tab-command "insert-word '	'"

@@ load-config Sources custom config file
function load-config {
	log_buffer+=('LOADING CONFIG...')
	local config_file
	local f
	f=~/.config/ebashsrc.d/init.bash ;[ -f "$f" ] && config_file="$f"
	f=~/.config/ebashsrc ;[ -f "$f" ] && config_file="$f"
	f=~/.ebashsrc ;[ -f "$f" ] && config_file="$f"
	f=~/.ebashsrc.d/init.bash ;[ -f "$f" ] && config_file="$f"
	f=.ebashsrc ;[ -f "$f" ] && config_file="$f"
	f=.ebashsrc.d/init.bash ;[ -f "$f" ] && config_file="$f"
	
	f="${EBASHS_CONFIG}" ;[ -n "$f" ] && [ -f "$f" ] && config_file="$f"
	f="${EBASHS_CONFIG_DIR}/init.bash" ;[ -n "$f" ] && [ -f "$f" ] && config_file="$f"
	
	[ -z "$config_file" ] && return
	source "$config_file"
	log_buffer+=("LOADED $config_file")
}

@@ scratch
:: Empty buffer
function scratch {
	log info "loading empty buffer..."
	declare-new-buffer
		:: mode "${options[default_mode]}"
		:: info "${options[help-message]}"
		:: filetype "bash"
		:: file "*scratch*"
		:: isfile 0
		:: menuline welcome
		:: current_state 0
	set-syntax
	size-full

	buffer=(
		''
		'# This buffer is for text that is not saved, and for Bash evaluation.'
		'# To create a file, visit it with C-x C-f and enter text in its buffer.'
		''
	)
		
	message="For information about Ebashs and the BASH system, type C-h C-a."
	bf_d[line]=1 # Indicate that we have a buffer loaded
	bf_d[modified]=0
}

@@ welcome-buffer
:: Show welcome message
function welcome-buffer {
	log info "loading welcome buffer..."
	declare-new-buffer
		:: mode welcome
		:: info "${options[help-message]}"
		:: filetype "format"
		:: file "*welcome*"
		:: isfile 0
		:: menuline welcome
		:: current_state 0
		:: syntax syntax-format
		:: syntax-exec 1
	size-full

	buffer=(
		''
		'<f> title <u> Ebashs </u> </f>'
		'<i-tab>'
		' Welcome to Ebashs the editor of pure Bash.'
		'</i>'
		'<f> title <u> Actions </u> </f>'
		'<tab> <a> find-file : <f> red Open <f> title f </f-> ile </f> </a>'
		'<tab> <a> dired : <f> yellow <f> title B </f-> rowse files </f> </a>'
		'<tab> <a> manual : <f> green View <f> title m </f-> anual </f> </a>'
		'<tab> <a> view-page : <f> cyan View <f> title d </f-> ocumentation </f> </a>'
		'<tab> <a> about : <f> blue <f> title A </f-> bout Ebashs </f> </a>'
		'<tab> <a> inputcodes : <f> magenta <f> title I </f-> nput debugging </f> </a>'
		'<tab> <a> list-faces-display : <f> red Fa <-f> title c </f-> es </f> </a>'
	)
	((log)) && buffer+=(
		'<tab> <a> view-log : <f> yellow <f> title L </f-> og </f> </a>'
	)
		
	message="For information about Ebashs and the BASH system, type C-h C-a."
	bf_d[line]=1 # Indicate that we have a buffer loaded
	bf_d[modified]=0
}

@@ init
:: Prepares variables and launches main function
function init {
	case "$1" in
		'--quick'|'-Q')
			log_buffer+=('- LOAD DEFAULT CONFIG -')
			load-default-config
			shift;;
		'--version')
			echo "$version"
			abort;;
		'--dump')
			declare -f
			echo 'init "$@"'
			abort;;
		'--help')
			print-stdin <<EOF
Usage: ebashs [OPTION-OR-FILENAME]...

Run Ebashs, the extensible, customizable, maybe-real-time
display editor.  The recommended way to start Ebashs for normal editing
is with no options at all.

Run C-h r RET inside Ebashs to read "manual".

Initialization options:
--quick, -Q    don't load config
--help,        display this help and exit
--version,     display version information and exit
--view, -v     open file for viewing if possible
--exec, -e     execute file as script with Ebashs features
EOF
			abort;;
		'--view'|'-v')
			log_buffer+=('- LOAD DEFAULT CONFIG -')
			options[view]=1
			load-default-config
			load-default-config-ebashs #loads default config
			load-config
			shift;;
		'--exec'|'-e')
			log_buffer+=('- LOAD DEFAULT CONFIG -')
			options[view]=1
			options[no-file]=1
			load-default-config
			load-default-config-ebashs #loads default config
			load-config
			source "$2"
			shift;;
		*)
			log_buffer+=('- LOAD DEFAULT CONFIG -')
			load-default-config
			load-default-config-ebashs #loads default config
			load-config
	esac
	init-var
	
	if [[ "$1" ]]; then # If a file was provided in the terminal pre-load it
		log info "args: $1"
		if [ -d "$1" ]; then
			log info "[$1] is directory => dired"
			cd "$1" || exit
			dired # enter the file selector in specified folder
		else
			log info "[$1] is file => read-buffer"
			read-buffer "$1"
		fi
	else
		log info "no arg => scratch"
		if ((options[welcome-buffer])); then
			welcome-buffer
		else
			scratch
		fi
	fi
	log info "drawing..."
	redraw
	log info 'entering main loop...'
	main
}

log_buffer+=('INIT')
init "$@"
;;
echo)
#!/usr/bin/env bash
#
# echo in pure bash.

echo "$@"
;;
ed)
#!/bin/bash
#ed in pure bash.
insert() {
	while true
	do
		read -r line
		if [ -z "$line" ]; then continue
		elif [ "$line" = . ]; then break
		else
			linee="$linee
$line"
		fi
	done
}
deleteline() {
	n=0
	linee=$(
		echo "$linee" | while read -r lined
		do
			if [ $n = "$linen" ]; then true
			else echo "$lined"
			fi
			((n++))
		done
	)
}
changeline() {
	n=0
	linee=$(
		echo "$linee" | while read -r lined
		do
			if [ $n = "$linen" ]; then
				read -r linec < /dev/tty
				echo "$linec"
			else echo "$lined"
			fi
			((n++))
		done
	)
}
insert() {
	n=0
	linee=$(
		echo "$linee" | while read -r lined
		do
			if [ $n = "$linen" ]; then
				read -r linec < /dev/tty
				echo "${linec}${lined}"
			else echo "$lined"
			fi
			((n++))
		done
	)
}
numberline() {
	n=0
	echo "$linee" | while read -r line
	do
		echo "$n $line"
		((n++))
	done
}
writee() {
	[ -z "$linee" ] && echo 'error: have no content'
	[ -z "$file" ] && echo 'no file specified'
	echo "$linee" > "$file"
	echo ${#linee}
}
#execute
linee=
linen=0
[ -n "$1" ] && file="$1"
if [ -f "$file" ]; then
	linee="$(<"$file")"
	echo ${#linee}
fi
while true
do
	read -rp ': ' command
	commandar=($command)
	if [ -z "$command" ]; then echo '?' && continue
	elif [ "$command" = a ]; then insert
	elif [ "$command" = q ]; then exit
	elif [ "$command" = d ]; then deleteline
	elif [ "$command" = c ]; then changeline
	elif [ "$command" = c ]; then insert
	elif [ "$command" = '+' ]; then ((linen++))
	elif [ "$command" = '-' ]; then ((linen--))
	elif [ "$command" = nl ]; then numberline
	elif [ "$command" = w ]; then writee
	elif [ "$command" = wq ]; then writee; exit
	elif [ "$command" = p ]; then echo "${linee##*$'\n'}"
	elif [ "$command" = ',p' ]; then echo "$linee"
	elif [ "${commandar[0]}" = f ]; then file="${commandar[1]}"
	elif [ "${commandar[0]}" = g ]; then linen="${commandar[1]}"
	else
		echo "?"
	fi
done
;;
emacs)
#!/bin/bash

ebashs_version='0.9.2'

### BUFFERMAKER START

#!/bin/bash
buffermaker_version="0.10.4.1-ebashs-internal"
log_buffer+=('' 'START')
## Buffermaker
# Pure bash tui framework (wip)

shopt -s lastpipe # For syntax highlighting
shopt -s extglob # Ensure advanced pattern matching is available
shopt -s checkwinsize && (:;:) # Enable and then trigger a terminal size refresh

declare -r DEFIFS="$IFS"
declare -A highlight faces faces_raw options charmap alias descriptions
declare -A menulineedit diredmenu menulinedebug
declare -A menufancy
declare -A keys_def keys_global
declare -a k_hex buffers_l log_buffer extensions modes=('keys_global')
declare -n buffer bf_s bf_e bf_d
declare -i menuloc_x menuloc_y toplines bottomlines hidden ismenu comment current_count _isdone
declare -n menucon
declare message reset readin

function load-default-config {
	## Configuration
	#		The magic :: function
	#			:: sets value to option depending on current context:
	#				set-options → define-options() → ass. array options
	#				global-set → global-set-key → define-key global → as. ar. keys_global
	#				add-mode → local-set-key → define-key <keys> → a. a. keys_<keys>
	#					mode-options → local-set-mode-option → define-mode-option → a. a. key_options_<keys>
	#				set-alias → add-alias → a. a. alias
	#				add-menu → local-set-menu → define-menu <menu> → menu_<menu>_0 & menu_<menu>_1
	#				set-highlight → add-highlight → a. a. highlight
					  
	options=(
		[mouse]=0
		[todonote]=0
		[menu-line]=0
		[mode-line]=0
		[command-line]=0 # note that disabling this means that any message will instead be draw on top of buffer
		[line-number-mode]=0
		[empty-line-char]=''
		[tabchar]='    '
		[keep-message]=0
		[log]=0
		[log-functions]=0
		[tty-linuxfb]=1 # enable truecolor support for framebuffer
		[full-redraw]=0 # redraws whole buffer, can fix artifacting in linuxfb at cost of performance
		[esc-to-meta]=0
	)
		
	## Key bindings configuration
	#		A keybinding is defined via either
	#		global-set; :: ... ... or add-mode <mode>; :: ... ...
	#		:: <key> <command>
	#			<key> is defined either via
	#				Hexadecimal format (with ' 0' added as suffix).
	#				Name of key like '[<key>]'
	#				Emacsy "$(kbd <key> )" (<key> being something like C-s M-e ...)
	#			The name of key and $(kbd) get translated into hex. format on startup.
	#
	#			mode-options sets magic :: to defining mode options
	#			:: option value

	add-mode empty
		mode-options
			:: else :
			:: disable-global 1
	
	## Faces
	#		Defined in escape codes
	#		Helper functions:
	#			:weight
	#				normal
	#				bold
	#			:slant
	#				normal
	#				italic
	#			:background & :foreground
	#				either hex. colour, colour name, or c<index> for 256 indexed colours
	#		See extensions/gruvboxdark for another example
default_faces=(
		reset '\e[m'
		default "$(:weight normal)"
		menu "$(:mode inverse)"
		menu-highlight '\e[7;30;43m'
		menu-back '\e[4m\e[1m'
		menu-enabled-face  "$(:mode inverse)"
		menu-selected-face "$(:foreground yellow :mode inverse :weight bold)"
		button "$(:foreground light-cyan)"
		link '\e[4;96m'
		link-highlight '\e[1;4;96m'
		title "$(:weight bold)"
		highlight "$(:weight bold :foreground light-red)"
		dim "$(:weight dim)"
		name "$(:foreground magenta)"
		hint "$(:foreground light-yellow)"
		hint-highlight '\e[4;93m'
		line-number "$(:foreground gray)"
		line-number-empty "$(:weight dim :foreground gray)"
		line-number-current-line "$(:weight bold :foreground light-red)"
		tab-face "$(:weight dim :foreground gray)"
		region "$(:weight bold :background gray)"
		minibuffer-prompt "$(:weight normal)"
		#
		TODO "$(:background magenta)"
		NOTE "$(:background gray)"
		mode-line "$(:mode inverse)"
		file-name "$(:weight bold)"
		# common colors for format stuff
		black      '\e[30m' gray          '\e[90m'
		red        '\e[31m' light-red     '\e[91m'
		green      '\e[32m' light-green   '\e[92m'
		yellow     '\e[33m' light-yellow  '\e[93m'
		blue       '\e[34m' light-blue    '\e[94m'
		magenta    '\e[35m' light-magenta '\e[95m'
		cyan       '\e[36m' light-cyan    '\e[96m'
		light-gray '\e[37m' white         '\e[97m'

		bg-black      '\e[40m' bg-gray          '\e[100m'
		bg-red        '\e[41m' bg-light-red     '\e[101m'
		bg-green      '\e[42m' bg-light-green   '\e[102m'
		bg-yellow     '\e[43m' bg-light-yellow  '\e[103m'
		bg-blue       '\e[44m' bg-light-blue    '\e[104m'
		bg-magenta    '\e[45m' bg-light-magenta '\e[105m'
		bg-cyan       '\e[46m' bg-light-cyan    '\e[106m'
		bg-light-gray '\e[47m' bg-white         '\e[107m'
)
	load-theme default_faces
}

## syntaxy sugar sugary syntax
log_buffer+=('- LOADING BASH EXTENSIONS -')
function @ifs { IFS="$DEFIFS"; }
	
# Make bash not be bashy enough
function @doc {
	mapfile -t "description_${desc_count}"
	descriptions["function_${1}_description"]="description_${desc_count}"
	((desc_count++))
}

# reverse of defun :D
function nufed {
	((_addfragment==1)) && {
		@add '='
		_addfragment=0
	}
	IFS=
	local -a fn
	local deffn="function $_function"$'\n'
	mapfile fn <<<"$(declare -f '=')"
	for ((i=1; i<${#fn[@]}; i++)) {
		deffn+="${fn[i]}"
	}
	eval "$deffn"
	_isdone=0
	@ifs
	unset '='
}
	
	
@doc copy-function <<'+'
copies function \$1 to function \$2
advantage of copying instead of creating wrapper alias functions should be in theory performance(?)

Little test script:
    1() {
    	echo hi > /dev/null
    }
    echo 1
    time for e in {0..100000}; do
    	1
    done
    
    2() {
    	1
    }
    echo 2
    time for e in {0..100000}; do
    	2
    done
    
    3() {
    	2
    }
    echo 3
    time for e in {0..100000}; do
    	3
    done
    
    4() {
    	3
    }
    echo 4
    time for e in {0..100000}; do
    	4
    done

output:
    1
    
    real	0m1,636s
    user	0m1,081s
    sys	0m0,540s
    2
    
    real	0m1,986s
    user	0m1,453s
    sys	0m0,518s
    3
    
    real	0m2,380s
    user	0m1,873s
    sys	0m0,491s
    4
    
    real	0m2,768s
    user	0m2,154s
    sys	0m0,595s

It seems like there's small performace gain.
+
function copy-function {
	local -a fn
	local deffn="function $2"$'\n'
	mapfile fn <<<"$(declare -f "$1")"
	for ((i=1; i<${#fn[@]}; i++)) {
		deffn+="${fn[i]}"
	}
	eval "$deffn"
}

function defun {
	if [ -z "$1" ]; then
		nufed
	else
		((desc_count++))
		log_buffer+=("    DEFUN: $1")
		((_isdone)) && nufed
		_addfragment="${_pass_addfragment}"
		descriptions["function_${1}_description"]="description_${desc_count}"
		_function="$1"
		_isdone=1
		_last_add=add-doc
	fi
}

function ::
case "$_last_add" in
	add-menu) local-set-menu "$@";;
	set-alias) add-alias "$@";;
	set-highlight) add-highlight "$@";;
	global-set) global-set-key "$@";;
	set-options) define-option "$@";;
	add-doc) add-doc "$@";;
	add-mode) local-set-key "$@";;
	mode-options) local-set-mode-option "$@";;
	set-buffer) local-set-buffer-data "$@"
esac

function add-doc {
	local -n cdoc="description_${desc_count}"
	cdoc+=("${_indent}$*")
}
function doc {
	((desc_count++))
	descriptions["function_${1}_description"]="description_${desc_count}"
	_function="$1"
	_last_add=add-doc
	_indent=''
	shift
	[ -n "$*" ] &&
		:: "$*"
}
copy-function doc @@

## :+ Add documentation indent
function :+ {
	_indent+="    "
	# "$*"
}
## :- Remove documentation indent
function :- {
	_indent="${_indent:0:${#_indent}-4}"
	# "$*"
}
# hell

## focus set magic # function
function focus {
	_last_add="$1"
}

## declare-new-buffer Create new text buffer
function declare-new-buffer {
	_last_add='set-buffer'
	((current_count++))
	set-buffer "bf_${current_count}"
	buffers_l+=("$current_buffer")
	last_line=1
	declare -Ag "${current_buffer}_bf_d"
	bf_d=(
		# some sane default values
		[line]=0
		[base]=1
		[column]=0
		[modified]=0
	)
}

## local-set-buffer-data
# set bf_d[] array of currently \"focused\" buffer
function local-set-buffer-data {
	while [ -n "$2" ]; do
		bf_d["$1"]="$2"
		shift 2
	done
}

## [auto] Checks bf_d[] array and set\'s needed missing values automatically
function [auto] {
	[ -z "${bf_d[loc-x]}" ] && bf_d[loc-x]=1
	[ -z "${bf_d[loc-y]}" ] && bf_d[loc-y]=1
	[ -z "${bf_d[size-x]}" ] && bf_d[size-x]=$COLUMNS
	[ -z "${bf_d[size-y]}" ] && bf_d[size-y]=$((LINES - 1))
	[ -z "${bf_d[syntax]}" ] && set-syntax 
}

## defun-fragment Same as defun but includes fragments for the function
function defun-fragment {
	_pass_addfragment=1
	defun "$@"
}

# fragments act basically like macros but with cooler name
# see redraw-buffer function for example usage
## fragment Creates a function-insertable macro
function fragment {
	log_buffer+=("        FRAGMENT: $1")
	declare -ag "_fragment_$1"
	mapfile "_fragment_$1"
}
	
## @add Adds fragment to a function
function @add {
	local -a _add_fn
	local -a _add_nfn
	local -i _add_f
	local -i _add_hf
	local _add_nfnline
	mapfile _add_fn < <(declare -f -- "$1")
	IFS=' '
	for _add_l in "${!_add_fn[@]}"; {
		_add_f=0
		_add_hf=0
		_add_nfnline=
		for _add_w in ${_add_fn[_add_l]}; {
			if [ "$_add_w" = '@' ]; then
				_add_f=1
			elif ((_add_f)); then
				_add_f=0
				_add_hf=1
				local -n _add_fragment="_fragment_${_add_w//[^[:alnum:]]/}"
				for _add_l1 in "${!_add_fragment[@]}"; {
					_add_nfnline+=" ${_add_fragment[_add_l1]}"
				}
			else
				_add_nfnline+=" $_add_w"
			fi
		}
		((_add_hf)) || _add_nfn+="${_add_fn[_add_l]}"
		((_add_hf)) && _add_nfn+="$_add_nfnline"
	}
	eval "${_add_nfn[*]}"
}

## @def Defines a function template
function @def {
	local -n _tpl="_template_$1"
	local _fn
	local -i _n=0
	shift
	for _w in $_tpl; {
		case "$_w" in
			'@var')
				_n=1;;
			*)
				((_n)) && {
					_n=0
					_fn+="${!_w} "
					continue
				}
				_fn+="$_w "
		esac
	}
	eval "$_fn"
}

## _ Variable refernce helper
function _ {
	# this function is here to simplify stuff as writing overlong variables indexed by overloong variable index...
	# ...is quite tiring <3
	[ -z "$1" ] && {
		for n in "${refalias[@]}"; do
			unset "$n"
		done
		unset refalias
		return
	}
	declare -gn "$1"="$2"
	refalias+=("$1")
}

## __ Swap variable references
function __ {
	# swap two references
	local -n _swap_1="$1"
	local _swap_copy_1="${!_swap_1}"
	local -n _swap_2="$2"
	local _swap_copy_2="${!_swap_2}"
	declare -gn "$1"="${_swap_copy_2}"
	declare -gn "$2"="${_swap_copy_1}"
}

## @fn Shorthand for one line functions
function @fn {
	[ -z "$*" ] && exit 1 # error if empty
	local name="$1"
	shift
	eval "function $name { $@; }"
}

## copy-array
# A univeral function to copy both normal and associative arrays
function copy-array {
	local -n source="$1"
	local -n target="$2"
	target=()
	for idx in "${!source[@]}"; {
		target[idx]="${source[idx]}"
	}
}

## append-array
# Append array \$1 to \$2  
function append-array {
	local -n source="$1"
	local -n target="$2"
	for idx in "${!source[@]}"; {
		target+=("${source[idx]}")
	}
}

## setface Convert colors to escape codes
# '$1' can be either one of colors:
:+     black
#     red
#     green
#     yellow
#     blue
#     magenta
#     cyan
#     ligth-gray
#     gray
#     light-red
#     light-green
#     light-yellow
#     light-blue
#     light-magenta
#     light-cyan
#     white
:- 'or hex. color (like "#bb2040")'
# 'or indexed 256 color with "c" as prefix (like c127)'
# 'for background color $mode has to be 48 and for foreground 38'
::
# If \$TERM \(current "$TERM"\) is \'linux\' \& option tty-linuxfb is 1 try to use true color even for tty
# Instead of normal '\e[$mode;r;g;bm' is used '\e]P$~1mode$Hexcode\e[$~2modem'
:+     '$mode 38 → $~1mode 2 & $~2mode 32'
#     '$mode 48 → $~1mode 1 & $~2mode 41'
:- Note that the linuxfb colors are very experimental and suffer from cursor implicitly overwriting them on movenment
function setface {
	[ -z "$1" ] && return
	case "$1" in
		black)      [ "$mode" = '38' ] && printf '\\e[30m' || printf '\\e[40m';;
		red)        [ "$mode" = '38' ] && printf '\\e[31m' || printf '\\e[41m';;
		green)      [ "$mode" = '38' ] && printf '\\e[32m' || printf '\\e[42m';;
		yellow)     [ "$mode" = '38' ] && printf '\\e[33m' || printf '\\e[43m';;
		blue)       [ "$mode" = '38' ] && printf '\\e[34m' || printf '\\e[44m';;
		magenta)    [ "$mode" = '38' ] && printf '\\e[35m' || printf '\\e[45m';;
		cyan)       [ "$mode" = '38' ] && printf '\\e[36m' || printf '\\e[46m';;
		light-gray) [ "$mode" = '38' ] && printf '\\e[37m' || printf '\\e[47m';;

		gray)          [ "$mode" = '38' ] && printf '\\e[90m' || printf '\\e[100m';;
		light-red)     [ "$mode" = '38' ] && printf '\\e[91m' || printf '\\e[101m';;
		light-green)   [ "$mode" = '38' ] && printf '\\e[92m' || printf '\\e[102m';;
		light-yellow)  [ "$mode" = '38' ] && printf '\\e[93m' || printf '\\e[103m';;
		light-blue)    [ "$mode" = '38' ] && printf '\\e[94m' || printf '\\e[104m';;
		light-magenta) [ "$mode" = '38' ] && printf '\\e[95m' || printf '\\e[105m';;
		light-cyan)    [ "$mode" = '38' ] && printf '\\e[96m' || printf '\\e[106m';;
		white)         [ "$mode" = '38' ] && printf '\\e[97m' || printf '\\e[107m';;
		*) case "${1::1}" in
			   '#')
				   if [ "$TERM" = 'linux' ] && ((options[tty-linuxfb])); then # Hack for linux framebuffer tty
					   case "$mode" in
						   38) printf '\\e]P2%s\\e[32m' "${1:1:6}" ;;
						   48) printf '\\e]P1%s\\e[41m' "${1:1:6}"
					   esac
				   else
					   local r="${1:1:2}"
					   local g="${1:3:2}"
					   local b="${1:5:2}"
					   printf '\\e[%d;2;%d;%d;%dm' "${mode}" $((16#$r)) $((16#$g)) $((16#$b))
				   fi;;
			   'c')
				   printf '\\e[%d;5;%dm' "${mode}" "${1:1}"
		   esac
	esac
	shift
	[ -n "$1" ] && "$@";
}

## :foreground
# Set foreground color.
# 'See <a> doc-goto setface : <f> link setface </f> </a> for more info.'
function :foreground { mode=38; setface "$@"; }

## :background
# Set background color.
# 'See <a> doc-goto setface : <f> link setface </f> </a> for more info.'
function :background { mode=48; setface "$@"; }

## :mode Sets text mode:
# '	inverse - inverses background and foreground'
function :mode {
	case "$1" in
		inverse) printf '\\e[7m';;
	esac
	shift
	[ -n "$1" ] && "$@";
}
	
## :weight Sets thickness of text:
:+     bold
#     dim
#     normal
function :weight {
	case "$1" in
		bold) printf '\\e[1m';;
		dim) printf '\\e[2m';;
		normal) printf '\\e[m'
	esac
	shift
	[ -n "$1" ] && "$@";
}

## :slant Sets slant of text:
:+     italic
#     normal
function :slant {
	case "$1" in
		italic) printf '\\e[3m';;
		normal) printf '\\e[m'
	esac
	shift
	[ -n "$1" ] && "$@";
}
	
## kbd Converts Emacs like key notation into hex.
function kbd {
	local -i i=0
	local out
	local in
	local -i ch=1
	# Surely there is better solution...
	case "$1" in
		C-a) printf '1 0' ;; C-b) printf '2 0' ;;
		C-c) printf '3 0' ;; C-d) printf '4 0' ;;
		C-e) printf '5 0' ;; C-f) printf '6 0' ;;
		C-g) printf '7 0' ;; C-h) printf '8 0' ;;
		C-i) printf '9 0' ;; C-j) printf 'a 0' ;;
		C-k) printf 'b 0' ;; C-l) printf 'c 0' ;;
		C-m) printf 'd 0' ;; C-n) printf 'e 0' ;;
		C-o) printf 'f 0' ;; C-p) printf '10 0';;
		C-q) printf '11 0';; C-r) printf '12 0';;
		C-s) printf '13 0';; C-t) printf '14 0';;
		C-u) printf '15 0';; C-v) printf '16 0';;
		C-w) printf '17 0';; C-x) printf '18 0';;
		C-y) printf '19 0';; C-z) printf '1a 0';;
		*)  ch=0
			case "${1:0:2}" in
				M-) in="${1:2:1}";;
				*) in="$1"
			esac
	esac
	((ch)) && return
	echo "$in" | {
		while read -rsn1; do
			out+="$(printf "%x\n" "'${in:$i}") "
			((i++))
		done
	}
	out=${out::-1}
	printf '%s' "${out}"
}

## define-key defines keybinding
:+     '$1' can be either:
#     '[function-key]'
#     '[arrow-key]'
#     '[prior | next]'
#     'RET'
#     'DEL'
#     '[delechar]'
#     'hex code ending with 0'
function define-key {
	local -n keys="keys_$1"
	case "$2" in
		#function keys
		'[f1]') keys[1b 4f 50 0]="$3";;
		'[f2]') keys[1b 4f 51 0]="$3";;
		'[f3]') keys[1b 4f 52 0]="$3";;
		'[f4]') keys[1b 4f 53 0]="$3";;
		'[f5]')  keys[1b 5b 31 35 7e 0]="$3";;
		'[f6]')  keys[1b 5b 31 37 7e 0]="$3";;
		'[f7]')  keys[1b 5b 31 38 7e 0]="$3";;
		'[f8]')  keys[1b 5b 32 39 7e 0]="$3";;
		'[f9]')  keys[1b 5b 32 30 7e 0]="$3";;
		'[f10]') keys[1b 5b 32 31 7e 0]="$3";;
		'[f11]') keys[1b 5b 32 33 7e 0]="$3";;
		'[f12]') keys[1b 5b 32 34 7e 0]="$3";;
		#arrow keys
		'[left]')  keys[1b 5b 44 0]="$3";;
		'[up]')    keys[1b 5b 41 0]="$3";;
		'[right]') keys[1b 5b 43 0]="$3";;
		'[down]')  keys[1b 5b 42 0]="$3";;
		#pg up & down
		'[prior]') keys[1b 5b 36 7e 0]="$3";;
		'[next]')  keys[1b 5b 35 7e 0]="$3";;
		#return
		'RET') keys[a 0]="$3";;
		#backspace & delete
		'DEL') keys[7f 0]="$3";;
		'[deletechar]') keys[1b 5b 33 7e 0]="$3";;
		'ESC') keys[1b 0 0]="$3";;
		'[deletechar]') keys[1b 5b 33 7e 0]="$3";;
		*) keys["$2"]="$3"
	esac
}

## local-set-key
# Sets keybinding of lastly defined mode
# See define-key for details
@fn local-set-key 'define-key "$_last_keys" "$@"'

## global-set-key
# Sets keybinding of global mode
# See define-key for details
@fn global-set-key 'define-key global "$@"'

## define-mode-option
# Sets option of mode '$1'
function define-mode-option {
	local -n ko="key_options_$1"
	ko["$2"]="$3"
}

## local-set-mode-option See define-mode-option
@fn local-set-mode-option 'define-mode-option "$_last_keys" "$@"'

## mode-options Brings mode-options of lastly defined mode into \"focus\"
@fn mode-options '_last_add="mode-options"'


## add-alias Adds alias '$1' of command '$2...' to M-x
function add-alias {
	local name="$1"
	shift
	alias["$name"]="$@"
}

## set-alias Brings into \"focus\" alias setting
@fn set-alias '_last_add=set-alias'

## add-highlight Sets highlighting mode '$1' for file types '$2...'
function add-highlight {
	local name="$1"
	shift
	for i in "$@"; {
		highlight["$i"]="$name"
	}
}

## set-alias Brings into \"focus\" highlight setting
@fn set-highlight '_last_add=set-highlight'

## clear-screen clears screen
@fn clear-screen "printf '\033c'"

## add-mode
# Adds keybing mode
function add-mode {
	log_buffer+=("        ADD MODE $1")
	_last_keys="$1"
	_last_add='add-mode'
	modes+=("keys_$1")
	declare -Ag "keys_$1"
	declare -Ag "key_options_$1"
}

## add-menu
# Adds menu
function add-menu {
	# create new menu function & array
	log_buffer+=("        ADD MENU $1")
	eval "function menu-${1} { menu $1; }"
	declare -ag "menu_${1}_0"
	declare -ag "menu_${1}_1"
	_last_menu="$1"
	_last_add='add-menu'
}

## local-set-menu Sets \"focused\" menu item
@fn local-set-menu 'define-menu "$_last_menu" "$1" "$2"'

## global-set Brings into \"focus\" global mode
@fn global-set '_last_add=global-set'

## define-option Defines options[] buffer
@fn define-option 'options["$1"]="$2"'

## set-options Brings into \"focus\" options setting
@fn set-options '_last_add=set-options'

## define-menu
# Defines item in menu '$1' with name '$2' with command '$3'
# '    If command is "menu-top_menu" face menu-back is used.'
function define-menu {
	local -n menu_0="menu_${1}_0"
	local -n menu_1="menu_${1}_1"
	local item_0
	case "$3" in
		'menu-top_menu') item_0="$(printf '%b' "${faces[menu-back]}")$2";;
		*) item_0="$2"
	esac
	menu_0+=("$item_0")
	menu_1+=("$3")
}

## load-theme Loads theme from array
function load-theme {
	local -i t=0
	local k
	local -n theme="$1"
	for i in "${theme[@]}"; {
		((t==0)) && {
			k="$i"
			t=1
		} || {
			faces["$k"]="$i"
			faces_raw["$k"]="$(printf '%b' "$i")"
			t=0
		}
	}
	((t)) && errno=1 die
	# aliases for nicer formating
	faces+=(
		[bl]="${faces[black]}"
		[dr]="${faces[red]}"
		[dg]="${faces[green]}"
		[dy]="${faces[yellow]}"
		[db]="${faces[blue]}"
		[dm]="${faces[magenta]}"
		[dc]="${faces[cyan]}"
		[dw]="${faces[light-gray]}"
		[gr]="${faces[gray]}"
		[lr]="${faces[light-red]}"
		[lg]="${faces[light-green]}"
		[ly]="${faces[light-yellow]}"
		[lb]="${faces[light-blue]}"
		[lm]="${faces[light-magenta]}"
		[lc]="${faces[light-cyan]}"
		[lw]="${faces[light-white]}"
	)
	faces_raw+=(
		[bl]="${faces_raw[black]}"
		[dr]="${faces_raw[red]}"
		[dg]="${faces_raw[green]}"
		[dy]="${faces_raw[yellow]}"
		[db]="${faces_raw[blue]}"
		[dm]="${faces_raw[magenta]}"
		[dc]="${faces_raw[cyan]}"
		[dw]="${faces_raw[light-gray]}"
		[gr]="${faces_raw[gray]}"
		[lr]="${faces_raw[light-red]}"
		[lg]="${faces_raw[light-green]}"
		[ly]="${faces_raw[light-yellow]}"
		[lb]="${faces_raw[light-blue]}"
		[lm]="${faces_raw[light-magenta]}"
		[lc]="${faces_raw[light-cyan]}"
		[lw]="${faces_raw[light-white]}"
	)
}

## extension Set properites of extension
function extension {
	log_buffer+=("- LOADING EXTENSION $1 -")
	extensions+=("$1")
	declare -Ag "${1}_ext_d"
	declare -ng ext_d="${1}_ext_d"
}
## version: Set version of extension
function version: {
	ext_d[version]="$1"
}

log_buffer+=('- LOADING BASH EXTENSIONS DONE -')

## rest of this garbageware

## refresh Refreshes buffer
# 'clears screen, reset syntax, redraws'
# 'See <a> doc-goto clear-screen : <f> link clear-screen </f> </a> for more info.'
function refresh {
	clear-screen
	bf_s=''
	
	message="reloaded..."
	redraw
}

## switch-mode
# Change current mode of buffer into '$1'
function switch-mode {
	bckmode="${bf_d[mode]}"
	bf_d[mode]="$1"
	redraw-statusline
}

## mode-back
# Restores previous mode
function mode-back {
	bf_d[mode]="$bckmode"
	unset bckmode
	redraw-statusline
}

## read-command
# Works like normal "'read'" but for bottom commanline
function read-command {
	printf '\e[%s;0H' $((bf_d[size-y] + bf_d[loc-y]))
	printf '\e[?25h'
	read -re -p "$1" -i "$3" "$2" || return 1
}

## base-name
# Basically equivalent to the "'basename'" coreutil		
function base-name
	for file in "$@"; {
		file="${file%/}"
		printf '%s\n' "${file##*/}"
	}

### TODO: make this make sense

## make-render Creates syntax highlighting for currently visible lines
function make-render {
	make-render-area "${bf_d[base]}" $((bf_d[base] + bf_d[size-y] + bf_d[loc-y]))
}

## make-render-area
# Creates syntax highlighting for lines from '$1' to '$2'
function make-render-area {
    local -i line="$1"
	local -i syntaxline=$line
	local -n linearray="${current_buffer}_syntax${syntaxline}"
	linearray=()
	bckeIFS="${IFS}"
	IFS=
	for ((l=syntaxline;l<${2};l++)); do
		((l > $2)) && break
		local -n linearray="${current_buffer}_syntax${syntaxline}"
		linearray=()
		bf_s[syntaxline]="${current_buffer}_syntax${syntaxline}"
		((syntaxline++))
		line="$l"
		make-render-line-loop
	done
	IFS="$bckeIFS"
}
	
## make-render-line
# Syntax highlights single line '$1'
# Defaults to currently selected line if no argument is passed
function make-render-line {
	local -i line=${1:-bf_d[line]}
	local -i syntaxline=$line
	local -n linearray="${current_buffer}_syntax${syntaxline}"
	bf_s[syntaxline]="${current_buffer}_syntax${syntaxline}"
	linearray=()
	bckeIFS="${IFS}"
	IFS=
	make-render-line-loop
	IFS="$bckeIFS"
}



## make-render-line-loop
# Backend for make-render-area \& make-render-line
# Also creates bf_e charmap for movenment
:+     "Tab is 't'"
#     "Space is 's'"
#     "Any unmaped char is '0'"
function make-render-line-loop {
	local -i comment=0
	local -i skip_next_space=0
	local word=''
	bf_e[line]=''

	for _link in ${bf_c[line]}; do
		unset "$_link"
	done
	unset bf_c[line]
		
	column=0
	while read -rsn1 char; do	
		case "$char" in
			' ')
				syntax-word
				word=''
				((skip_next_space==1)) && skip_next_space=0 && continue
				bf_e[line]+='s'
				face-no-expand "${facename:-${bf_d[background]:-default}}" ' '
				((column++));;
			'	')
				syntax-word
				word=''
				local -i i
				for ((i = ${#options[tabchar]}; i > 0 ; i--)); do
					bf_e[line]+="${charmap[	]}"
				done
				face-no-expand tab-face "${options[tabchar]}"
				((column+=${#options[tabchar]}));;
			'')
				syntax-word
				word=''
				skip_next_space=0
				face-no-expand "${bf_d[background]:-default}" ' '
				newline=1 # tell syntax functions that the previous char was newline # used for format thing
				return;;
			*)
				word+="${char}"
		esac
	done  <<< "${buffer[line]}"
}

## syntax-word
# Decides what a word should highlighted as:
:+     'If todonote option is enabled, highlight "NOTE:" & "TODO:"'
#     'If the word is supposed to be comment highlight it as it'
#     'Else pass it to current syntax function'
function syntax-word {
	(("${options[todonote]}"==1)) && {
		case "$word" in
			'NOTE:') face NOTE "${word}"; return ;;
			'TODO:') face TODO "${word}"; return ;;
		esac
	}
	((comment)) && set-face font-lock-comment-face ||
		"${bf_d[syntax]}"
	((bf_d[syntax-exec])) || face "$syntax_face" "$word" # s_ex controls syntax extended
}

## face
# Add highlighted word to multidimensional nonsense "'bf_s'" arry
function face {
	IFS=' '
	[[ "$2" =~ ${2//?/(.)} ]]
	linearray+=("${faces_raw[reset]}${faces_raw[${1}]}${BASH_REMATCH[@]:1}")
	IFS=''
	for ((iw=0; iw < ${#2}; iw++)); do
		bf_e[line]+='0'
	done
}

## face-no-expand
# Add highlighted word to multidimensional nonsense "'bf_s'" arry without adding anything to bf_e[] array
function face-no-expand {
	IFS=' '
	[[ "$2" =~ ${2//?/(.)} ]]
	linearray+=("${faces_raw[reset]}${faces_raw[${1}]}${BASH_REMATCH[@]:1}")
	IFS=''
}

## set-face Sets face for syntax highlighting
@fn set-face 'syntax_face="$1"'

## size-full
# Sets size of buffer to be fullscreen
function size-full {
	bf_d+=(
		[loc-x]=1
		[loc-y]=1
		[size-x]=$COLUMNS
		[size-y]=$((LINES - 1))
	)
}

## set-buffer
# Switch to buffer \$1 
function set-buffer {
	log info "switch to buffer [$1]"
	current_buffer="$1"
	declare -ng buffer="${current_buffer}_buffer"
	declare -ng bf_s="${current_buffer}_bf_s"
	declare -ng bf_e="${current_buffer}_bf_e"
	declare -ng bf_d="${current_buffer}_bf_d"
	declare -ng bf_c="${current_buffer}_bf_c"
}

## add-to-list
# Adds a buffer into currently active buffer list
function add-to-list {
	log info "added into buffer list: $current_buffer"
	buffers_l+=("$current_buffer")
}

## clear-buffer
# Empties buffer bf_s bf_e \& bf_d
function clear-buffer {
	buffer=()
	for l in "${bf_s[@]}"; {
		unset "$l"
	}
	bf_s=()
	bf_e=()
	for l in "${bf_c[@]}"; {
		unset "$l"
	}
	bf_c=()
}

## list-directory
# Basically like ls command 
function list-directory {
	((hidden==1)) && shopt -s dotglob
	((hidden==0)) && shopt -u dotglob
	printf '..\n'
	printf '%s\n' *
}

## current-time
# Basically like coreutil "'date'"
@fn current-time 'printf "%($1)T\\n"'

## log
# Adds message into log
# '    info -- everything *should* be well'
# '    warn -- something is wrong but it *should* not break entire Ebashs'
# '    error -- something is wrong and anything can break, but it *can* still run(?)'
# '    fatal -- something is mega wrong and only thing left to do is to die'
# Is disabled when log wasn\'t initialised, see init-log for info
function log {
	((log)) || return
	local type="$1"
	shift
	tooktime="$(( $(current-time '%s') - lasttime ))"
	bufferlog+=("<f> title [$type] </f> <f> font-lock-comment-face ${tooktime}s </f> <f> name [${FUNCNAME[1]}] </f> $*")
	lasttime="$(current-time '%s')"
}

## log-echo
# Adds message into log without any special formating	
function log-echo {
	((log)) || return
	bufferlog+=("<f> font-lock-comment-face > </f>    $*")
}

## debug
# +debug -- basically like set -x but reports stuff into log
## +log	
# Debug function to add logging to function it\'s called from
function +log {
	((log)) || return
	((options[log-functions])) && log '*' "${FUNCNAME[1]}"
	trap 'log bash $? $LINENO ${BASH_COMMAND}' ERR
}
## +debug
# Debug function to add extensive \(set -x like\) logging to function it\'s called from
function +debug {
	((log)) || return
	trap 'log DEBUG "${BASH_COMMAND}"' DEBUG
}

## goto Load array into buffer
function goto {
	clear-buffer
	bf_d[line]=1
	bf_d[column]=0
	copy-array "$1" buffer
	redraw
}

@doc syntax-format <<'EOF'
Convert formated text into Ebashs buffer understandable format.

<f> title <u> Specifications </u> </f>

<[> name <f> <f> hint face_name text... </f> <[> name </f>
<-> Set <f> hint text </f> to face <f> hint face_name </f-> .

<[> name <h> <f> hint text... </f> <[> name </h>
<-> Make <f> hint text </f> into title.

<[> name <a> <f> hint command </f> <[> name : <f> hint text </f> <[> name </a>
<-> Create clickable area that executes <f> hint command </f> on click and is labeled <f> hint text </f-> .
<-> See <a> doc-goto link-enter : <f> link link-enter </f> </a> 

<[> name <link> <f> hint command </f> <[> name : <f> hint text </f> <[> name </link>
<-> Create clickable area that executes <f> hint command </f> on click and is labeled <f> hint text </f-> .
<-> <[> name <link> also automatically adds <f> link link </f> face to text.

<[> name <u> <f> hint text </f> <[> name </u>
<-> Make <f> hint text </f> <u> uppercase. </u>

<[> name <i> <f> hint number_of_spaces hint text </f-> ...\n...\n...\n... <[> name </i>
<i-tab> Indent lines by <f> hint number of spaces </f-> .

<[> name <i-tab>
<-> Indent by tab (default 4 spaces).
<-> Tab size is controlled via tab_format variable. </i>

<[> name <s> <f> hint number_of_spaces </f>
<-> Insert <f> hint number of spaces </f-> .

<[> name <tab>
<-> Insert tab.
<-> <[> name <-> is alias for <[> name <tab>.

<[> name <v> <f> hint variable_name </f> <[> name </v>
<-> Insert contents of <f> hint variable </f> into text at formating time.

<[> name <\> <f> hint text </f>
<-> Escape <f> hint text </f>

<[> name <[> <f> hint face_name text </f>
<-> Escape <f> hint text </f> with <f> hint face </f-> .


Some of these keywords also include versions to glue together with other words.
For example:
<-> text <[> name <-f> <f> name face </f> color! <[> name </f-> text
Will turn into text <-f> lr c <-f> ly o <-f> lg l <-f> lc o <-f> lb r <-f> lm ! </f> </f> </f> </f> </f> </f-> text.
EOF
function syntax-format {
	((skip_word==1)) && {
		skip_next_space=1
		[ "$word" = '-->' ] && skip_word=0
		return
	}
	[ "$word" = '<!--' ] && {
		skip_next_space=1
		skip_word=1
		return
	}
	((newline==1)) && {
		ichar="${indent_spaces}"
	}
	((newline==0)) && {
		ichar=
	}

	((escape==2)) && {
		escape=1
		facename="$word"
		skip_next_space=1
		return
	}
	((escape==1)) && {
		escape=0
		face "$facename" "${ichar}$word"
		return
	}
	[ "$word" = '<\>' ] && {
		escape=1
		skip_next_space=1
		facename='unknown'
		return
	}
	[ "$word" = '<[>' ] && {
		escape=2
		skip_next_space=1
		return
	}
	
	((variable==1)) && {
		variable=0
		word="${!word}"
	}
	[ "$word" = '<v>' ] && {
		variable=1
		varname=
		skip_next_space=1
		return
	}

	[ "$word" = '</u>' ] && {
		upper=0
		skip_next_space=1
		return
	}
	[ "$word" = '<u>' ] && {
		upper=1
		skip_next_space=1
		return
	}
	[ "$word" = '</f>' ] && {
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		((column--))
		unset facename
		[ -n "$bckfacename" ] && {
			facename="$bckfacename"
			unset bckfacename
		}
		return
	}
	[ "$word" = '</f->' ] && {
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		((column--))
		skip_next_space=1
		[ -n "$bckfacename" ] && {
			facename="$bckfacename"
			unset bckfacename
		}
		return
	}
	((facedef==1)) && {
		skip_next_space=1
		facedef=0
		facename="$word"
		return
	}
	[ "$word" = '<f>' ] && {
		bckfacename="$facename"
		skip_next_space=1
		facedef=1
		return
	}
	[ "$word" = '<-f>' ] && {
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		((column--))
		bckfacename="$facename"
		skip_next_space=1
		facedef=1
		return
	}
	
	[ "$word" = '</h>' ] && {
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		((column--))
		unset facename
		upper=0
		[ -n "$bckfacename" ] && {
			facename="$bckfacename"
			unset bckfacename
		}
		return
	}
	[ "$word" = '<h>' ] && {
		bckfacename="$facename"
		skip_next_space=1
		facename=title
		upper=1
		return
	}
	
	((sethighlight==2)) && {
		sethighlight=1
		skip_next_space=1
		tmp_sex="$word"
		return
	}
	((sethighlight==1)) && {
		sethighlight=0
		skip_next_space=1
		bf_d[syntax-exec]="$tmp_sex"
		bf_d[syntax]="syntax-$word"
		return
	}
	[ "$word" = '<change-syntax>' ] && {
		skip_next_space=1
		sethighlight=2
		return
	}
	((space_next==1)) && {
		space_next=0
		skip_next_space=1
		for ((if=0; if< word; if++)) {
			linearray+=(' ')
			bf_e[line]+='s'
			((column++))
		}
		return
	}
	[ "$word" = '<s>' ] && {
		space_next=1
		skip_next_space=1
		return
	}
	[ "$word" = '<tab>' ] || [ "$word" = '<->' ] && {
		skip_next_space=1
		for ((if=0; if< format_tab; if++)) {
			linearray+=(' ')
			bf_e[line]+='s'
			((column++))
		}
		return
	}
	[ "$word" = '</i>' ] && {
		indent_spaces=
		return
	}
	((indent==1)) && {
		indent=0
		skip_next_space=1
		indent_spaces=
		indent_spaces_e=
		for ((if=0; if< word; if++)) {
			indent_spaces+=' '
			indent_spaces_e+='s'
		}
		return
	}
	[ "$word" = '<i>' ] && {
		indent=1
		skip_next_space=1
		return
	}
	[ "$word" = '<i-tab>' ] && {
		skip_next_space=1
		indent_spaces=
		indent_spaces_e=
		for ((if=0; if< format_tab; if++)) {
			indent_spaces+=' '
			indent_spaces_e+='s'
		}
		return
	}
	((link==2)) && {
		[ "$word" = ':' ] && {
			((
				skip_next_space=1,
				link=1
			))
			return
		}
		skip_next_space=1
		linkfn+="$word "
		return
	}
	[ "$word" = '</a>' ] && {
		((lc++))
		((column--))
		link=0
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		bf_c[line]+="bf_c_${lc}_${current_buffer} "
		declare -Ag "bf_c_${lc}_${current_buffer}"
		local -n bf_c_line="bf_c_${lc}_${current_buffer}"
		bf_c_line=(
			[start]="$lsx"
			[end]=$((column - 1))
			[exec]="$linkfn"
		)
		return
	}
	[ "$word" = '<a>' ] && {
		((
			link=2,
			lsx=column,
			skip_next_space=1
		))
		linkfn=
		return
	}
	((facelink==2)) && {
		[ "$word" = ':' ] && {
			((
				skip_next_space=1,
				facelink=1
			))
			facename='link'
			return
		}
		skip_next_space=1
		linkfn+="$word "
		return
	}
	[ "$word" = '</link>' ] && {
		((lc++))
		((column--))
		facelink=0
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		bf_c[line]+="bf_c_${lc}_${current_buffer} "
		declare -Ag "bf_c_${lc}_${current_buffer}"
		local -n bf_c_line="bf_c_${lc}_${current_buffer}"
		bf_c_line=(
			[start]="$lsx"
			[end]=$((column - 1))
			[exec]="$linkfn"
		)
		unset facename
		[ -n "$bckfacename" ] && {
			facename="$bckfacename"
			unset bckfacename
		}
		return
	}
	[ "$word" = '<link>' ] && {
		((
			facelink=2,
			lsx=column,
			skip_next_space=1
		))
		linkfn=
		return
	}
	
	((object==1)) && {
		skip_next_space=1
		[ "$word" = 'text:' ] && {
			object=0
			set_obj=0
			return
		}
		[ "$word" = 'select:' ] && { set_obj=1; obj_select=; return; }
		[ "$word" = 'id:' ] && { set_obj=2; obj_id=; return; }
		[ "$word" = 'left:' ] && { set_obj=3; obj_left=; return; }
		[ "$word" = 'up:' ] && { set_obj=4; obj_up=; return; }
		[ "$word" = 'right:' ] && { set_obj=5; obj_right=; return; }
		[ "$word" = 'down:' ] && { set_obj=6; obj_down=; return; }

		((set_obj==1)) && obj_select+="$word "
		((set_obj==2)) && obj_id+="$word "
		((set_obj==3)) && obj_left+="$word "
		((set_obj==4)) && obj_up+="$word "
		((set_obj==5)) && obj_right+="$word "
		((set_obj==6)) && obj_down+="$word "
		return
	}
	[ "$word" = '</o>' ] && {
		((lc++))
		((column--))
		link=0
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		bf_c[line]+="bf_c_${lc}_${current_buffer} "
		declare -Ag "bf_c_${lc}_${current_buffer}"
		local -n bf_c_line="bf_c_${lc}_${current_buffer}"
		bf_c_line=(
			[start]="$lsx"
			[end]=$((column - 1))
			[exec]="$obj_select"
			[id]="$obj_id"
			[left]="$obj_left"
			[up]="$obj_up"
			[right]="$obj_right"
			[down]="$obj_down"
		)
		return
	}
	[ "$word" = '<o>' ] && {
		((
			object=1,
			lsx=column,
			skip_next_space=1
		))
		obj_id=
		obj_text=
		obj_select='true'
		obj_left='backward-char'
		obj_up='previous-line'
		obj_right='forward-char'
		obj_down='next-line'
		set_obj=0
		return
	}
	
	((newline==1)) && newline=0
	((column+=${#ichar} + ${#word}))
	((upper==1)) && {
		word="${word^^}"
	}
	face "${facename:-unknown}" "${ichar}$word"
}

@doc link-enter <<'EOF'
Executes <f> name clickable area </f> of formated text to which current position
of cursor points.
Mostly used for <f> name hyperlinks </f-> .

Internally <f> name clickable area </f> is defined via bf_c 2d array. Each line contains
the <f> name clickable areas </f-> . Each of these is it's own associative array.
Each <f> name clickable area </f> contains:
<i-tab> <[> hint start - the first column of the area
<[> hint end   - the last column of the area
<[> hint exec  - what command should be executed when this function,
<-> <f> name link-enter </f> is ran. </i>
EOF
function link-enter {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"
		#echo "    $link" >> d
		#echo "${bf_c_line[start]}" >> d
		#echo "${bf_c_line[end]}" >> d
		#echo "${bf_c_line[exec]}" >> d
		
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				has=1
				${bf_c_line[exec]}
				return
			}
	}
	${bf_d[format-else]}
}

function format-left {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				${bf_c_line[left]:-backward-char}
				return
			}
	}
	backward-char
}
function format-up {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				${bf_c_line[up]:-previous-line}
				return
			}
	}
	previous-line
}
function format-right {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				${bf_c_line[right]:-forward-char}
				return
			}
	}
	forward-char
}
function format-down {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				${bf_c_line[down]:-next-line}
				return
			}
	}
	next-line
}

function obj {
	for y in "${!bf_c[@]}"; {
		for obj in ${bf_c[y]}; {
			local -n bf_c_line="$obj"
			[ "${bf_c_line[id]}" = "$1 " ] && {
				((bf_d[line]=y, bf_d[column]=bf_c_line[start]))
				redraw-cursor
			}
		}
	}
}
	
@fn is-function 'declare -F -- "$1" > /dev/null'

## Dumps current buffer into a file	
function dump-buffer {
	true >"$1" # Set the file to an empty text file
	for ln in "${buffer[@]}"; do # Write in the buffer to the file
		echo "$ln" >>"$1"
	done
}

## die
# Closes Ebashs with exit code \$errno, if errno is empty exit with 0
# If \$nocleanup is 1, do not restore the terminal to sane mode and do not cleanup 
# Else restore to sane mode 
function die {
	((nocleanup)) && exit "${errno:-0}"
	${on_die:-true}
	echo -e "\e[?1000;1006;1015l" #disable mouse tracking
	clear-screen # TODO fix the buffer switching
	printf '\e[?25h\e[?7h\e[?1049l' # Reset terminal to sane mode
	exit "${errno:-0}" # Assume that we are exiting without an error
}

# Sets \$nocleanup to 1 and dies	
function abort {
	((nocleanup=1)) && die "$@"
}

fragment keepcolumn <<'+'
	[ -z "$bckrl" ] && bckrl="${bf_d[column]}"	
	(( ${#bf_e[bf_d[line]]} < bf_d[column] )) && bf_d[column]=${#bf_e[bf_d[line]]}
	(( ${#bf_e[bf_d[line]]} > bckrl )) && bf_d[column]=${bckrl}
+

# Moves up \$1 lines, if \$ is empty move up 1 line
function move-previous-line {
	for ((i = 0; i < ${1:-1}; i++)); do
		((bf_d[line] > 1)) && ((bf_d[line]--)) # As long as we can keep going up, go up
		((bf_d[line] < bf_d[base] + 1)) && {
			((bf_d[base]--)) # Push back the top if we need to
			move_base=1 # Send signal to redraw-cursor that the buffer was moved, thus needs to be redraw fully
			((bf_d[base] <= 0)) && bf_d[base]=1 # Don't push back if our base is at 1
		}
		[ -z "$bckrl" ] && bckrl="${bf_d[column]}"	
		(( ${#bf_e[bf_d[line]]} < bf_d[column] )) && bf_d[column]=${#bf_e[bf_d[line]]}
		(( ${#bf_e[bf_d[line]]} > bckrl )) && bf_d[column]=${bckrl}
	done
}

# Moves down \$1 lines, if \$ is empty move down 1 line
function move-next-line {
	for ((i = 0; i < ${1:-1}; i++)); do
		((bf_d[line] < ${#buffer[@]}+1)) && ((bf_d[line]++)) # If we can go down, go down
		# Move window down if needed
		((bf_d[line] > bf_d[base] + bf_d[size-y] - 3 - bottomlines)) && {
			((bf_d[base]++))
			move_base=1
		}
		[ -z "$bckrl" ] && bckrl="${bf_d[column]}"	
		(( ${#bf_e[bf_d[line]]} < bf_d[column] )) && bf_d[column]=${#bf_e[bf_d[line]]}
		(( ${#bf_e[bf_d[line]]} > bckrl )) && bf_d[column]=${bckrl}
	done
}

function previous-line {
	move-previous-line "$@"
	redraw-statusline
	if ((bf_d[selection])); then
		redraw
	else
		redraw-cursor
	fi
}
function next-line {
	move-next-line "$@"
	redraw-statusline
	if ((bf_d[selection])); then
		redraw
	else
		redraw-cursor
	fi
}
function scroll-down {
	move-previous-line $((bf_d[size-y] - 3))
	redraw-statusline
	if ((bf_d[selection])); then
		redraw
	else
		redraw-cursor
	fi
}
function scroll-up {
	move-next-line $((bf_d[size-y] - 3))
	redraw-statusline
	if ((bf_d[selection])); then
		redraw
	else
		redraw-cursor
	fi
}
	
@fn move-beginning-of-line 'bf_d[column]=0; redraw'
@fn move-end-of-line 'bf_d[column]="${#bf_e[${bf_d[line]}]}"; redraw'


function move-select {
	((bf_d[selection])) || {
		bf_d[selection_start_y]="${bf_d[line]}"
		bf_d[selection_start_x]="${bf_d[column]}"
		bf_d[selection]=1
	}
}

function select-forward {
	move-select
	forward-char
}
function select-backward {
	move-select
	backward-char
}
function select-next {
	move-select
	next-line
}
function select-previous {
	move-select
	previous-line
}

function forward-char {
	for ((i = 0; i < ${1:-1}; i++)); do
		case "${bf_e[${bf_d[line]}]:${bf_d[column]}+1:1}" in
			't') bf_d[column]=$(( bf_d[column]+${#options[tabchar]}));;
			*) ((bf_d[column]++));;
		esac
		((bf_d[column] > ${#bf_e[${bf_d[line]}]})) && {
			bf_d[column]=0
			next-line
			return
		}
		bckrl=
	done
	if ((bf_d[selection])); then
		redraw
	else
		redraw-cursor-line
	fi
}

function backward-char {
	for ((i = 0; i < ${1:-1}; i++)); do
		case "${bf_e[${bf_d[line]}]:${bf_d[column]}-1:1}" in
			't') bf_d[column]=$(( bf_d[column]-${#options[tabchar]}));;
			*) ((bf_d[column]--));;
		esac
		((bf_d[column] < 0)) && ((bf_d[line]==1)) && {
			bf_d[line]=1
			bf_d[column]=0
		}
		((bf_d[column] < 0)) && {
			bf_d[column]="${#bf_e[${bf_d[line]}-1]}"
			previous-line
			return
		}
		bckrl=
	done
	if ((bf_d[selection])); then
		redraw
	else
		redraw-cursor-line
	fi
}
	
## forward-word
# Moves forward to next word
function forward-word {
	((bf_d[column] == ${#bf_e[bf_d[line]]})) && {
		next-line
		move-beginning-of-line
	}
	while :; do
		((bf_d[column] < ${#bf_e[bf_d[line]]})) && ((bf_d[column]++)) || break
		case "${bf_e[bf_d[line]]:${bf_d[column]}:1}" in
			't'|'s') break
		esac
	done
	redraw
}

## backward-word
# Moves backward to previous word
function backward-word {
	((bf_d[column] == 0)) && {
		previous-line
		move-end-of-line
	}
	while :; do
		((bf_d[column] > 0)) && ((bf_d[column]--)) || break
		case "${bf_e[bf_d[line]]:${bf_d[column]}:1}" in
			't'|'s') break
		esac
	done
	redraw
}


@doc to-line <<'+'
Move cursor to line number $1 and move the line into middle of visible buffer area.
+
function to-line {
	bf_d[line]="$1"
	bf_d[base]=$((bf_d[line] - bf_d[size-y] / 2 ))
	redraw
}
			
# Handle clicking on top menu with mouse		
function menuline-mouse {
	local -n top_0="menu_${bf_d[menuline]}_0"
	local -n top_1="menu_${bf_d[menuline]}_1"
	#determine which item should be triggered
	[ -z "$1" ] && menuloc_x=0 || menuloc_x=$1
	local cx="${bf_d[loc-x]}"
	i=0
	for i in "${!top_0[@]}"; {
		la="${#top_0[i]}"
		((menuloc_x>cx)) && ((menuloc_x<(cx + la + 1))) && {
			${top_1[$i]}
			return
		}
		cx=$(( cx + la + 1 ))
	}
}
# Redraw popup menu
function redraw-menu {
	printf '\e[?25l' # hide cursor (again)
	printf '\e[%s;0H' $menuloc_y
	for i in "${!menu_0[@]}"; {
		if ((i == menuselection)); then
			printf "\e[%sC${faces[menu-selected-face]}%s${reset}\n" $menuloc_x "${menu_0[i]}"  
		else
	   		printf "\e[%sC${faces[menu-enabled-face]}%s${reset}\n" $menuloc_x "${menu_0[i]}"
		fi
	}
}


function menuup {
	((menuselection > 0)) && ((menuselection--));
	redraw-menu;
}
function menudown {
	((menuselection < ${#menu_0[@]} -1)) && ((menuselection++));
	redraw-menu;
}

# Execute selected item in menu
function menuselect
for i in "${!menu_1[@]}"; {
	((i == menuselection)) && "${menu_1[i]}"
}

# Closes a menu
function menuleave {
	ismenu=0
	bf_d[mode]="${modebackup}"
	redraw
}

# Opens a menu \$1	
function menu {
	declare -ng menu_0=menu_${1}_0
	declare -ng menu_1=menu_${1}_1
	((ismenu == 0 )) && modebackup="${bf_d[mode]}"
	ismenu=1
	declare -ig menuselection=0
	bf_d[mode]='menu'
	redraw
}

# deletes current buffer
function delete-buffer {
	local -a copy
	local i=0
	local index
	for b in "${buffers_l[@]}"
	do
		[[ "$b" != "$current_buffer"  ]] && copy+=("$b")
		[[ "$b" = "$current_buffer"  ]] && index="$i"
		((i++))
	done
	unset buffers_l
	copy-array copy buffers_l
	current_buffer="${buffers_l[index-1]}"
	redraw
}
						
# Draw multiline region
function selection-draw
if ((i == bf_d["${1}_y"])); then
	printf "${ln}%*s\e[%sG%b%s%b%s%b%b"\
		   ${lnargs[@]}\
		   $((bf_d[size-x] - bf_d[number-length]))\
		   ''\
		   $((bf_d[loc-x] + bf_d[number-length] + space))\
		   "${faces[default]}"\
		   "${linearray[*]:bf_d[basecolumn]:bf_d[${1}_x]}"\
		   "\e[m${faces[region]}"\
		   "${buffer[i]:bf_d[${1}_x]:bf_d[size-x] - (bf_d[number-length] + 1)}"\
		   "${faces[default]}" "$nlchar"
elif ((i == bf_d["${2}_y"])); then
	printf "${ln}%*s\e[%sG%b%b%s%b%s%b%b"\
		   ${lnargs[@]}\
		   $((bf_d[size-x] - bf_d[number-length]))\
		   ''\
		   $((bf_d[loc-x] + bf_d[number-length] + space))\
		   "${faces[default]}"\
		   "${faces[region]}"\
		   "${buffer[i]:bf_d[basecolumn]:bf_d[${2}_x]}"\
		   "\e[m"\
		   "${linearray[*]:bf_d[${2}_x]:bf_d[size-x]}"\
		   "${faces[default]}" "$nlchar"
else
	printf "${ln}%*s\e[%sG%b%b%s%b%b"\
		   ${lnargs[@]}\
		   $((bf_d[size-x] - bf_d[number-length]))\
		   ''\
		   $((bf_d[loc-x] + bf_d[number-length] + space))\
		   "${faces[default]}"\
		   "${faces[region]}" "${buffer[i]:bf_d[basecolumn]:bf_d[size-x] - (bf_d[number-length] + 1)}"\
		   "${faces[default]}" "$nlchar"
fi

# Handle changing size of terminal
function change-size-screen {
	bf_d[size-x]="$COLUMNS"
	bf_d[size-y]=$((LINES-1))
	redraw
}
	
## redraw
# Redraw screen
function redraw {
	[ -n "${bf_d[redraw]}" ] && {
		"${bf_d[redraw]}" "$@"
		return
	}
	printf '\e[?25l'

	# the first line should be always empty 
	unset buffer[0]
	
	# Handle changing size of buffer
	((bf_d[size-x]!=bcksize_x)) || ((bf_d[size-y]!=bcksize_y)) && {
		# Make the statusline full of dashes
		dashline=$(
			for ((i=0; i<bf_d[size-x]; i++)) {
				printf '-'
			}
		)
		bcksize_x=${bf_d[size-x]}
		bcksize_y=${bf_d[size-y]}
	}
		
	# Get length of line-number of lines
	bf_d[length]="${#buffer[@]}"
	((bf_d[length]==0)) &&((bf_d[length]++))
	
	((options[line-number-mode])) && {
		bf_d[number-length]=${#bf_d[length]}
		bf_d[number-space]=1
	} || ((bf_d[number-length]=0, bf_d[number-space]=0))
	
	# Update selection ends to current cursor
	((bf_d[selection]==1)) &&
		((bf_d[selection_end_y]=bf_d[line], bf_d[selection_end_x]=bf_d[column]))
	
	# Move the buffer horizontally if needed
	((bf_d[column] +3 < bf_d[size-x] - bf_d[number-length] - 1)) &&
		bf_d[basecolumn]=0
	((bf_d[column] +3 > bf_d[size-x] - bf_d[number-length] - 1)) &&
		bf_d[basecolumn]=$((bf_d[column] - (bf_d[size-x] + bf_d[loc-x] - bf_d[number-length] - 1) +3))

	# Draw top menuline
	(("${options[menu-line]}"==1)) && {
		"${bf_d[menuline-function]:-redraw-menuline}"
	} || printf "\e[%s;%sH" "${bf_d[loc-y]}" "${bf_d[loc-x]}"

	# IFS has to be empty in order to bufferarray multiarray be printed as words instead of chars
	IFS=''

	# Handle line number displaying
	# the resulting line has to be printed in one go to prevent flicker
	# space stores if the position of actuall text should be offset by +1
	# ln stores printf print line
	# args stores printf arguments
	local -i space
	local ln
	local -a lnargs
	
	# Iterate over shown lines
	local -i max=$((bf_d[size-y] - (toplines + bottomlines) + 1))
	for ((i = bf_d[base]; i - bf_d[base] < max; i++)); do
	# if the line is last, do not add newline

		ln="\e[%dG"
		lnargs=(
			"${bf_d[loc-x]}"
		)
		if ((options[line-number-mode])); then
			space=1
			ln="\e[%dG%b%*s"
			lnargs=(
				"${bf_d[loc-x]}"
				"${faces[line-number]}"
				"${bf_d[number-length]}"
				"$i"
			)
			((i == bf_d[line])) && lnargs[1]="${faces[line-number-current-line]}"
		fi
		
		((i - bf_d[base] > max - 2)) && nlchar='' || nlchar='\n'

		((i > ${#buffer[@]})) &&
			printf '\e[%sG%b%*s%s%b%*s%b'\
				   "${bf_d[loc-x]}"\
				   "${faces[line-number-empty]}"\
				   $((bf_d[number-length]/2)) ''\
				   "${options[empty-line-char]}"\
				   "${faces[default]}"\
				   $((bf_d[size-x] - bf_d[number-length]))\
				   ''\
				   "$nlchar" &&
			continue
		
		# to improve speed syntaxing has to be "lazy" -- having to be heavily cached as ram is far less expensive to waste
		[ -z "${bf_s[base+i]}" ] && {
			make-render-line $((base + i))
		}
		local -n linearray="${bf_s[i]}"
		
		# draw the selection area
		((bf_d[selection])) && {
			((i == bf_d[selection_start_y])) &&
				((bf_d[selection_start_y] == bf_d[selection_end_y])) && {
					((bf_d[selection_start_x] <= bf_d[selection_end_x])) && {
						local -n sx=bf_d[selection_start_x]
						local -n ex=bf_d[selection_end_x]
					} || {
						local -n sx=bf_d[selection_end_x]
						local -n ex=bf_d[selection_start_x]
					}
					printf "${ln}%*s\e[%sG%b%s%b%s%b%s%b"\
						   ${lnargs[@]}\
						   $((bf_d[size-x] - bf_d[number-length]))\
						   ''\
						   $((bf_d[loc-x] + bf_d[number-length] + space))\
						   "${faces[default]}"\
						   "${linearray[*]:bf_d[basecolumn]:sx}"\
						   "\e[m${faces[region]}"\
						   "${buffer[i]:sx:ex-sx}"\
						   "\e[m"\
						   "${linearray[*]:ex:bf_d[size-x]}"\
						   "$nlchar"
					continue
				}
			((i >= bf_d[selection_start_y])) && ((i <= bf_d[selection_end_y])) && {
				selection-draw selection_start selection_end
				continue
			}
			((i <= bf_d[selection_start_y])) && ((i >= bf_d[selection_end_y])) && {
				selection-draw selection_end selection_start
				continue
			}
		}
		# due to escape codes present in bf_s,
		# the bf_s has to be multidimensional nonsense for perfomance reasons
		printf "${ln}%b%*s\e[%sG%b%s\e[m%b"\
			   ${lnargs[@]}\
			   "${faces[${bf_d[background]:-default}]}"\
			   $((bf_d[size-x] - bf_d[number-length]))\
			   ''\
			   $((bf_d[loc-x] + bf_d[number-length] + space))\
			   "${faces[${bf_d[background]:-default}]}"\
			   "${linearray[*]:bf_d[basecolumn]:bf_d[size-x] - (bf_d[number-length])}"\
			   "$nlchar"
	done
	redraw-statusline
	redraw-commandline
	((no_cursor)) || redraw-cursor		
	@ifs		
	# redraw menu if open
	[ "${bf_d[mode]}" = 'menu' ] && redraw-menu
}

## print-buffer-line
function print-buffer-line {
	IFS=''
	local -n linearray="${bf_s[bf_d[line]]}"
	printf '%s' "${linearray[*]:bf_d[basecolumn]:bf_d[size-x] - (bf_d[number-length])}"
	@ifs
}

## redraw-menuline Redraws top menu line
function redraw-menuline {
	local -n top_0="menu_${bf_d[menuline]}_0"
	printf "\e[0m\e[%s;%sH${faces[menu]}\e[?25l%*s\r%s"\
		   "${bf_d[loc-y]}"\
		   "${bf_d[loc-x]}"\
		   "${bf_d[size-x]}"\
		   "${bf_d[info]}"
	printf '\e[%sG%s\e[0m\n' "${bf_d[loc-x]}" "${top_0[*]}"
}

# Draw cursor on the line
function redraw-cursor-line {
	((options[full-redraw]==0)) && {
		# redraw if buffer needs to be moved horizontally
		((bf_d[column] > bf_d[size-x] - bf_d[number-lenght] - space)) && {
			redraw
			return
		}
		((bf_d[basecolumn]==0)) || {
			redraw
			return
		}
		printf '\e[%sG\e[?25h'\
			   $((bf_d[column] - bf_d[basecolumn] + bf_d[number-length] + bf_d[loc-x] + bf_d[number-space])) ||
			redraw
	}
}
	
# Draw cursor and if move_base is 1 redraw
function redraw-cursor {
	((options[full-redraw])) && {
		no_cursor=1
		redraw
		no_cursor=0
	}
	((move_base)) && {
		move_base=0
		redraw
		return
	}
	local -i y=$((bf_d[line] + options[menu-line] - bf_d[base] + bf_d[loc-y]))
	((options[line-number-mode])) && {
		printf '\e[%s;%sH%b%*s\e[m'\
			   $((last_line + options[menu-line] - bf_d[base] + bf_d[loc-y]))\
			   "${bf_d[loc-x]}"\
			   "${faces[line-number]}"\
			   ${bf_d[number-length]}\
			   $last_line
		printf '\e[%s;%sH%b%*s\e[m'\
			   $y\
			   "${bf_d[loc-x]}"\
			   "${faces[line-number-current-line]}"\
			   ${bf_d[number-length]}\
			   ${bf_d[line]}
	}
	printf '\e[%s;%sH\e[?25h'\
		   $y\
		   $((bf_d[column] - bf_d[basecolumn] + bf_d[number-length] + bf_d[loc-x] + bf_d[number-space]))
	last_line=${bf_d[line]}
}

# Draw bottom mode/status line
function redraw-statusline {
	((options[mode-line])) &&
		printf "\e[%s;%sH\e[%sG%b%s\e[%sG%s %b%s\e[m%b %d%% (%d,%d) (%s[%s]) (screen: %s) \e[m" \
			   $((bf_d[size-y] - 1 + bf_d[loc-y]))\
			   $((bf_d[size-x] + bf_d[loc-x]))\
			   "${bf_d[loc-x]}"\
			   "${faces[mode-line]}"\
			   "$dashline"\
			   "${bf_d[loc-x]}" \
			   "${bf_d[mode]}"\
			   "${faces[file-name]}"\
			   "$(base-name "${bf_d[file]}")"\
			   "${faces[mode-line]}"\
			   $((100 * bf_d[line] / bf_d[length]))\
			   "${bf_d[line]}"\
			   "${bf_d[column]}"\
			   "${highlight[${bf_d[filetype]}]}"\
			   "${bf_d[filetype]}"\
			   "$current_buffer"
}

# Draw bottomest command line message echo area
function redraw-commandline {
	# clear message if it has been printed before already
	((options[keep-message]==0)) && 
		((clrmsg)) && {
			message=
			clrmsg=0
		} || clrmsg=1
	if ((options[command-line])); then
		printf "\e[%s;%sH\n${faces[minibuffer-prompt]}%*s\r%s\e[m" \
			   $((LINES-1)) 1 $((COLUMNS)) ' ' "$message"
	else
		[ -n "$message" ] &&
			printf "\e[%s;%sH%s" \
				   $((LINES)) 1 "$message"
	fi
}

## handle-mouse
# Handle mouse click
function handle-mouse {
	local -i x y
	#parse mouse stuff somewhatish weirdly
	[ "${k_hex[*]:0:5}" = '1b 5b 3c 36 34' ] && previous-line && return
	[ "${k_hex[*]:0:5}" = '1b 5b 3c 36 35' ] && next-line && return
	[ "${k_hex[*]:0:5}" = '1b 5b 3c 38 30' ] && previous-line 9 && return
	[ "${k_hex[*]:0:5}" = '1b 5b 3c 38 31' ] && next-line 9 && return
	((skipnext==1)) && skipnext=0 && return
	((skipnext==0)) && [ "${k_hex[*]:0:2}" = '1b 5b' ] && {
		mapfile -t -d '' inputarray <<< "${1}"
		inputarray[-1]="${inputarray[-1]%?}"
		[ -z "${inputarray[2]}" ] && skipnext=1
		mapfile -t -d ';' inputarray <<< "${inputarray[1]}"
		inputarray[-1]="${inputarray[-1]%?}"	
		mousemode="${inputarray[0]}"
		x="${inputarray[1]}"
		y="${inputarray[2]::-1}"
		#limitations of movenment
		#TODO:
		[ $y = "${bf_d[loc-y]}" ] && menuline-mouse $x && return #handle menuline
		((x < (bf_d[number-length] + bf_d[loc-x] + 2))) && {
			if [ "$mousemode" = '[<0' ]; then
				bf_d[line]=$(( bf_d[base] + ( (y - bf_d[loc-y]) - toplines) ))
				redraw
			elif [ "$mousemode" = '[<2' ]; then #VERY BAD SOLUTION, TODO: FIX
				clear-screen
				echo 'Enter the index: '
				read -re line
				redraw
			fi
			return
		}
		bf_d[line]=$(( bf_d[base] + ( y - bf_d[loc-y] - 1) ))
		bf_d[column]=$(( x - (bf_d[loc-x] + bf_d[number-length] + 1) ))
		((bf_d[line] > ${#bf_e[@]})) &&
			bf_d[line]=${#bf_e[@]}
		((bf_d[column] > ${#bf_e[bf_d[line]]})) &&
			bf_d[column]=${#bf_e[bf_d[line]]}
		redraw
	}
}

## insert-word
# Insert \$1 to buffer
function insert-word {
	((options[save-states])) && save-state
	local -i rlr
	unset ta
	local ta
	ta=${bf_e[${bf_d[line]}]:0:${bf_d[column]}}
	ta=${ta//[^t]}
	ta=${#ta}
	rlr=$((bf_d[column] + ta / 4 - ta))
	buffer[bf_d[line]]="${buffer[${bf_d[line]}]:0:${rlr}}$1${buffer[${bf_d[line]}]:${rlr}}"
	#add at cursor position - amount of tabs * tab size
	make-render-line
	forward-char "${#1}"
	bf_d[selection]=0
	redraw
	bf_d[modified]=1
}

## input-key Handles input
# Either \$1 raw character input or k_hex array containing hex values of characters is used
function input-key {
	#arg $1 is the pressed key in normal text form
	#k_hex is pressed key in hex array ending with 0
		
	local -i mode_contains=0
	local -n modekeys="keys_${bf_d[mode]}"\
	         key_options="key_options_${bf_d[mode]}"

	# global keys
	((key_options[disable-global])) ||
		for str in "${!keys_global[@]}"
		{
			[ "$str" = "${k_hex[*]}" ] && {
				"${keys_global[$str]}"
				return
			}
		}

	# Execute the 'always' key option
	((${#key_options[@]})) &&
		[ -n "${key_options[always]}" ] && "${key_options[always]}"

	# Loop over current mode keybindings to match current keypress
	for str in "${!modekeys[@]}"
	{
		[ "$str" = "${k_hex[*]}" ] && {
			"${modekeys[$str]}"
			mode_contains=1
		}
	}

	# If mode keybinding doesn't contain current keypress, execute this
	((${#key_options[@]})) &&
		((mode_contains == 0)) &&
		[ -n "${key_options[else]}" ] && {
			[ "${key_options[else]}" = 'insert' ] || {
				"${key_options[else]}" && return
			}
		}

	# Do not continue if mode contains keypress to prevent control chars flooding file
	((mode_contains==1)) && return

	# If mouse is enabled, do whatever the hell that ugly piece of code does
	(("${options[mouse]}"==1)) && {
		handle-mouse "$1"
		return
	}

	# Insert the pressed character
	[[ $1 =~ [[:cntrl:]] ]] && return # If char is control char, return
	insert-word "$1"
}

function init-var {
	((options[log])) && init-log || unset buffer_log # set up log buffer (M-x log)


	log info setting traps...
	trap change-size-screen WINCH ALRM # Attach WINCH and ALRM to redraw the screen
	trap die EXIT HUP USR1 # Attach most exit codes to cleanup and exit
	trap 'k_hex=(3 0); input-key' INT
	trap quit SIGTERM

	format_tab=4

	menuloc_y=0; menuloc_x=0 # menu positions
	log info 'Setting menu-line'
	toplines=${toplines:-0}
	((toplines=toplines + options[menu-line]))

	# this is reverse because the value is added to buffer redrawing size
	log info 'Setting mode-line'
	bottomlines=${bottomlines:-0}
	((options[mode-line]==0)) && ((bottomlines--))
	log info 'Setting command-line'
	((options[command-line]==0)) && ((bottomlines--))
	((bottomlines+=2))
	
	log-echo "toplines $toplines"
	log-echo "bottomlines $bottomlines"
	
	log info 'Setting reset'
	reset='\e[0;0m'
	log info 'Setting charmap'
	charmap=(
		#[0] is reserved for any unmapped char
		[	]='t' # tab
		[ ]='s' # space
	)
	if ((options[esc-to-meta])); then
		esc_timeout=123456789 # a very big number
	else
		esc_timeout=0.01
	fi
	log info 'Setting nlchar'
	nlchar='\n'
	printf '\e[?1049h'
	log info 'Setting mouse'
	((options[mouse])) && echo -ne "\e[?1000;1006;1015h" #enable mouse tracking
}

## main Main keyboard loop
function main
	while :; do
		local -a k=()
		local -i i=1
		k_hex=() # Also convert the input sequence into hex for way easier handling
		# Check for ready input
		read -rsN1 k[0] && {
			k_hex[0]="$(printf "%x\n" "'${k[0]}")"

			# Hack to try preventing arrow codes being split into multiple and inserting garbage to buffer
			[ "${k_hex[0]}" = '1b' ] && {
				read -rsN1 -t "${esc_timeout}" k[1]
				k_hex[1]="$(printf "%x\n" "'${k[1]}")"
				[ "${k_hex[1]}" = '5b' ] && {
					read -rsN1 k[2]
					k_hex[2]="$(printf "%x\n" "'${k[2]}")"
					case "${k_hex[2]}" in
						'41'|'42'|'43'|'44')
							k_hex[3]='0'
							input-key "${k[@]}"
							continue
					esac
					i=2
				}
				((i++))
			}
			# Multibyte hack
			while read -rsN1 -t0.0001 k[$i]; do
				k_hex[$i]="$(printf "%x\n" "'${k[$i]}")"
				((i++))
			done
			k_hex[$i]='0'
			input-key "${k[@]}" # Handle keypress event
		}
	done	

### BUFFERMAKER END

## Ebashs
#		Emacs-like editor written in pure Bash
#		Had been tested properly only on Bash 5.2, and will propably be broken on 4.x versions and definitelly on 3 and older.

function load-default-config-ebashs {
	## Configuration
	#		The magic :: function
	#			:: sets value to option depending on current context:
	#				set-options → define-options() → ass. array options
	#				global-set → global-set-key → define-key global → as. ar. keys_global
	#				add-mode → local-set-key → define-key <keys> → a. a. keys_<keys>
	#					mode-options → local-set-mode-option → define-mode-option → a. a. key_options_<keys>
	#				set-alias → add-alias → a. a. alias
	#				add-menu → local-set-menu → define-menu <menu> → menu_<menu>_0 & menu_<menu>_1
	#				set-highlight → add-highlight → a. a. highlight
					  
	set-options
		:: mouse 0
		:: todonote 1
		:: menu-line 1
		:: mode-line 1
		:: command-line 1 # note that disabling this means that any message will instead be draw on top of buffer
		:: line-number-mode 1
		:: empty-line-char '~'
		:: tabchar '│   '
		:: file-prompt 'Path: '
		:: command-prompt 'M-x '
		:: cancelhex '18 0'
		:: default_mode 'edit'
		:: keep-message 0
		:: help-message "Ebashs $version"
		:: dired-message 'Pick a file'
		:: log 0
		:: log-functions 0
		:: tty-linuxfb 1 # enable truecolor support for framebuffer
		:: full-redraw 0 # redraws whole buffer, can fix artifacting in linuxfb at cost of performance
		:: welcome-buffer 1 # show welcome message instead of scratch
		:: esc-to-meta 1
		
	## Key bindings configuration
	#		A keybinding is defined via either
	#		global-set; :: ... ... or add-mode <mode>; :: ... ...
	#		:: <key> <command>
	#			<key> is defined either via
	#				Hexadecimal format (with ' 0' added as suffix).
	#				Name of key like '[<key>]'
	#				Emacsy "$(kbd <key> )" (<key> being something like C-s M-e ...)
	#			The name of key and $(kbd) get translated into hex. format on startup.
	#
	#			mode-options sets magic :: to defining mode options
	#			:: option value

	global-set
		:: "$(kbd C-x)" 'prefix'
		:: "$(kbd M-x)" 'execute-extended-command'
		:: '[f10]' 'menu-top_menu'
		:: "$(kbd C-g)" 'mode-back'
		:: '[up]' 'previous-line'
		:: '[down]' 'next-line'
		:: '[right]' 'forward-char'
		:: '[left]' 'backward-char'
		:: '[next]' 'scroll-down'
		:: '[prior]' 'scroll-up'
		:: "$(kbd C-a)" 'move-beginning-of-line'
		:: "$(kbd C-e)" 'move-end-of-line'
		:: "$(kbd C-p)" 'previous-line'
		:: "$(kbd C-n)" 'next-line'
		:: "$(kbd C-f)" 'forward-char'
		:: "$(kbd M-f)" 'forward-word'
		:: "$(kbd C-b)" 'backward-char'
		:: "$(kbd M-b)" 'backward-word'
		:: "$(kbd M-v)" 'scroll-down'
		:: "$(kbd C-v)" 'scroll-up'

	add-mode edit
		:: '1b 5b 31 3b 32 41 0' select-previous
		:: '1b 5b 31 3b 32 42 0' select-next
		:: '1b 5b 31 3b 32 43 0' select-forward
		:: '1b 5b 31 3b 32 44 0' select-backward
		:: '1b 20 0' set-mark-command # in gnu emacs this is C-SPC but i cant get that to be detected in bash so M-SPC will suffice
		:: '20 0' insert-space
		:: "$(kbd C-h)" prefix-help
		:: 'RET' newline
		:: "$(kbd C-l)" newline
		:: "$(kbd M-d)" duplicate-line
		:: "$(kbd C-t)" execute
		:: "$(kbd C-d)" delete-line
		:: 'DEL' backspace
		:: '[deletechar]' delete
		:: "$(kbd M-g)" menu-key
		:: '1b 5b 48 0' move-beginning-of-line
		:: "$(kbd C-i)" indent-for-tab-command
		:: '1b 5b 46 0' move-end-of-line
		mode-options
			:: else 'insert'

	add-mode dired
		:: RET 'dired-select'
		:: "$(kbd h)" 'toggle_hidden'
	
	add-mode view
		:: RET 'quit-view'

	add-mode doc
		:: RET 'doc-select'
		:: "$(kbd C-c)" 'quit-doc'
	
	add-mode list_buffers
		:: RET 'buffer-select'
		mode-options
			:: else 'true'
	
	add-mode prefix
		:: "$(kbd C-c)" 'quit'
		:: "$(kbd C-s)" 'write_buffer'
		:: "$(kbd C-f)" 'find-file'
		:: "$(kbd C-b)" 'list-buffers'
		:: "$(kbd b)" 'switch-to-buffer'
		:: "$(kbd 0)" 'delete-buffer'
		:: "$(kbd u)" 'undo'
		mode-options
			:: always 'mode-back'
			:: disable-global 1
	
	add-mode prefix_help
		:: "$(kbd C-g)" 'mode-back'
		:: "$(kbd C-a)" 'about'
		:: "$(kbd r)" 'manual'
		:: "$(kbd f)" 'describe-function'
		:: "$(kbd C-f)" 'describe'
		mode-options
			:: disable-global 1

	add-mode menu
		:: '[up]' 'menuup'
		:: '[down]' 'menudown'
		:: 'RET' 'menuselect'
		mode-options
			:: else 'menuleave'
			:: disable-global 1

	add-mode format
		:: '[left]' format-left
		:: '[up]' format-up
		:: '[right]' format-right
		:: '[down]' format-down
		:: 'RET' link-enter
		:: "$(kbd C-c)" quit-view
		:: '[next]' 'scroll-down'
		:: '[prior]' 'scroll-up'
		:: "$(kbd C-a)" 'move-beginning-of-line'
		:: "$(kbd C-e)" 'move-end-of-line'
		:: "$(kbd C-p)" 'previous-line'
		:: "$(kbd C-n)" 'next-line'
		:: "$(kbd C-f)" 'forward-char'
		:: "$(kbd M-f)" 'forward-word'
		:: "$(kbd C-b)" 'backward-char'
		:: "$(kbd M-b)" 'backward-word'
		:: "$(kbd M-v)" 'scroll-down'
		:: "$(kbd C-v)" 'scroll-up'
		:: "$(kbd C-x)" 'prefix'
		:: "$(kbd M-x)" 'execute-extended-command'
		:: '[f10]' 'menu-top_menu'
		:: "$(kbd C-g)" 'mode-back'
		mode-options
			:: else :
			:: disable-global 1

	add-mode welcome
		:: 'RET' link-enter
		:: "$(kbd f)" find-file
		:: "$(kbd b)" dired
		:: "$(kbd m)" manual
		:: "$(kbd d)" view-page
		:: "$(kbd a)" about
		:: "$(kbd i)" inputcodes
		:: "$(kbd c)" list-faces-display
		:: "$(kbd l)" view-log
		:: "$(kbd C-c)" quit-view
		mode-options
			:: else :
		
	## Faces
	#		Defined in escape codes
	#		Helper functions:
	#			:weight
	#				normal
	#				bold
	#			:slant
	#				normal
	#				italic
	#			:background & :foreground
	#				either hex. colour, colour name, or c<index> for 256 indexed colours
	#		See extensions/gruvboxdark for another example
edit_faces=(
		# syntax highlighting
		sh-quoted-exec "$(:foreground light-yellow)"
		font-lock-variable-string-face "$(:foreground cyan)"
		font-lock-comment-face "$(:weight dim)"
		font-lock-variable-name-face "$(:foreground light-cyan)"
		font-lock-argument-face "$(:foreground light-yellow)"
		font-lock-flow-face "$(:foreground ligth-yellow)"
		font-lock-pipe-face "$(:weight bold :foreground light-blue)"
		font-lock-bracket-face "$(:weight bold :foreground light-gray)"
		font-lock-constant-face "$(:foreground light-green)"
		font-lock-string-face "$(:foreground green)"
		font-lock-assign-face "$(:foreground light-blue)"
		font-lock-function-name-face "$(:weight bold :foreground light-cyan)"
		font-lock-keyword-face "$(:foreground light-red)"
		font-lock-util-face "$(:foreground light-magenta)"
		font-lock-declare-face "$(:foreground red)"
	)
	load-theme edit_faces

	## Aliases
	#		List of aliases for M-x.
	set-alias
		:: set-buffer-file 'find-file'
		:: read-file 'read-buffer'
		:: write-file 'write-buffer'
		:: force-quit 'die'
		:: menul 'menu-top_menu'
		:: menu-file 'menu-file'
		:: input 'inputcodes'
		:: log 'view-log'

	## Menus
	#		Defined via ordered pseudo-associative double-arrays
	#			All menu items calling 'menu-top' get applied the 'menu-back' face
	#
	#		Menu top is the top menuline & f10 menu	
	#		Menu dired is the top menuline in dired buffers	
	add-menu top
		:: File menu-file
		:: Keys menu-key
		:: Help menu-help
		:: Debug menu-debug
		:: Redraw refresh

	add-menu top_menu
		:: 'File   ' menu-file
		:: 'Keys   ' menu-key
		:: 'Help   ' menu-help
		:: 'Debug  ' menu-debug
		:: 'Redraw ' refresh

	add-menu file
		:: '        BACK        ' menu-top_menu
		:: 'Quit        C-x C-c ' quit
		:: 'Visit file  C-x C-f ' find-file
		:: 'Execute         C-t ' execute
		:: 'Save        C-x C-s ' write-buffer
		:: 'Dired               ' dired
	add-menu help
		:: '        BACK        ' menu-top
		:: 'Keybinding          ' menu-key
		:: 'About               ' about

	add-menu key
	    :: '        BACK        ' menu-top_menu
		:: 'Exit        C-x C-c ' quit
		:: 'New Line    C-l | ⏎ ' newline
		:: 'Visit file  C-x C-f ' find-file
		:: 'Save file   C-x C-s ' write-buffer
		:: 'Delete Line     C-d ' delete-line
		:: 'Prev Line       C-p ' previous-line
		:: 'Next Line       C-n ' next-line
		:: 'Prev Page       C-y ' scroll-down
		:: 'Next Page       C-v ' scroll-up
		:: 'Execute         C-t ' execute
		:: 'Shell           C-s ' shell
		:: 'Force exist     M-q ' die
    add-menu debug
		:: '   BACK   ' menu-top_menu
		:: 'clear     ' clear-screen
		:: 'refresh   ' refresh
		:: 'backspace ' backspace
		:: 'right     ' forward-char
		:: 'left      ' backward-char
		:: 'inputcodes' inputcodes
		:: 'faces     ' list-faces-display

	## Syntax highlighting
	set-highlight
		:: 'shell' bash ksh dash sh mksh zsh ash oksh i\*bash 'busybox sh'
		:: 'ebashs' ebashs
		:: 'config' conf
		:: 'execline' execlineb
		:: 'format-edit' format
		:: 'dired' i\*dired
		:: 'unknown' unknown

	add-menu dired
		:: 'toggle hidden (h)' "toggle_hidden"

	add-menu dialog
		:: quit 'quit-view'

	add-menu welcome
		:: about 'about'
		:: manual 'manual'
		:: docs 'view-page'
		:: quit 'quit-view'
	
	# Navigation used in some inbuild buffers
	#format_nav="<a> about : <f> link About </f> </a> "
	#format_nav+="<a> manual : <f> link Manual </f> </a> "
	#format_nav+="<a> view-page : <f> link Documentation </f> </a>"
	format_nav="<o> id: about select: about right: obj manual text: <f> link About </f> </o> "
	format_nav+="<o> id: manual select: manual left: obj about right: obj doc text: <f> link Manual </f> </o> "
	format_nav+="<o> id: doc select: view-page left: obj manual right: next-line text: <f> link Documentation </f> </o>"
}

## Documentation
function load-doc {
	mapfile -t -O 1 top_doc <<'EOF'
<h> Documentation </h>

<tab> <link> goto doc_control : Controls </link>
<tab> <link> describe : Functions </link>
<tab> <link> goto doc_faces : Face setting </link>
EOF

	mapfile -t -O 1 doc_control <<'EOF'
<link> goto top_doc : Back </link>
<h> [ Controls ] </h>

Automatically generated list of keybindings. Click on function name to view it's documentation.
Note that currently only key set via $(kbd C-char or M-char) will show up.
EOF
	for mode in "${modes[@]}"; do
		doc_control+=(
			'</i>'
			"<h> ${mode} </h>"
			'<i-tab>'
		)
		local -n moderef="$mode"
		for ch in\
			C-a C-b C-c C-d C-e C-f C-g C-h C-i C-j C-k C-l C-m C-n C-o C-p C-q C-r C-s C-t C-u C-v C-w C-x C-y C-z :\
			M-a M-b M-c M-d M-e M-f M-g M-h M-i M-j M-k M-l M-m M-n M-o M-p M-q M-r M-s M-t M-u M-v M-w M-x M-y M-z	
		do
			[ "$ch" = ':' ] && {
				doc_control+=('')
				continue
			}
			key=${moderef[$(kbd ${ch})]}
			[ -z "$key" ] && continue
			doc_control+=(
				"<f> highlight ${ch} </f> <a> doc-select $key : <f> font-lock-function-name-face $key </f> </a>"
			)
		done
	done
	doc_control+=(
		'</i>'
	)

	mapfile -t -O 1 doc_faces <<'EOF'
<link> goto top_doc : Back </link>
<h> [ Face configuration ] </h>

Faces are set via theme arrays. Theme array consists pairs of name and value.
The first is name, second is value, then again first... second... ... ... . The
Theme array has to be then loaded via <link> doc-select load-theme : load-theme </link> function.

Faces configured via escape codes, for example:
<-> <f> blue perfectblue '\e[44m' </f>
Produces blue colored face

But <[> title Ebashs is civilised and so has nicer settings for this:
<-> <f> blue perfecterblue "$(:background blue)" </f>
or one of 256 colors:
<-> <f> blue blue256 "$(:background c18)" </f>
or if you use nice terminal even full 24 bit hex. color:
<-> <f> blue TRUEBLUE "$(:background " <-f> ansi-color-blue #0000ff </f-> ")" </f>

The face-setting functions can be combined:
<-> <f> red red <-f> cyan cyan </f> </f> <f> cyan "$(:background <f> ansi-color-cyan c44 </f> </f> <f> red :foreground <f> ansi-color-red c196 </f-> )" </f>

<-> <-> see <link> doc-select :foreground : :foreground </link> <link> doc-select :background : :background </link> <link> doc-select setface : setface </link>

The boldness and dimness can be set via <a> doc-select :weight : <f> link :weight </f> </a> function.
The inverseness can be set via <a> doc-select :mode : <f> link :mode </f> </a> function.
The slant can be set via <a> doc-select :slant : <f> link :slant </f> </a> function.

<h> Example </h>

To change faces used on this page

<-> <f> title misleading_theme </f-> =( <i> 8
<[> title title "$(:weight bold :background "#ffffff")"
<[> link link "$(:weight bold :background light-yellow)"
<[> ansi-color-blue ansi-color-blue "$(:background cyan)"
<[> ansi-color-cyan ansi-color-cyan "$(:background green)"
<[> blue blue "$(:foreground cyan)"
<[> red red "$(:foreground yellow)"
<[> font-lock-keyword-face font-lock-keyword-face ''
<[> cyan cyan "$(:foreground green)" </i>
<-> )
<-> <f> font-lock-keyword-face load-theme </f> <f> title misleading-theme </f>
EOF
}

@@ execute-extended-command
:: 'Handles M-x command prompt & execution'
function execute-extended-command {
	read-command "${options[command-prompt]}" readin || return 1
	for lcmd in "${!alias[@]}"; {
		[ "$readin" = "$lcmd" ] && {
			${alias[$lcmd]}
			return
		}
	}
	$readin			
	((noredraw)) && noredraw=0 || redraw
}

function prefix { switch-mode prefix; }
function prefix-help { switch-mode prefix_help; }

@@ save Saves current buffer references data as '$1'
function save {
	local name="$1"
	local -n savedcurrent_buffer="current_buffer${name}"
	savedcurrent_buffer="$current_buffer"
}

@@ restore Restores '$1' buffer references data to current
function restore {
	local name="$1"
	local -n savedcurrent_buffer="current_buffer${name}"
	set-buffer "${savedcurrent_buffer}"
}

@@ set-syntax
:: Picks syntax highlighting function for current filetype
function set-syntax
	if [ -n "${highlight[*]}" ] && bf_d[syntax]="syntax-${highlight[unknown]}"
	then
		for syntax_setting in "${!highlight[@]}"; {
			[ "$syntax_setting" = "${bf_d[filetype]}" ] && {
				bf_d[syntax]="syntax-${highlight[$syntax_setting]}"
			}
		}
	else
		log warn 'no highlight array... using unknown'
	fi

@@ syntax-shell
:: Syntax function for shell
:: Used faces:
	:+ '* sh-quoted-exec'
	:: '* font-lock-declare-face'
	:: '* font-lock-variable-string-face'
	:: '* font-lock-comment-face & sets comment to 1 for syntax-word function'
	:: '* font-lock-variable-name-face'
	:: '* font-lock-argument-face'
	:: '* font-lock-function-name-face'
	:: '* font-lock-flow-face'
	:: '* font-lock-pipe-face'
	:: '* font-lock-bracket-face'
	:: '* font-lock-constant-face'
	:: '* font-lock-string-face'
	:: '* font-lock-assign-face'
	:: '* font-lock-keyword-face'
	:: '* font-lock-default-face'
function syntax-shell
	case "${word}" in
		'$('*|'"$('*) set-face sh-quoted-exec;;
		*'=()'|'declare'|'local'|'typeset') set-face font-lock-declare-face;;
		'"$'*) set-face font-lock-variable-string-face;;
		'#'*) set-face font-lock-comment-face && comment=1;;
		'$'*) set-face font-lock-variable-name-face;;
		'-'*) set-face font-lock-argument-face;;
		*'()') set-face font-lock-function-name-face;;
		'||'|'&&'|';'|'&') set-face font-lock-flow-face;;
		'>'|'<'|'|'|'>>'|'<<'|'<<<') set-face font-lock-pipe-face;;
		'('|')'|'{'|'}'|'[['|']]'|'['|']') set-face font-lock-bracket-face;;
		'function') set-face font-lock-function-name-face;;
		*"'"*) set-face font-lock-constant-face;;
		*'"'*) set-face font-lock-string-face;;
		*'='*) set-face font-lock-assign-face;;
		'echo'|'return'|'case'|'esac'|'for'|'while'|'do'|'done'|'if'|'elif'|\
		'else'|'printf'|'fi'|'continue'|'exit'|'bind'|'then'|'break'|'read'|\
		'let'|'shopt'|'trap'|'set'|'eval'\
			) set-face font-lock-keyword-face;;
		*) set-face default;;
	esac

@@ syntax-ebashs
:: Syntax function for shell
:: Used faces:
	:+ '* sh-quoted-exec'
	:: '* font-lock-declare-face'
	:: '* font-lock-variable-string-face'
	:: '* font-lock-comment-face & sets comment to 1 for syntax-word function'
	:: '* font-lock-variable-name-face'
	:: '* font-lock-argument-face'
	:: '* font-lock-function-name-face'
	:: '* font-lock-flow-face'
	:: '* font-lock-pipe-face'
	:: '* font-lock-bracket-face'
	:: '* font-lock-constant-face'
	:: '* font-lock-string-face'
	:: '* font-lock-assign-face'
	:: '* font-lock-keyword-face'
	:: '* font-lock-default-face'
function syntax-ebashs
	case "${word}" in
		'$('*|'"$('*) set-face sh-quoted-exec;;
		*'=()'|'declare'|'local'|'typeset') set-face font-lock-declare-face;;
		'"$'*) set-face font-lock-variable-string-face;;
		'#'*) set-face font-lock-comment-face && comment=1;;
		'$'*|'@') set-face font-lock-variable-name-face;;
		'-'*|'::') set-face font-lock-argument-face;;
		*'()') set-face font-lock-function-name-face;;
		'||'|'&&'|';'|'&') set-face font-lock-flow-face;;
		'>'|'<'|'|'|'>>'|'<<'|'<<<') set-face font-lock-pipe-face;;
		'('|')'|'{'|'}'|'[['|']]'|'['|']') set-face font-lock-bracket-face;;
		'new'|'template'|'@def'|'@fn'|'@:') set-face font-lock-function-name-face;;
		*"'"*) set-face font-lock-constant-face;;
		*'"'*) set-face font-lock-string-face;;
		*'='*|'function') set-face font-lock-assign-face;;
		'echo'|'return'|'case'|'esac'|'for'|'while'|'do'|'done'|'if'|'elif'|\
		'else'|'printf'|'fi'|'continue'|'exit'|'bind'|'then'|'break'|'read'|\
		'let'|'shopt'|'trap'|'set'|'eval'\
			) set-face font-lock-keyword-face;;
		'set-options'|'global-set'|'define-key'|'local-set-key'|'add-mode'|'mode-options'|\
		'load-theme'|'set-alias'|'add-menu'|'@ifs'|'doc'|'_'|'__'|'copy-array'|\
		':foreground'|':background'|':mode'|'weight'|':slant'|'kbd'|'add-highlight'\
			) set-face font-lock-keyword-face;;
		*) set-face default;;
	esac

@@ syntax-execline
:: Syntax function for execline
function syntax-execline
	case "${word}" in
		'"$'*) set-face font-lock-variable-string-face;;
		'#'*) set-face font-lock-comment-face && comment=1;;
		'$'*) set-face font-lock-variable-name-face;;
		'-'*) set-face font-lock-argument-face;;
		'{'|'}') set-face font-lock-bracket-face;;
		*'"'*) set-face font-lock-string-face;;
		'execlineb'|'execline-cd'|'posix-cd'|'cd'|'execline-umask'|'posix-umask'|'umask'|\
		'emptyenv'|'envfile'|'export'|'unexport'|'fdclose'|'fdblock'|'fdmove'|'fdswap'|'fdreserve'|\
		'redirfd'|'piperw'|'heredoc'|'wait'|'getcwd'|'getpid'|'exec'|'tryexec'|'exit'|'trap'|'withstdinas'|\
		'foreground'|'background'|'case'|'if'|'ifelse'|'ifte'|'ifthenelse'|'backtick'|'pipeline'|'runblock'|\
		'define'|'importas'|'elglob'|'elgetpositionals'|'multidefine'|'multisubstitute'|\
		'fox'|'forstdin'|'forbacktickx'|'loopwhilex'|\
		'elgetopt'|'shift'|'dollarat'|\
		'eltest'|'homeof'|\
		'execline') set-face font-lock-keyword-face;;
		's6-basename'|'s6-cat'|'s6-chmod'|'s6-chown'|'s6-clock'|'s6-cut'|'s6-dirname'|'s6-dumpenv'|\
		's6-echo'|'s6-env'|'s6-expr'|'s6-false'|'s6-format-filter'|'s6-grep'|'s6-head'|'s6-hiercopy'|\
		's6-linkname'|'s6-ln'|'s6-ls'|'s6-maximumtime'|'s6-mkdir'|'s6-mkfifo'|'s6-nice'|'s6-nuke'|\
		's6-pause'|'s6-printenv'|'s6-quote-filter'|'s6-quote'|'s6-rename'|'s6-rmrf'|'s6-seq'|\
		's6-sleep'|'s6-sort'|'s6-sync'|'s6-tai64ndiff'|'s6-tail'|'s6-touch'|'s6-true'|'s6-uniquename'|\
		's6-unquote-filter'|'s6-unquote'|'s6-update-symlinks'|'seekablepipe'|\
		's6-portable-utils') set-face font-lock-util-face;;
		'rngseed'|'s6-chroot'|'s6-freeramdisk'|'s6-hostname'|'s6-logwatch'|'s6-mount'|\
		's6-pivotchroot'|'s6-ps'|'s6-swapoff'|'s6-swapon'|'s6-umount') set-face font-lock-util-face;;
		*) set-face default;;
	esac

@@ syntax-format-edit
:: Syntax function for ebashs\'s formatter
function syntax-format-edit
	case "${word}" in
		'<f>'|'<-f>'|'</f>'|'</f->'|'<u>'|'</u>'|'<tab>'|'<i>'|'</i>'|'<i-tab>'|'<h>'|'<s>'\
			)set-face font-lock-keyword-face;;
		*) set-face default;;
	esac
@@ syntax-unknown Default syntax function
:: Sets everything to default face
@fn syntax-unknown 'set-face default'

@@ syntax-list-buffers
:: Syntax function for list-buffers
function syntax-list-buffers {
	((syntaxline==2)) && {
		face hint "$word"
		return
	}
	local -n cbf_d="${word}_bf_d"
	face link "$(printf '%*s' -6 "$word")"
	face file-name "$(printf '%*s' -16 "${cbf_d[file]}")"
	face default "$(printf '%*s' -10 "${cbf_d[mode]}")"
	face font-lock-comment-face "${cbf_d[modified]} "
}

@@ syntax-dired
:: Highlighting for dired buffers
:+     '* Directories → link'
::     '* Files → default'
function syntax-dired {
	[ -d "$word" ] && set-face link
	[ -f "$word" ] && set-face default
}

@@ syntax-config
:: Basic syntax function for config files
:: Used faces:
:+     '* default'
::     '* font-lock-comment-face & sets comment to 1 for syntax-word function'	
function syntax-config
	case "${word}" in
		'#'*) set-face font-lock-comment-face && comment=1;;
		*) set-face default;;
	esac

@@ filetype
:: Detect type of file '$1':					
:+     "* If file doesn't exist → unknown"
::     "* If is COMMIT_EDITMSG → conf"
::     "* If is ebashs → ebashs"
::     "* Extension →"
::     "* Shebang →"
::     "* Special shebang #@ →"
::     "* unknown →"
function filetype {
	[ ! -f "$1" ] && {
		echo unknown
		return
	}
	#very ugly, TODO: redo this
	local filename shebang extension
	local -a filenamesplit shebangsplit
	[ $# = 0 ] && return
	[ "${1:0:1}" = '.' ] || {
		IFS='.'
		filename="${1%/}"
		filename="${filename##*/}"
		[ "$filename" = 'COMMIT_EDITMSG' ] && echo conf && return
		[ "$filename" = 'ebashs' ] && echo ebashs && return
		filenamesplit=($filename)
		extension="${filenamesplit[-1]}"
		[ "${#filenamesplit[@]}" -gt 1 ] && echo "$extension" && return
	}
	mapfile -n 1 file_data < "$1"
	shebang="$(echo -n "${file_data[@]}")"
	case "${shebang:0:2}" in
		'#!')
			shebang="${shebang%/}"
			IFS=' '
			shebangsplit=("${shebang##*/}")
			local shebangss=(${shebangsplit[-1]})
			case "${shebangss[0]}" in
				env)
					printf '%s\n' "${shebangss[1]}";;
				*)
					printf '%s\n' "${shebangsplit[-1]}";;
			esac
			;;
		'! ')
			mapfile -d ' ' -t split <<< "${shebang}"
			printf '%s\n' "${split[1]}"
			;;
		'##')
			mapfile -d ' ' -t split <<< "${shebang}"
			printf '%s\n' "${split[1]}"
			;;
		*) echo unknown
	esac
	@ifs
}

@@ find-file
:: Asks for file and opens it
function find-file {
	printf '\e[%s;0H' $((bf_d[size-y] + bf_d[loc-y]))
	printf '\e[?25h'
	bind 'set disable-completion off' 2>/dev/null # Enable completion
	read -re -p "${options[file-prompt]}" command && {
		read-buffer "$command"
		[ -n "$bckmode" ] && bf_d[mode]="$bckmode" || bf_d[mode]=edit
		redraw
	}
	bind 'set disable-completion on' 2>/dev/null
}

@@ view-format
:: Open file as formated document
function view-format {
	save openfile
	printf '\e[%s;0H' $((bf_d[size-y] + bf_d[loc-y]))
	printf '\e[?25h'
	bind 'set disable-completion off' 2>/dev/null # Enable completion
	read -re -p "${options[file-prompt]}" command && {
		read-buffer "$command"
		bf_d[syntax]=syntax-format
		bf_d[syntax-exec]=1
		[ -n "$bckmode" ] && bf_d[mode]="$bckmode" || bf_d[mode]=view
		redraw
	}
	bind 'set disable-completion on' 2>/dev/null
}

@@ insert-debug-hex
:: Adds hex code of keypress into buffer
function insert-debug-hex {
	buffer+=(
		"${k_hex[*]}"
	)
	next-line
	make-render-line
	redraw
}

@@ switch-to-buffer
:: Interactive wrapper for set-buffer
function switch-to-buffer {
	redraw
	read-command "Switch to buffer: " readin
	set-buffer "$readin"
	redraw
}

@@ list-buffers
:: Displays currently active buffers
function list-buffers {
	save openfile
	set-buffer list_buffers
	declare -Ag "${current_buffer}_bf_d"
	focus set-buffer
		:: line 1
		:: base 1
		:: column 0
		:: modified 0
		:: mode 'list_buffers'
		:: info 'Currently open buffers'
		:: filetype 'i*buffer-list'
		:: file '*Buffer List*'
		:: syntax syntax-list-buffers
		:: syntax-exec 1
		:: menuline 'about'
	[auto]
	buffer=(
		''
		'ID    FILENAME        MODE      MODIFIED'
	)
	bf_s=('')
	append-array buffers_l buffer
	redraw
	}
	
@@ buffer-select
:: Is ran on RET inside list_buffers buffer
function buffer-select {
	((bf_d[line]==1)) && return
	set-buffer "${buffer[bf_d[line]]}"
	[ "${bf_d[mode]}" = 'prefix' ] && bf_d[mode]="$bckmode"
	redraw
}

add-mode debuginput
	local-set-key "$(kbd C-x)" 'quit-view'
	local-set-mode-option else 'insert-debug-hex'
	local-set-mode-option disable-global 1
add-menu debuginput
	local-set-key 'quit-debuginput'

@@ inputcodes
:: Opens debug input buffer
function inputcodes {
	save openfile
	declare-new-buffer
		:: mode 'debuginput'
		:: info 'C-x (18 0) to close'
		:: filetype 'i*term'
		:: file '*debuginput*'
		:: modified 0
		:: syntax syntax-unknown
		:: menuline 'debuginput'
		[auto]
		
	buffer=(
		''
		'[ KEY DEBUGGER ]'
		''
		"Press any key to see Ebashs's native hex. representation of it."
		"See C-h f define-key & C-h f kbd for fancier key settings"
		''
	)
	bf_d[line]=7
	redraw
}

@@ read-buffer
:: Reads file \$1 into new buffer
function read-buffer {
	log info "reading $* ..."
	declare-new-buffer
		:: mode "${options[default_mode]}"
		:: info "${options[help-message]}"
		:: filetype "$(filetype "$1")"
		:: file "$1"
		:: menuline 'top'
		:: current_state 0
	[auto]
	((options[view])) &&	
		[ "${bf_d[filetype]}" = 'format' ] && {
			:: mode format
			:: syntax syntax-format
			:: syntax-exec 1
		}
		
	[ -f "${bf_d[file]}" ] && mapfile -t -O 1 "${current_buffer}_buffer" <"${bf_d[file]}" # Read file into an array
	
	
	# Ensure that something was actually read into the file
	[[ -n "${buffer[*]}" ]] && {
		message="Read ${#buffer[@]} lines from '${bf_d[file]}'"
	} || {
		message="'${bf_d[file]}' is empty"
	}
	bf_d[line]=1 # Indicate that we have a buffer loaded
	bf_d[modified]=0
}

@@ toggle_hidden
:: Toggles hidden files in dired buffer
function toggle_hidden {
	((hidden==0)) && hidden=1 || hidden=0
	dired
}

@@ dired
:: Open file manager in current working directory
function dired {
	declare-new-buffer
		:: info 'Dired'
		:: mode 'dired'
		:: filetype 'i*dired'
		:: file '*dired*'
		:: menuline 'dired'
		[auto]
		
	mapfile -t -O 1 buffer <<< "$(list-directory)"
	make-render
	if [[ "${buffer[1]}" ]]; then # Ensure that something was actually read into the file
		bf_d+=(
			[line]=1
			[info]="$PWD"
		)
	else
		bf_d[info]="error: empty"
	fi
	redraw
}

@@ dired-select
:: Select a item in dired buffer
	:+     '* If it is a directory cd into it and open new dired'
	::     '* If it is a file open it via read-buffer function'
function dired-select
	if [ -d "${buffer[bf_d[line]]}" ]; then
		cd "${buffer[bf_d[line]]}"
		dired
	else
		read-buffer "${buffer[bf_d[line]]}" || exit 1
		redraw
	fi

@@ init-log
:: Initializes M-x view-log buffer
function init-log {
	log=1
	declare -Ag "log_bf_d"
	declare -ng bufferlog="log_buffer"
	declare -ng bf_d="log_bf_d"
	focus set-buffer
		:: base 1
		:: column 0
		:: info 'LOG'
		:: mode 'view'
		:: help-message 'LOG'
		:: filetype 'i*view'
		:: file '*log*'
		:: modified 0
		:: syntax syntax-format
		:: syntax-exec 1
		:: menuline 'menulog'
	add-menu
		:: 'quit' 'quit-view'

	size-full

	bufferlog+=(
		''
		"<f> title Ebashs version $version </f>"
		"<tab> <f> highlight [ LOG START ] </f>"
		''
		'<f> title System info: </f> <i-tab>'
		"Bash version:  ${BASH_VERSION}"
		"System:        ${OSTYPE}"
		"Terminal type: ${TERM}"
		"Locale:        ${LANG} </i>" 
		''
		'<f> title Loaded extensions: </f>'
	)
	for e in "${extensions[@]}"; {
		local -n ext_d="${e}_ext_d"
		bufferlog+=("    $e - ${ext_d[version]}")
	}
	bufferlog+=(
		''
		'<f> hint level time function message </f>'
	)
	lasttime="$(current-time '%s')"
}

@@ view-log
:: Opens log buffer
function view-log {
	((log)) || {
		message='Error: log is not initialised'
		return
	}
	save openfile
	set-buffer log
	copy-array buffer bf_e
	clear-screen
	redraw
}

@@ buffer-dialog
:: Helper functions for creating simple popup buffers
function buffer-dialog {
	save openfile
	declare-new-buffer
		:: line 1
		:: info "$1"
		:: mode view
		:: filetype 'i*view'
		:: file "$2"
		:: modified 0
		:: syntax syntax-unknown
	size-full
}

@@ buffer-dialog-draw
:: Draws buffer created by buffer-dialog
# NOTE: To be removed
function buffer-dialog-draw {
	clear-screen
	redraw
}
	
@@ about
:: Shows about information	
function about {
	save openfile
	declare-new-buffer
		:: line 1
		:: info "About"
		:: mode format
		:: filetype 'i*format'
		:: file "*about*"
		:: modified 0
		:: syntax syntax-format
		:: syntax-exec 1
	size-full
	mapfile -t -O 1 buffer <<EOF
$format_nav

<h> Ebashs $ebashs_version </h>
Buffermaker $buffermaker_version

Copyright(č)ˇ 2022-2024 <f> title Netkv </f-> .
( <-f> title bed </f-> : Copyright(č)ˇ 2020 <f> title Comfies </f-> .)

This is Ebashs, one component of the Bash/Bash operating system.

An editor written in pure bash via nonsense sphagetti code trying copying emacs.

Repo <s> 19 <f> link https://github.com/aeknt/spis </f>
<s> 24 Ebashs comes with ABSOLUTELY NO WARRANTY




Based on <s> 15 <f> link https://github.com/comfies/bed </f>


<tab> <f> hint For more information about usage of Ebashs, press <f> light-gray C-h C-r </f> to view </f> <link> manual : manual </link>

<i> 5
<f> dr                          .............. </f>
<f> lr                       @***%@@@@@@@@@@@@... </f>
<f> dr                ** .*@@@@@@@@@@@@@@@@@@@@@.. </f>
<f> dy                .       @@&....,,#@@@@@@@@ </f>
<f> ly                 ....,@@@@@@@@@@@@@@@@@@ </f>
<f> dy             /@@@@@@@@@@@@@@@@@@@@@@. </f>
<f> dg           @@@@@@@,,...@@@&.. </f>
<f> lg         .@@@@@@@@@@@,,@@@&. </f>
<f> dg         ..@@@@@@@@@@@@@@@&.. </f>
<f> dc           .../@@@@@@@@@@@@@@..... </f>
<f> lc              ....@@@@@@@@@@@@@@@&.... </f>
<f> dc              ..(#@@@@@@@@@@@@@@@@@@@ </f>                                    
<f> db         ./@@@@@@@@@@@@@@@@%...... </f>
<f> lb     .@@@@@@@@@@@@@@@@.@@@&. </f>
<f> db   @@@@@@@@@@@@@@..   .@@@&. </f>
<f> dm  .@@@@@@@@@@@@.      .@@@&. </f>
<f> lm ..@@@@@@@@@@@@/.......@@@&. </f>
<f> dm  ...,@@@@@@@@@@@@@@@@@@@@&................. </f>
<f> gr      ...@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@.. </f>
<f> dw          ....../@@@@@@@@@@@@@@@@@@@@@@@@@@@@@# </f>
<f> lw                   ..,,,,*##@@@@@@@@@@@@@@@.      .###################. </f>
<f> dw                 @@@@@@@@@@@@@@@@@@@@..        @@@@@@@@@@@@@@@@@@@@@@ </f>
<f> gr              /@@@@@@@/........              @@@@@@@@@@@@@@@@@@@@. </f>
</i>                                                                              
                                                                                

<i> 2 <f> hint ─[ <-f> light-cyan bsd0 </f-> ]───────────────────────────────────────────────────────────────────────────────────── </f->
Permission to use, copy, modify, and/or distribute this software for any purpose
with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
<f> hint ──────────────────────────────────────────────────────────────────────────────────────────── </f> </i>

EOF
	redraw
}

@@ view-page
:: Display formated text nicely	
function view-page {
	save openfile
	declare-new-buffer
		:: line 3
		:: column 4
		:: info "view"
		:: mode format
		:: filetype 'format'
		:: file "*view*"
		:: modified 0
		:: isfile 0
		:: syntax syntax-format
		:: syntax-exec 1
	size-full
	clrmsg=0	
	message='loading...'
	redraw-commandline
	load-doc
	copy-array top_doc buffer
	redraw
}

@@ list-faces-display
:: Displays list of faces
function list-faces-display {
	save openfile
	declare-new-buffer
		:: line 1
		:: info "$1"
		:: mode view
		:: filetype 'i*view'
		:: file '*format*'
		:: modified 0
		:: syntax syntax-format
		:: syntax-exec 1
	size-full
	buffer=('')
	for face in "${!faces[@]}"; do
		buffer+=(
			"$(printf '%*s' -40 "${face}") <f> ${face} abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ </f>"
		)
	done
	buffer-dialog-draw
}

@@ list-data-display
:: Displays list of data of buffer from bf_d array	
function list-data-display {
	read-command "List data of buffer: " readin
	local -n bdata="${readin}_bf_d"
	buffer-dialog faces 'data' '*list-data-display*'
	buffer=('')
	for datum in "${!bdata[@]}"; do
		buffer+=(
			"$(
			printf '%*s%s' -20 "${datum}" "${bdata[${datum}]}"
		)"
		)
	done
	buffer-dialog-draw
}

@@ list-options-display
:: Displays list of options
function list-options-display {
	buffer-dialog faces '*list-data-display*'
	buffer=('')
	for option in "${!options[@]}"; do
		buffer+=(
			"$(
				printf '%*s%s' -20 "${option}" "${options[${option}]}"
			)"	
		)
	done
	buffer-dialog-draw
}

@@ table-init
:: Initializes bml \(bash markup language\) table
function table-init {
	table_columns="$1"
	shift
	local -i i=0
	for col in "$@"; do
		local -n n="table_column_$i"
		n="$col"
		((i++))
	done
}

@@ table-char
:: Sets style of bml table
function table-char
	if (( ${#@} == 11 )); then
		table_char=("$@")
	else
		table_char=(─ │ ┌ ┬ ┐ ├ ┼ ┤ └ ┴ ┘)
	fi

@@ table-top
:: Prints top line of bml table
function table-top {
	printf '%s' "<f> hint ${table_char[2]}"
	for ((i=0; i<table_columns; i++)); do
		local -n n="table_column_$i"
		for ((ii=1; ii-1<n; ii++)); do
			printf '%s' "${table_char[0]}"
		done
		((i==table_columns-1)) || printf '%s' "${table_char[3]}"
		((i==table_columns-1)) && printf '%s' "${table_char[4]}"
	done
	printf '%s\n' ' </f->'
}

@@ table-title-line
:: Prints bml table title divider
function table-title-line {
	printf '%s' "<f> hint ${table_char[5]}"
	for ((i=0; i<table_columns; i++)); do
		local -n n="table_column_$i"
		for ((ii=1; ii-1<n; ii++)); do
			printf '%s' "${table_char[0]}"
		done
		((i==table_columns-1)) || printf '%s' "${table_char[6]}"
		((i==table_columns-1)) && printf '%s' "${table_char[7]}"
	done
	printf '%s\n' ' </f->'
}
@fn table-divider 'table-title-line "$@"'

@@ table-bottom
:: Prints bottom line of bml table
function table-bottom {
	printf '%s' "<f> hint ${table_char[8]}"
	for ((i=0; i<table_columns; i++)); do
		local -n n="table_column_$i"
		for ((ii=1; ii-1<n; ii++)); do
			printf '%s' "${table_char[0]}"
		done
		((i==table_columns-1)) || printf '%s' "${table_char[9]}"
		((i==table_columns-1)) && printf '%s' "${table_char[10]}"
	done
	printf '%s\n' ' </f->'
}

@@ table-item
:: Prints line of table
function table-item {
	local -i i=0
	for item in "$@"; do
		local -n n="table_column_$i"
		printf '%s' "<f> hint ${table_char[1]} </f-> "
		printf '%s' "$item"
		printf '%*s' $(( n - ${#item} )) ''
		((i++))
	done
	printf '%s' "<f> hint ${table_char[1]}"
	printf '%s\n' ' </f->'
}

@@ table-title
:: Prints title of table
function table-title {
	local -i i=0
	for title in "$@"; do
		local -n n="table_column_$i"
		printf '<f> hint %s' "${table_char[1]} </f->"
		printf '%*s' $(( n / 2 - ( ${#title} / 2 ) )) ''
		printf '%s' " <-f> title $title </f-> "
		if ((${#title}%2==0)) && ((n%2==1)); then
			printf ' %*s' $(( ( n / 2 - ( ${#title} / 2 ) ) + 1 )) ''
		else
			printf ' %*s' $(( n / 2 - ( ${#title} / 2 ) )) ''
		fi
		((i++))
	done
	printf '%s' "<f> hint ${table_char[1]}"
	printf '%s\n' ' </f->'
}

@@ code-block
:: Prints code in bml document
function code-block while read -r; do echo " <-f> light-cyan $REPLY </f-> "; done

@@ print-stdin
:: Basically like coreutil "'cat'"
function print-stdin while read -r; do echo "$REPLY"; done

@@ text
:: Prints normal text in bml document
function text
	while read -r; do
		l=${#REPLY}
		for ((i=0; i<l; i+=(bf_d[size-x]/3)*2)); do
			printf '%s%s\n' "$1" "${REPLY:i:(bf_d[size-x]/3)*2}"
		done
	done

@fn title 'printf "[ <f> title %s </f> ]" "$@"'
@fn code 'printf "$@"'

@@ header
:: Prints header of bml document
function header {
	arg=$*
	table-init 1 $(( ${#arg} * 2 ))
	table-char ═ ║ ╔ X ╗ X X X ╚ X ╝
	print-stdin <<-EOF2
                                 $(table-top)
                                 $(table-title "${1}")
                                 $(table-bottom)
	EOF2
}

@@ manual
:: 'Displays C-h r manual buffer'
function manual {
	save openfile
	declare-new-buffer
		:: line 1
		:: info "About"
		:: mode view
		:: filetype 'i*format'
		:: file "*about*"
		:: modified 0
		:: syntax syntax-format
		:: syntax-exec 1
	size-full
	get-manual
	redraw
}
	
@@ get-manual
:: Parses manual bml document
function get-manual {
	#DO NOT edit following lines, makedoc handles them automatically
	# MAKEDOC INSERT README START
mapfile -t -O 1 buffer <<EOF
$(text <<EOF2
This is Ebashs, one component of the Bash/Bash operating system.
… or even better an attempt to clone GNU Emacs in bash.
EOF2
)

$(text '    '<<EOF2
Note that the readme, may be currently outdated as I am changing the core functioning of Ebashs.

Versions of Ebashs ending in WIP-x are and will be broken, you can check version via M-x about or by reading the second line of Ebashs script.
EOF2
)

$(text '    '<<EOF2
For more updated help run inside Ebashs $(code 'M-x describe') or $(code 'C-h C-f')
EOF2
)

$(text <<EOF2
Update: Ebashs was split into two parts, the editor (Ebashs) and the underlying tui framework (Buffermaker). This split isn't yet complete and using Buffermaker for programs other than Ebashs is very experimental (see testapp example).

Update 2: Buffermaker has been separated into https://github.com/aeknt/BufferMaker. Ebashs now includes its internal version of BufferMaker library to prevent breaking when I randomly decide to change core functions, and to make using Ebashs easier.
EOF2
)

$(header EBASHS)

$(title DESCRIPTION)

$(text <<EOF2
An attempt to clone GNU Emacs but in bash.
EOF2
)

$(title FEATURES)

$(text <<EOF2
syntax highlighting
custom keybindings
custom modes -- so you can implement the evil too
file picker
mouse support
EOF2
)

$(title CONFIG)

$(text <<EOF2
Ebashs is configured via variables defined at start, you can separate it into file and then source it.
EOF2
)

    $(title 'OPTIONS ARRAY')

$(table-init 3 19 19 39; table-char
print-stdin <<EOF2
    $(table-top)
    $(table-title NAME DEFAULT DESCRIPTION)
    $(table-title-line)
    $(table-item mouse ' 0' 'enable mouse at launch')
    $(table-item todonote ' 1' "highlight 'TODO:' & 'NOTE:'")
    $(table-item menuline ' 1' 'display menuline')
    $(table-item tabchar "$(code '|   ')" 'what should tab display as')
    $(table-item file_prompt "'Path: '" 'file setting prompt')
    $(table-item cmd_prompt "'M-x '" 'command line prompt')
    $(table-item cancelhex "'18 0' (C-x)" 'keybinding to exit debug input menu')
    $(table-item default_mode ' edit' 'what mode should be set on launch')
    $(table-item help_message "'F10 to open menu'" 'top right help message')
    $(table-item dired_message "'Pick a file'" 'same as above but for dired buffer')
    $(table-bottom)
EOF2
)

    $(title 'KEYBINDING ARRAYS')

$(text '    ' <<EOF2
Keybinding arrays match with modes. The array has to be associative and nammed $(code 'keys_<mode>'). $(code 'keys_def') is reserved and used as reference for other arrays, it's also reversed compared to other keybinding arrays.
EOF2
)

$(text '     ' <<EOF2
Keybindings are defined via hexadecimal syntax suffixed with ' 0'. Function $(code '@kbd field') is equivalent to $(code '${keys_def[field]}') but nicer. Function kbd provides Emacsy keybinding syntax.
EOF2
)

$(text '    ' <<EOF2
There is also a optionable option array possible for all keybinding arrays. Currently only defined option is [else] which defines what should happen if no key is matched from the keybinding. These arrays have to be named $(code 'key_options_<mode>').
EOF2
)

    $(title MODES)

$(text '    ' <<EOF2
Modes determine used keybinding and other properties of buffer.
EOF2
)

$(table-init 2 19 43; table-char
print-stdin <<EOF2
    $(table-top)
    $(table-title NAME DESCRIPTION)
    $(table-title-line)
    $(table-item edit "general editing mode")
    $(table-item dired "mode used in file picker")
    $(table-item view "read-only mode")
    $(table-item menu "mode of menus")
    $(table-item debuginput "for getting input codes (M-x input)")
    $(table-item prefix "for C-x prefix")
    $(table-item prefix_help "for C-h prefix")
    $(table-item quit "for quit confirmation")
    $(table-item list_buffers "used in buffer switcher")
    $(table-bottom)
EOF2
)

    $(title STYLE)

$(text '    ' <<EOF2
Style of stuff is defined as escape code. See extensions/gruvboxdark for example of custom theme.
EOF2
)

$(table-init 3 32 19 39; table-char
print-stdin <<EOF2
    $(table-top)
    $(table-title NAME DEFAULT DESCRIPTION)
    $(table-title-line)
    $(table-item default ' \e[m' 'Default face')
    $(table-item TODO ' \e[0;97;45m' "Highlighting of 'TODO: '")
    $(table-item NOTE ' \e[0;97;100m' "Highlighting of 'NOTE: '")
    $(table-item menu ' \e[0;37;40' 'Menuline')
    $(table-item menu-enabled-face ' \e[0;37;40' 'Items of menuline')
    $(table-item selected ' \e[30;45m' 'Selected item')
    $(table-item link ' \e[94m' 'Redirects')
    $(table-item menu-selected-face ' \e[30;45m' 'Selected item of menu')
    $(table-item mode-line ' \e[40;97m' 'Bottom statusline')
    $(table-item line-number ' \e[0;90m' 'Line count')
    $(table-item line-number-empty ' \e[0;90m' 'Lines that do not exist')
    $(table-item line-number-current-line ' \e[0;91m' 'Currently selected line')
    $(table-item tab-face ' \e[0;90m' 'Tabs')
    $(table-item minibuffer-prompt ' \e[m' 'Bottom commandline')
    $(table-divider)
    $(table-item font-lock-variable-string-face ' \e[0;36;48m' 'Quoted variables')
    $(table-item font-lock-comment-face ' \e[3;37;48m' 'Comments')
    $(table-item font-lock-variable-name-face ' \e[0;96m' 'Variables')
    $(table-item font-lock-argument-face ' \e[0;93m' 'Options')
    $(table-item font-lock-flow-face ' \e[0;93m' 'Control flow')
    $(table-item font-lock-pipe-face ' \e[1;94m' 'Pipes')
    $(table-item font-lock-bracket-face ' \e[1;95m' 'Brackets')
    $(table-item font-lock-constant-face ' \e[0;92m' 'Constants')
    $(table-item font-lock-string-face ' \e[0;32m' 'Strings')
    $(table-item font-lock-assign-face ' \e[0;94;108m' 'Variable assignments')
    $(table-item font-lock-function-name-face ' \e[0;30;44m' 'Function definitions')
    $(table-item font-lock-declare-face ' \e[0;91m' 'Keywords')
    $(table-bottom)
EOF2
)
$(text '    ' <<EOF2
Ebashs also includes the ansi-color-* faces, see M-x list-faces-display for full list.
EOF2
)

    $(title SYNTAX)

$(text '    ' <<EOF2
Defines which syntax functions should be used for which file types.
EOF2
)

    $(title MENULINE)

$(text '    ' <<EOF2
Defines items in menuline, content of keys defines which functions should be ran on invocation.
EOF2
)

    $(title MENUS)

$(text '    ' <<EOF2
Each menu has to have helper function to set it up on request:
EOF2
)
$(code-block bash <<EOF2
        <menu>() { declare -ng menucon=<menu>; menu; }
EOF2
)
$(text '    ' <<EOF2
The contents of menu are defined by an associative  array.
EOF2
)

    $(title ALIAS)

$(text '    ' <<EOF2
Defines aliases that can be used in $(code 'M-x').
EOF2
)
$(text '    ' <<EOF2
Use function $(code add-alias name command) to define.
EOF2
)

$(title EXTENDING)

$(text <<EOF2
Some of useful variables and for extending Ebashs
EOF2
)

$(table-init 2 19 43; table-char
print-stdin <<EOF2
$(table-top)
$(table-title NAME DESCRIPTION)
$(table-title-line)
$(table-item buffer 'File data')
$(table-item buffersyntax 'Multidimensional buffer for rendering')
$(table-item bufferexpand 'Special characters filtered out')
$(table-item bufferdata 'Options of current buffer')
$(table-item charmap 'Definitions for bufferexpand')
$(table-item mode 'Current mode')
$(table-item commands 'List of M-x commands')
$(table-bottom)
EOF2
)

$(title 'SYNTAX HIGHLIGHTING')

$(text <<EOF2
Ebashs handles highlighting via checking 'syntax' array which consists of $(code '[file type]=syntax-function')
EOF2
)

    $(title 'SYNTAX FUNCTIONS')

$(text '    ' <<EOF2
Here is sample bash syntax function included with Ebashs:
EOF2
)

$(code-block bash <<EOF2
    set-highlight
        :: shell bash ksh dash sh mksh zsh ash oksh i*bash

	defun syntax-shell
		:: Syntax function for shell
		:: Used faces:
		:: '    * font-lock-declare-face'
		:: '    * font-lock-variable-string-face'
		:: '    * font-lock-comment-face & sets comment to 1 for syntax-word function'
		:: '    * font-lock-variable-name-face'
		:: '    * font-lock-argument-face'
		:: '    * font-lock-function-name-face'
		:: '    * font-lock-flow-face'
		:: '    * font-lock-pipe-face'
		:: '    * font-lock-bracket-face'
		:: '    * font-lock-constant-face'
		:: '    * font-lock-string-face'
		:: '    * font-lock-assign-face'
		:: '    * font-lock-keyword-face'
		:: '    * font-lock-default-face'
		function =
			case "${word}" in
				*'=()'|'declare'|'local'|'typeset') set-face font-lock-declare-face;;
				'"$'*) set-face font-lock-variable-string-face;;
				'#'*) set-face font-lock-comment-face && comment=1;;
				'$'*) set-face font-lock-variable-name-face;;
				'-'*) set-face font-lock-argument-face;;
				*'()') set-face font-lock-function-name-face;;
				'||'|'&&'|';'|'&') set-face font-lock-flow-face;;
				'>'|'<'|'|'|'>>'|'<<'|'<<<') set-face font-lock-pipe-face;;
				'('|')'|'{'|'}'|'[['|']]'|'['|']') set-face font-lock-bracket-face;;
				'function') set-face font-lock-function-name-face;;
				*"'"*) set-face font-lock-constant-face;;
				*'"'*) set-face font-lock-string-face;;
				*'='*) set-face font-lock-assign-face;;
				'echo'|'return'|'case'|'esac'|'for'|'while'|'do'|'done'|'if'|'elif'|\\
					'else'|'printf'|'fi'|'continue'|'exit'|'bind'|'then'|'break'|'read'|\\
					'let'|'shopt'|'trap'|'set'|'eval'\\
						) set-face font-lock-keyword-face;;
				*) set-face default;;
			esac
EOF2
)

$(text '    ' <<EOF2
The comments are handled specially via comment variable which gets reseted at every newline.
EOF2
)

$(title EXAMPLES)

$(text <<EOF2
A simple function to jump to line 11 when $(code 'C-x M-e') is pressed:
EOF2
)

$(code-block bash <<EOF2
    keys_prefix+=( # prefix is the mode for C-x
        [1b 65 0]='jump-to-11' # '1b 65 0' is the M-e in hex.
                               # You can use the M-x input to convert to hex. format.
    )
    jump-to-11() {
        [[ -n "${buffer[11]}" ]] && line=11 # If line 11 exists, set current line to 11.
        [[ "${bufferdata[mode]}" = 'prefix' ]] && quit-prefix
                                    # Since the key stroke contains C-x as prefix,
                                    # quit-prefix is is required as otherwise
                                    # it would stay in 'prefix' mode.
        redraw # Redraw whole buffer.
    }
EOF2
)

$(text <<EOF2
A function to write $(code 'Hello world!') at current cursor position when $(code 'M-x hi') is typed
EOF2
)

$(code-block bash <<EOF2
    commands+=(
        [hi]='hello-world' # Add command 'hi' invoking 'hello-world' function:
    )
    hello-world() {
        insert-word 'Hello-world!' # The function 'insert-word' handles insertion
                                   # of stuff, so no redraw or other magic is needed.
    }
EOF2
)

$(text '    ' <<EOF2
Create a menu containing previous functions $(code 'jump-to-11') & $(code 'hello-world'):
EOF2
)

$(code-block bash <<EOF2
    example-menu-function() { declare -ng menucon='example_menu'; menu; }
    # A function with which the menu will be invoked.

    declare -A example_menu
    example_menu=(
        [Jump to 11  ]='jump-to-11'  # The names of items in menu should have
        [Hello world!]='hello-world' # same width to display correctly.
    )

    # Add the example_menu into default menuline
    menulineedit+=(
        [Example]='example-menu-function'
    )
EOF2
)

$(title ETC)

$(text <<EOF2
Logo and it's krita file is in etc/

This readme is generated from doc/README.bml via makedoc script.
EOF2
)

$(title CREDITS)

$(text '    ' <<EOF2
Based on https://github.com/comfies/bed
EOF2
)

$(text '    '<<EOF2
fff by Dylan Araps https://github.com/dylanaraps/fff as base for extensions/efff
Licensed under the MIT license see extensions/efff for details
EOF2
)

$(text '    '<<EOF2
Early versions of Ebashs/Bano can be found at
https://github.com/aeknt/bashbox/blob/master/bin/nano
https://github.com/aeknt/bashbox/blob/master/bin/bano
EOF2
)
EOF
	# MAKEDOC INSERT README STOP
}

defun describe-function
	:: Displays help and info of function
	function = {
		redraw
		read-command 'Describe function: ' function || return 1
	    doc-select "$function"
	}

defun describe
	:: Displays help and info of all functions
	function = {
	    save openfiledoc
		declare-new-buffer
			:: line 9
			:: base 1
			:: column 0
			:: info "Documentation"
			:: mode format
			:: filetype 'format'
			:: file "*functions*"
			:: modified 0
			:: syntax syntax-format
			:: syntax-exec 1
			:: menuline 'dialog'
		size-full
		buffer=(
			''
		    "$format_nav"
			''
			'<f> title <u> Functions </u> </f>'
			'<i-tab>'
			'Documentation of these function is defined via internal pseudo-comments.'
			'It consists of the description and the source code. The source code is formated automatically'
			'by Bash and differs greatly from the formating of real source code.'
			'</i>'
)
		while read -r fn;  do
			buffer+=("<a> doc-select ${fn:11} : <f> link ${fn:11} </f> </a>")
		done <<< "$(declare -F)"
		buffer+=(
			''
			"<tab> <f> font-lock-comment-face Ebashs $version </f>"
		)
		redraw
}

defun doc-select	
	:: Select documentation item
	function = {
		local function="$@"
	    save openfile
		declare-new-buffer
			:: line 5
			:: info "Describe"
			:: mode format
			:: format-else quit-view
			:: filetype 'format'
			:: file "*describe*"
			:: modified 0
			:: syntax syntax-format
			:: syntax-exec 1
			size-full
		buffer=(
			''
			"$format_nav"
			''
		)
		mapfile -t -O 3 buffer <<< "$(get-description "$function")"
	    redraw
	}
nufed

@@ doc-goto
:: Replace function documentation with function \$1.
:: 'See <a> doc-goto get-description : <f> link get-description </f> </a> for more details.'
function doc-goto {
	clear-buffer
	bf_d[line]=1
	bf_d[column]=0
    buffer=(
		''
		"$format_nav"
		''
	)
	mapfile -t -O 3 buffer <<< "$(get-description "$1")"
	redraw
}

defun quit-doc
	:: Quits and restores previous buffer.
	function = {
		restore openfiledoc
		redraw
	}

defun get-description
	:: Prints desciption of function \$1
	function = {
		is-function "$1" || {
			echo "<f> highlight $1 is not a Ebashs function </f>"
			return
		}
		printf "%s\n" "<f> title [ $1 ] </f>"
		[ -z "${descriptions[function_${1}_description]}" ] && {
			echo 'Function has no documentation'
			return
		}
		local -n fn_desc="${descriptions[function_${1}_description]}"
		((${#fn_desc[@]})) && {
			echo
			for l in "${fn_desc[@]}"; {
				printf "%s\n" "$l"
			}
			#for i in {0..8}; {
			#	printf '\n'
			#}
			#printf '<f> title [ Source ] </f>\n <change-syntax> 0 shell\n'		 
			#declare -f -- "$1"
		}
	}

defun quit-view
	:: Quits and restores previous buffer.
	:: Used mainly for dialog buffers.
	function = {
		restore openfile
		redraw
	}
nufed

@@ duplicate-line Copies line
function duplicate-line {
	newline # create new empty line
	buffer[bf_d[line]-1]="${buffer[bf_d[line]]}" # copy current line to previous line
	#make-render-area $((bf_d[line]-1)) $((bf_d[line]))
	local -n lap="${current_buffer}_syntax$((bf_d[line]-1))"
	local -n lac="${current_buffer}_syntax$((bf_d[line]))"
	copy-array lac lap
	redraw
}
	
@@ newline
:: Inserts newline to current buffer at current cursor position, shift lines
:: below one line down and go down one line.
function newline {
	bf_d[modified]=1
	save-state
	buffer=('' "${buffer[@]:1:${bf_d[line]}-1}" '' "${buffer[@]:${bf_d[line]}}")
	buffer[bf_d[line]]="${buffer[${bf_d[line]}+1]:0:${bf_d[column]}}"
	buffer[bf_d[line]+1]="${buffer[${bf_d[line]}+1]:${bf_d[column]}:${#buffer[${bf_d[line]}+1]}}"
	bf_d[column]=0
	syntax-shift
	no_cursor=1
	redraw
	no_cursor=0
	next-line
}

@@ syntax-shift
:: Moves syntax multibuffer from current cursor position one line to the bottom.
:: Used in newline function.
::
:: Is currently very badly implemented, TODO: fix.
function syntax-shift {
	local -a tmp1
	local -a tmp2
	local extmp1
	local extmp2
	for ((l=bf_d[line];l<${#buffer[@]}+1;l++)); do
		local -n linearray="${current_buffer}_syntax${l}"
		copy-array linearray tmp1
		copy-array tmp2 linearray
		copy-array tmp1 tmp2
		extmp1="${bf_e[l]}"
		bf_e[l]="$extmp2"
		extmp2="$extmp1"
	done
	bf_s[buffer_length]="${current_buffer}_syntax${bf_d[number-length]}"
	unset tmp1 tmp2
	make-render-area $((bf_d[line])) $((bf_d[line]+2))
}

defun delete-line
	:: Deletes line at current cursor position
	function = {
		bf_d[modified]=1
		buffer-delete-line "${bf_d[line]}"
		((bf_d[line] == 1)) || previous-line
		redraw
	}

defun buffer-delete-line
	:: Deletes line at \$1
	function = {
		local -i l=$1
		save-state
		buffer=("" "${buffer[@]:1:l-1}" "${buffer[@]:l+1}")
		bf_s=("" "${bf_s[@]:1:l-1}")
	}

fragment getrlr <<'+'
	local -i rlr
	unset ta
	local ta
	ta=${bf_e[${bf_d[line]}]:0:${bf_d[column]}}
	ta=${ta//[^t]}
	ta=${#ta}
	rlr=$((bf_d[column] + ta / 4 - ta))
+

fragment predelete <<'+'
	((bf_d[selection])) && {
		delete-selection
		return
	}
	((${#buffer[${bf_d[line]}]} == 0 )) && {
		delete-line
		bf_d[column]="${#buffer[${bf_d[line]}]}"
		redraw
		return 0
	}
+

defun-fragment backspace
	:: Deletes previous character
	function = {
		save-state
		@ predelete
		@ getrlr
		((rlr==0)) && {
			buffer[bf_d[line]-1]="${buffer[bf_d[line]-1]}${buffer[bf_d[line]]}"
			delete-line
			bf_d[column]=${#bf_e[${bf_d[line]}]}
			redraw
			return 0
		}
		buffer[${bf_d[line]}]="${buffer[${bf_d[line]}]:0:$(( rlr - 1 ))}${buffer[${bf_d[line]}]:${rlr}}"
		backward-char #go back with cursor
		make-render-line # copy the buffer into bf_s and bf_e
		redraw #draw it
		bf_d[modified]=1
	}

defun-fragment delete
	:: Deletes next character
	function = {
		save-state
		@ predelete
		@ getrlr
		((rlr==${#buffer[bf_d[line]]})) && {
			buffer[bf_d[line]]="${buffer[bf_d[line]]}${buffer[bf_d[line]+1]}"
			move-next-line
			delete-line
			bf_d[column]=${#bf_e[${bf_d[line]}]}
			redraw
			return 0
		}
		buffer[bf_d[line]]="${buffer[bf_d[line]]:0:rlr}${buffer[bf_d[line]]:rlr+1:${#buffer[bf_d[line]]}}"
		make-render-line # copy the buffer into bf_s and bf_e
		redraw #draw it
		bf_d[modified]=1
	}

defun delete-selection
	:: Deletes region
	function = {
		_ sy bf_d[selection_start_y]
		_ ey bf_d[selection_end_y]
		_ sx bf_d[selection_start_x]
		_ ex bf_d[selection_end_x]
		((sy == ey)) && {
			((sx > ex)) && __ sx ex
			buffer[sy]="${buffer[sy]:0:sx}${buffer[sy]:ex}"
			bf_d[column]=$sx
			make-render-area $sy $((sy+1))
		} || {
			((sy > ey)) && {
				__ sy ey
				__ sx ex
			}
			buffer[sy]="${buffer[sy]:0:sx}"
			buffer[ey]="${buffer[ey]:ex}"
			buffer=("" "${buffer[@]:1:sy}" "${buffer[@]:ey}")
			bf_s=("" "${bf_s[@]:1:sy-1}")
			buffer[sy+1]="${buffer[sy]}${buffer[sy+1]}"
			buffer=("" "${buffer[@]:1:sy-2}" "${buffer[@]:sy}")
			bf_d[line]=$sy
			bf_d[column]=$sx
		}
		bf_d[selection]=0
		redraw
		_ # unset reference aliases
	}

defun write-buffer
	:: Writes current buffer into its target file	
	function =
		if [ -w "${bf_d[file]}" ]; then
			dump-buffer "${bf_d[file]}"
			bf_d[modified]=0
			message="Wrote ${#buffer[@]} lines to \'${bf_d[file]}\'"
		else
			return 1
		fi

add-mode quit
	local-set-key "$(kbd y)" 'save-quit'
	local-set-key "$(kbd n)" 'die'
	local-set-key "$(kbd c)" 'quit-quit'
	local-set-key "$(kbd C-y)" 'save-quit-force'

defun save-quit-force
	:: Force saving file
	function = {
		dump-buffer "${bf_d[file]}"
		die
	}
	
defun save-quit
	:: Writes buffer if target is writable
	function =
		if write-buffer; then
			die
		else
			message='File is not writable! [n/c] (to force save C-y)'
			redraw-commandline
		fi

defun quit-quit
	:: Quits quit message
	function = {
		bf_d[mode]="$bckmode"
		message='Quit canceled'
		redraw
	}

defun quit
	:: Displays quit message and sets mode to \'quit\'
	function = {
		[ -n "${bf_d[isfile]}" ] && ((bf_d[isfile]==0)) || ((bf_d[modified]==0)) && {
			die
		}
		
		[ -z "$bckmode" ] && bckmode="${bf_d[mode]}"
		bf_d[mode]='quit'
		redraw-statusline
		printf '\e[%s;0H' $((bf_d[size-y] + bf_d[loc-y]))
		printf '%s' 'Buffer modified, save before close? [y/n/c]'
	}

defun set-mark-command
	:: Begins selection	
	function =
		if ((bf_d[selection])); then
			log info 'selection disable'
			bf_d[selection]=0
		else
			bf_d[selection]=1
			bf_d[selection_start_y]="${bf_d[line]}"
			bf_d[selection_start_x]="${bf_d[column]}"
			log info 'selection enable'
		fi

defun shell
	:: Spawns bash as subprocess
	function = {
		clear-screen
		bash # NOTE: in theory an external command
		redraw
	}

defun execute
	:: Executes a command and inserts its output into buffer	
	function = {
		((bf_d[line] == 0)) && return # If the line is not possible, do nothing
		printf '\e[?25h\e[%sH' "$((bf_d[line] + 2 - bf_d[base]))" # Reset cursor position and enable cursor
		read -re -p "$(printf '%4s ' "$")" # Present editable line
		if [[ "$REPLY" != "${buffer[${bf_d[line]}]}" ]]; then # If the line is changed, update and inform
			buffer[${bf_d[line]}]="$($REPLY)"
			bf_d[modified]=1
		fi
		make-render-line
		redraw
	}

defun diff-buffer-syntax
	:: Deletes highlighting on modified lines, comparing two buffers
	function = {
		# remove outdated lines from bf_s to set them for resyntaxing
		local -n source="$1"
		local -n target="$2"
		for idx in "${!target[@]}"; do
			[ "${source[idx]}" = "${target[idx]}" ] || bf_s[idx]=
		done
	}

defun diff-buffer-copy
	:: Compares two buffers and copies the difference into \$3 buffer
	function = {
		local -n source="$1"
		local -n check="$2"
		local -n target="$3"
		[ -z "${source[*]}" ] && return 1 # | indicate that there's no previous buffer state to check against 
		[ -z "${check[*]}"  ] && return 1 # | should indicate save-state() to just copy the whole buffer
		target=()
		for idx in "${!source[@]}"; do
			[ "${source[idx]}" = "${check[idx]}" ] || target[idx]="${source[idx]}"
			[ "${source[idx]}" = "${check[idx]}" ] && target[idx]=''
		done
	}

defun diff-buffer-merge
	:: Add buffer \$1 on top of \$2
	function = {
		local -n source="$1"
		local -n target="$2"
		for idx in "${!source[@]}"; do
			[ -n "${source[idx]}" ] && target[idx]="${source[idx]}"
		done
	}

defun save-state
	:: Saves current buffer for undo function
	function = {
		((bf_d[current_state]++))
		declare -ga "${current_buffer}_buffer_state_${bf_d[current_state]}"
		diff-buffer-copy\
			buffer\
			"${current_buffer}_buffer_state_$((bf_d[current_state]-1))"\
			"${current_buffer}_buffer_state_${bf_d[current_state]}" || {
			copy-array buffer "${current_buffer}_buffer_state_${bf_d[current_state]}"
		}
	}

defun undo
	:: Undo a change
	function = {
		((bf_d[current_state]--))
		((bf_d[current_state]<0)) && {
			bf_d[current_state]=0
			bf_d[modified]=0
		}
		diff-buffer-syntax buffer "${current_buffer}_buffer_state_${bf_d[current_state]}"
		diff-buffer-merge "${current_buffer}_buffer_state_${bf_d[current_state]}" buffer
		redraw
	}

defun toggle-mouse
	:: 'Changes options[mouse]'
	function =
		case "${options[mouse]}" in
			0)
				printf '\e[?1000;1006;1015h'
				options[mouse]=1
				message='Enabled options[mouse]';;
			1)
				printf '\e[?1000;1006;1015l'
				options[mouse]=0
				message='Disabled options[mouse]'
		esac

defun toggle-mode-line
	:: 'Changes options[mode-line]'
	function =
		case "${options[mode-line]}" in
			0)
				options[mode-line]=1
				((bottomlines++))
				redraw;;
			1)
				options[mode-line]=0
				((bottomlines--))
				redraw
		esac

defun toggle-command-line
	:: 'Changes options[command-line]'
	function =
		case "${options[command-line]}" in
			0)
				options[commandline]=1
				((bottomlines++))
				redraw;;
			1)
				options[command-line]=0
				((bottomlines--))
				redraw
		esac

defun toggle-line-number-mode
	:: 'Changes options[line-number-mode]'
	function = {
		case "${options[line-number-mode]}" in
			0) options[line-number-mode]=1;;
			1) options[line-number-mode]=0
		esac
		redraw
	}

defun toggle-menu-line
	:: 'Changes options[menu-line]'
	function = {
		case "${options[menu-line]}" in
			0) options[menu-line]=1;;
			1) options[menu-line]=0
		esac
		toplines="${options[menu-line]}"
		redraw
	}
nufed
	
@fn self-insert 'insert-word $@'
@fn insert-space 'insert-word " "'
@fn indent-for-tab-command "insert-word '	'"

@@ load-config Sources custom config file
function load-config {
	log_buffer+=('LOADING CONFIG...')
	local config_file
	local f
	f=~/.config/ebashsrc.d/init.bash ;[ -f "$f" ] && config_file="$f"
	f=~/.config/ebashsrc ;[ -f "$f" ] && config_file="$f"
	f=~/.ebashsrc ;[ -f "$f" ] && config_file="$f"
	f=~/.ebashsrc.d/init.bash ;[ -f "$f" ] && config_file="$f"
	f=.ebashsrc ;[ -f "$f" ] && config_file="$f"
	f=.ebashsrc.d/init.bash ;[ -f "$f" ] && config_file="$f"
	
	f="${EBASHS_CONFIG}" ;[ -n "$f" ] && [ -f "$f" ] && config_file="$f"
	f="${EBASHS_CONFIG_DIR}/init.bash" ;[ -n "$f" ] && [ -f "$f" ] && config_file="$f"
	
	[ -z "$config_file" ] && return
	source "$config_file"
	log_buffer+=("LOADED $config_file")
}

@@ scratch
:: Empty buffer
function scratch {
	log info "loading empty buffer..."
	declare-new-buffer
		:: mode "${options[default_mode]}"
		:: info "${options[help-message]}"
		:: filetype "bash"
		:: file "*scratch*"
		:: isfile 0
		:: menuline welcome
		:: current_state 0
	set-syntax
	size-full

	buffer=(
		''
		'# This buffer is for text that is not saved, and for Bash evaluation.'
		'# To create a file, visit it with C-x C-f and enter text in its buffer.'
		''
	)
		
	message="For information about Ebashs and the BASH system, type C-h C-a."
	bf_d[line]=1 # Indicate that we have a buffer loaded
	bf_d[modified]=0
}

@@ welcome-buffer
:: Show welcome message
function welcome-buffer {
	log info "loading welcome buffer..."
	declare-new-buffer
		:: mode welcome
		:: info "${options[help-message]}"
		:: filetype "format"
		:: file "*welcome*"
		:: isfile 0
		:: menuline welcome
		:: current_state 0
		:: syntax syntax-format
		:: syntax-exec 1
	size-full

	buffer=(
		''
		'<f> title <u> Ebashs </u> </f>'
		'<i-tab>'
		' Welcome to Ebashs the editor of pure Bash.'
		'</i>'
		'<f> title <u> Actions </u> </f>'
		'<tab> <a> find-file : <f> red Open <f> title f </f-> ile </f> </a>'
		'<tab> <a> dired : <f> yellow <f> title B </f-> rowse files </f> </a>'
		'<tab> <a> manual : <f> green View <f> title m </f-> anual </f> </a>'
		'<tab> <a> view-page : <f> cyan View <f> title d </f-> ocumentation </f> </a>'
		'<tab> <a> about : <f> blue <f> title A </f-> bout Ebashs </f> </a>'
		'<tab> <a> inputcodes : <f> magenta <f> title I </f-> nput debugging </f> </a>'
		'<tab> <a> list-faces-display : <f> red Fa <-f> title c </f-> es </f> </a>'
	)
	((log)) && buffer+=(
		'<tab> <a> view-log : <f> yellow <f> title L </f-> og </f> </a>'
	)
		
	message="For information about Ebashs and the BASH system, type C-h C-a."
	bf_d[line]=1 # Indicate that we have a buffer loaded
	bf_d[modified]=0
}

@@ init
:: Prepares variables and launches main function
function init {
	case "$1" in
		'--quick'|'-Q')
			log_buffer+=('- LOAD DEFAULT CONFIG -')
			load-default-config
			shift;;
		'--version')
			echo "$version"
			abort;;
		'--dump')
			declare -f
			echo 'init "$@"'
			abort;;
		'--help')
			print-stdin <<EOF
Usage: ebashs [OPTION-OR-FILENAME]...

Run Ebashs, the extensible, customizable, maybe-real-time
display editor.  The recommended way to start Ebashs for normal editing
is with no options at all.

Run C-h r RET inside Ebashs to read "manual".

Initialization options:
--quick, -Q    don't load config
--help,        display this help and exit
--version,     display version information and exit
--view, -v     open file for viewing if possible
--exec, -e     execute file as script with Ebashs features
EOF
			abort;;
		'--view'|'-v')
			log_buffer+=('- LOAD DEFAULT CONFIG -')
			options[view]=1
			load-default-config
			load-default-config-ebashs #loads default config
			load-config
			shift;;
		'--exec'|'-e')
			log_buffer+=('- LOAD DEFAULT CONFIG -')
			options[view]=1
			options[no-file]=1
			load-default-config
			load-default-config-ebashs #loads default config
			load-config
			source "$2"
			shift;;
		*)
			log_buffer+=('- LOAD DEFAULT CONFIG -')
			load-default-config
			load-default-config-ebashs #loads default config
			load-config
	esac
	init-var
	
	if [[ "$1" ]]; then # If a file was provided in the terminal pre-load it
		log info "args: $1"
		if [ -d "$1" ]; then
			log info "[$1] is directory => dired"
			cd "$1" || exit
			dired # enter the file selector in specified folder
		else
			log info "[$1] is file => read-buffer"
			read-buffer "$1"
		fi
	else
		log info "no arg => scratch"
		if ((options[welcome-buffer])); then
			welcome-buffer
		else
			scratch
		fi
	fi
	log info "drawing..."
	redraw
	log info 'entering main loop...'
	main
}

log_buffer+=('INIT')
init "$@"
;;
env)
#!/usr/bin/env bash
#
# env in pure bash.

mapfile -t envars < <(compgen -v)

for var in "${envars[@]}"; do
    printf '%s=%s\n' "$var" "${!var}"
done
;;
exec)
#!/usr/bin/env bash
shift #shift so when running bashbox exec command it wont try to exec exec
exec $@
;;
expand)
#!/usr/bin/env bash
#
# expand in pure bash.

[[ ! -f $1 ]] && {
    printf '%s\n' "expand: $1: No such file or directory." >&2
    exit 1
}

file="$(< "$1")"
printf '%s\n' "${file//$'\t'/'        '}"
;;
expr)
#!/usr/bin/env bash
#
# expr in pure bash.
if [ -z "$*" ]; then
	while true
	do
		read -rep ':' expre
		printf '%s\n' "$(($expre))"
	done
else	
	printf '%s\n' "$(($@))"
fi
;;
exprf)
#!/bin/bash
floatpoint='.'
makeunfloat() {
	IFS=$floatpoint read -ra n <<< "$1"
	floatlenght="${#n[1]}"
	echo "${n[0]}${n[1]}"
}
makefloat() {
	len=$2
	num=$1
	[ ${#num} -lt "$len" ] && {
		echo echo -n 0
	}
	[ ${#num} = "$len" ] && {
		echo -n 0
	}
	tmp=$(( ${#num} - len ))
	echo "${1:0:$tmp}${floatpoint}${1: -$2}"
}
getfloatlenght() {
	IFS=$floatpoint read -ra n <<< "$1"
	echo "${#n[1]}"
}
calculate() {
	inta="$1"
	oper="$2" && [ ! "$oper" = '+' ] && [ ! "$oper" = '-' ] && [ ! "$oper" = '*' ] && [ ! "$oper" = '/' ] && echo unknown operation && exit
	intb="$3"
	[[ ! $inta == *.* ]] && inta=${inta}.0
	[[ ! $intb == *.* ]] && intb=${intb}.0
	if [ ! $(getfloatlenght $inta) = $(getfloatlenght $intb) ]; then
		floatlenghtinta=$(getfloatlenght $inta)
		floatlenghtintb=$(getfloatlenght $intb)
		if [ $floatlenghtinta -gt $floatlenghtintb ]; then
			last=$(( floatlenghtinta - floatlenghtintb ))
			intb=$(echo -n $intb
				for ((i=1;i<=last;i+=1)); {
			    	printf '%s' 0
				}
			)
			floatlenght=$(getfloatlenght $inta)
		elif [ $floatlenghtinta -lt $floatlenghtintb ]; then
			last=$(( floatlenghtintb - floatlenghtinta ))
			inta=$(echo -n $inta
				for ((i=1;i<=last;i+=1)); {
					printf '%s' 0
				}
			)
			floatlenght=$(getfloatlenght $intb)
		fi
	else
		floatlenght=$(getfloatlenght $inta)
	fi
	[ "$oper" = '*' ] && floatlenght=$(( floatlenght * 2 ))
	[ "$oper" = '/' ] && {
		inta=$(echo -n $inta
			for ((i=1;i<=floatlenght;i+=1)); {
				printf '%s' 0000000000000000
			}
		)
		floatlenght=$(( floatlenght + 15 ))
	}
	echo $(makefloat $(( $(makeunfloat $inta) $oper $(makeunfloat $intb) )) $floatlenght )
}
parse() {
	#inta="$1"
	#oper="$2" && [ ! "$oper" = '+' ] && [ ! "$oper" = '-' ] && [ ! "$oper" = '*' ] && [ ! "$oper" = '/' ] && echo unknown operation && exit
	#intb="$3"
	for arg in "$@"; {
		[[ ! $arg == *.* ]] && continue
		IFS=$floatpoint read -ra n <<< "$arg"
		maxlenght="${#n[1]}"
	}
	floatlenght=$maxlenght
	mathline=$(
		echo -n 'echo $(makefloat $(( '
		for arg in "$@"; {
			[ "$arg" = '+' ] && echo -n '+ ' && continue
			[ "$arg" = '-' ] && echo -n '- ' && continue
			[ "$arg" = '*' ] && echo -n '* ' && continue
			[ "$arg" = '/' ] && echo -n '/ ' && continue
			number=$([[ ! $arg == *.* ]] && echo -n "${arg}.0" && continue; echo -n "${arg}")
			currentlenght=$(getfloatlenght "$number" )
			last=$(( maxlenght - currentlenght ))
			echo -n '10#$(makeunfloat '"$(
				echo -n "$number"
				for ((i=1;i<=last;i+=1)); {
			    	printf '%s' 0
				}
			)"') '
		}
		echo -n ')) $floatlenght)'
	)
	eval "${mathline}"
}
#shift
calculate "$@"
#parse "$@"
;;
factor)
#!/bin/bash
n=$1
for ((i=n;i>=1;i-=1)); {
	[ $(( n / i * i )) = $n ] && printf "$i "
}
echo
;;
false)
#!/usr/bin/env bash
#
# false in pure bash.

exit 1
;;
figlethd)
#!/bin/bash
#it seems to work on xterm but not on alacritty
printf "\e#3"
echo "$@"
printf "\e#4"
echo "$@"
;;
find)
#!/bin/bash
recurse() {  
	[ ! -d "$1" ] && return
	for i in "$1"/.* "$1"/*; do
		path=${i//\/\//\/} # replace all double slashes
		#skip . and ..
		[ "${path##*/}" = '.' ] && continue
		[ "${path##*/}" = '..' ] && continue
		echo "$path"
		# dont follow symbolic links
		[ -L "$path" ] && continue
		# recurse down dirs
		[ -d "$path" ] && recurse "$path"
	done
}
recurselinks() {  
	[ ! -d "$1" ] && return
	for i in "$1"/.* "$1"/*; do
		path=${i//\/\//\/} # replace all double slashes
		#skip . and ..
		[ "${path##*/}" = '.' ] && continue
		[ "${path##*/}" = '..' ] && continue
		echo "$path"
		# recurse down dirs
		[ -d "$path" ] && recurse "$path"
	done
}
if [ -z "$1" ]; then
	recurse .
else
	if [ "$1" = "-P" ]; then
		shift
		for file in "$@"; {
			recurse "$file"
		}
	elif [ "$1" = "-L" ]; then
		shift
		for file in "$@"; {
			recurselinks "$file"
		}
	else
		for file in "$@"; {
			recurse "$file"
		}
	fi
fi
;;
findfast)
#!/bin/bash
shopt -s globstar
if [ -z "$1" ]; then
	printf '%s\n' .*.*
	printf '%s\n' **
else
	cd "$1" || return
	printf '%s\n' .*.*
	printf '%s\n' **
fi
;;
free)
#!/bin/bash
line(){
	#copy of getlines script
	#make array with all lines mapped to line numbers
	n=0
	while read -r line
	do
		n=$(( n + 1 ))
		lines[$n]="$line"
	done
	for arg in "$@"
	do
		#echo the line requested from the array
		echo "${lines[$arg]}"
	done
	
}
printf '%s\n' "$(</proc/meminfo)" | line 1 2 21 5 3
;;
ftype)
#!/bin/bash
[ $# = 0 ] && exit
IFS='.'
filename="${1%/}"
filename="${filename##*/}"
filenamesplit=($filename)
extension="${filenamesplit[-1]}"
[ "${#filenamesplit[@]}" -gt 1 ] && echo "$extension" && exit
mapfile -n 1 file_data < "$1"
shebang="$(echo -n "${file_data[@]}")"
[ ! "${shebang:0:1}" = '#' ] && echo unknown && exit
shebang="${shebang%/}"
IFS=' '
shebang="${shebang##*/}"
shebangsplit=($shebang)
printf '%s\n' "${shebangsplit[-1]}"
;;
getlines)
#!/bin/bash
#make array with all lines mapped to line numbers
n=0
while read -r line
do
	n=$(( n + 1 ))
	lines[$n]="$line"
done
for arg in "$@"
do
	#echo the line requested from the array
	echo "${lines[$arg]}"
done
;;
getopt)
#!/bin/bash
getopt() {
  # pure-getopt, a drop-in replacement for GNU getopt in pure Bash.
  # version 1.4.5
  #
  # Copyright 2012-2021 Aron Griffis <aron@scampersand.com>
  #
  # Permission is hereby granted, free of charge, to any person obtaining
  # a copy of this software and associated documentation files (the
  # "Software"), to deal in the Software without restriction, including
  # without limitation the rights to use, copy, modify, merge, publish,
  # distribute, sublicense, and/or sell copies of the Software, and to
  # permit persons to whom the Software is furnished to do so, subject to
  # the following conditions:
  #
  # The above copyright notice and this permission notice shall be included
  # in all copies or substantial portions of the Software.
  #
  # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  # OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  # MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  # IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  # CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  # TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  # SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

  _getopt_main() {
    # Returns one of the following statuses:
    #   0 success
    #   1 error parsing parameters
    #   2 error in getopt invocation
    #   3 internal error
    #   4 reserved for -T
    #
    # For statuses 0 and 1, generates normalized and shell-quoted
    # "options -- parameters" on stdout.

    declare parsed status
    declare short long='' name flags=''
    declare have_short=false

    # Synopsis from getopt man-page:
    #
    #   getopt optstring parameters
    #   getopt [options] [--] optstring parameters
    #   getopt [options] -o|--options optstring [options] [--] parameters
    #
    # The first form can be normalized to the third form which
    # _getopt_parse() understands. The second form can be recognized after
    # first parse when $short hasn't been set.

    if [[ -n ${GETOPT_COMPATIBLE+isset} || $1 == [^-]* ]]; then
      # Enable compatibility mode
      flags=c$flags
      # Normalize first to third synopsis form
      set -- -o "$1" -- "${@:2}"
    fi

    # First parse always uses flags=p since getopt always parses its own
    # arguments effectively in this mode.
    parsed=$(_getopt_parse getopt ahl:n:o:qQs:TuV \
      alternative,help,longoptions:,name:,options:,quiet,quiet-output,shell:,test,version \
      p "$@")
    status=$?
    if [[ $status != 0 ]]; then
      if [[ $status == 1 ]]; then
        echo "Try 'getopt --help' for more information." >&2
        # Since this is the first parse, convert status 1 to 2
        status=2
      fi
      return $status
    fi
    eval "set -- $parsed"

    while [[ $# -gt 0 ]]; do
      case $1 in
        (-a|--alternative)
          flags=a$flags ;;

        (-h|--help)
          _getopt_help
          return 0
          ;;

        (-l|--longoptions)
          long="$long${long:+,}$2"
          shift ;;

        (-n|--name)
          name=$2
          shift ;;

        (-o|--options)
          short=$2
          have_short=true
          shift ;;

        (-q|--quiet)
          flags=q$flags ;;

        (-Q|--quiet-output)
          flags=Q$flags ;;

        (-s|--shell)
          case $2 in
            (sh|bash)
              flags=${flags//t/} ;;
            (csh|tcsh)
              flags=t$flags ;;
            (*)
              echo 'getopt: unknown shell after -s or --shell argument' >&2
              echo "Try 'getopt --help' for more information." >&2
              return 2 ;;
          esac
          shift ;;

        (-u|--unquoted)
          flags=u$flags ;;

        (-T|--test)
          return 4 ;;

        (-V|--version)
          echo "pure-getopt 1.4.4"
          return 0 ;;

        (--)
          shift
          break ;;
      esac

      shift
    done

    if ! $have_short; then
      # $short was declared but never set, not even to an empty string.
      # This implies the second form in the synopsis.
      if [[ $# == 0 ]]; then
        echo 'getopt: missing optstring argument' >&2
        echo "Try 'getopt --help' for more information." >&2
        return 2
      fi
      short=$1
      have_short=true
      shift
    fi

    if [[ $short == -* ]]; then
      # Leading dash means generate output in place rather than reordering,
      # unless we're already in compatibility mode.
      [[ $flags == *c* ]] || flags=i$flags
      short=${short#?}
    elif [[ $short == +* ]]; then
      # Leading plus means POSIXLY_CORRECT, unless we're already in
      # compatibility mode.
      [[ $flags == *c* ]] || flags=p$flags
      short=${short#?}
    fi

    # This should fire if POSIXLY_CORRECT is in the environment, even if
    # it's an empty string.  That's the difference between :+ and +
    flags=${POSIXLY_CORRECT+p}$flags

    _getopt_parse "${name:-getopt}" "$short" "$long" "$flags" "$@"
  }

  _getopt_parse() {
    # Inner getopt parser, used for both first parse and second parse.
    # Returns 0 for success, 1 for error parsing, 3 for internal error.
    # In the case of status 1, still generates stdout with whatever could
    # be parsed.
    #
    # $flags is a string of characters with the following meanings:
    #   a - alternative parsing mode
    #   c - GETOPT_COMPATIBLE
    #   i - generate output in place rather than reordering
    #   p - POSIXLY_CORRECT
    #   q - disable error reporting
    #   Q - disable normal output
    #   t - quote for csh/tcsh
    #   u - unquoted output

    declare name="$1" short="$2" long="$3" flags="$4"
    shift 4

    # Split $long on commas, prepend double-dashes, strip colons;
    # for use with _getopt_resolve_abbrev
    declare -a longarr
    _getopt_split longarr "$long"
    longarr=( "${longarr[@]/#/--}" )
    longarr=( "${longarr[@]%:}" )
    longarr=( "${longarr[@]%:}" )

    # Parse and collect options and parameters
    declare -a opts params
    declare o alt_recycled=false error=0

    while [[ $# -gt 0 ]]; do
      case $1 in
        (--)
          params=( "${params[@]}" "${@:2}" )
          break ;;

        (--*=*)
          o=${1%%=*}
          if ! o=$(_getopt_resolve_abbrev "$o" "${longarr[@]}"); then
            error=1
          elif [[ ,"$long", == *,"${o#--}"::,* ]]; then
            opts=( "${opts[@]}" "$o" "${1#*=}" )
          elif [[ ,"$long", == *,"${o#--}":,* ]]; then
            opts=( "${opts[@]}" "$o" "${1#*=}" )
          elif [[ ,"$long", == *,"${o#--}",* ]]; then
            if $alt_recycled; then o=${o#-}; fi
            _getopt_err "$name: option '$o' doesn't allow an argument"
            error=1
          else
            echo "getopt: assertion failed (1)" >&2
            return 3
          fi
          alt_recycled=false
          ;;

        (--?*)
          o=$1
          if ! o=$(_getopt_resolve_abbrev "$o" "${longarr[@]}"); then
            error=1
          elif [[ ,"$long", == *,"${o#--}",* ]]; then
            opts=( "${opts[@]}" "$o" )
          elif [[ ,"$long", == *,"${o#--}::",* ]]; then
            opts=( "${opts[@]}" "$o" '' )
          elif [[ ,"$long", == *,"${o#--}:",* ]]; then
            if [[ $# -ge 2 ]]; then
              shift
              opts=( "${opts[@]}" "$o" "$1" )
            else
              if $alt_recycled; then o=${o#-}; fi
              _getopt_err "$name: option '$o' requires an argument"
              error=1
            fi
          else
            echo "getopt: assertion failed (2)" >&2
            return 3
          fi
          alt_recycled=false
          ;;

        (-*)
          if [[ $flags == *a* ]]; then
            # Alternative parsing mode!
            # Try to handle as a long option if any of the following apply:
            #  1. There's an equals sign in the mix -x=3 or -xy=3
            #  2. There's 2+ letters and an abbreviated long match -xy
            #  3. There's a single letter and an exact long match
            #  4. There's a single letter and no short match
            o=${1::2} # temp for testing #4
            if [[ $1 == *=* || $1 == -?? || \
                  ,$long, == *,"${1#-}"[:,]* || \
                  ,$short, != *,"${o#-}"[:,]* ]]; then
              o=$(_getopt_resolve_abbrev "${1%%=*}" "${longarr[@]}" 2>/dev/null)
              case $? in
                (0)
                  # Unambiguous match. Let the long options parser handle
                  # it, with a flag to get the right error message.
                  set -- "-$1" "${@:2}"
                  alt_recycled=true
                  continue ;;
                (1)
                  # Ambiguous match, generate error and continue.
                  _getopt_resolve_abbrev "${1%%=*}" "${longarr[@]}" >/dev/null
                  error=1
                  shift
                  continue ;;
                (2)
                  # No match, fall through to single-character check.
                  true ;;
                (*)
                  echo "getopt: assertion failed (3)" >&2
                  return 3 ;;
              esac
            fi
          fi

          o=${1::2}
          if [[ "$short" == *"${o#-}"::* ]]; then
            if [[ ${#1} -gt 2 ]]; then
              opts=( "${opts[@]}" "$o" "${1:2}" )
            else
              opts=( "${opts[@]}" "$o" '' )
            fi
          elif [[ "$short" == *"${o#-}":* ]]; then
            if [[ ${#1} -gt 2 ]]; then
              opts=( "${opts[@]}" "$o" "${1:2}" )
            elif [[ $# -ge 2 ]]; then
              shift
              opts=( "${opts[@]}" "$o" "$1" )
            else
              _getopt_err "$name: option requires an argument -- '${o#-}'"
              error=1
            fi
          elif [[ "$short" == *"${o#-}"* ]]; then
            opts=( "${opts[@]}" "$o" )
            if [[ ${#1} -gt 2 ]]; then
              set -- "$o" "-${1:2}" "${@:2}"
            fi
          else
            if [[ $flags == *a* ]]; then
              # Alternative parsing mode! Report on the entire failed
              # option. GNU includes =value but we omit it for sanity with
              # very long values.
              _getopt_err "$name: unrecognized option '${1%%=*}'"
            else
              _getopt_err "$name: invalid option -- '${o#-}'"
              if [[ ${#1} -gt 2 ]]; then
                set -- "$o" "-${1:2}" "${@:2}"
              fi
            fi
            error=1
          fi ;;

        (*)
          # GNU getopt in-place mode (leading dash on short options)
          # overrides POSIXLY_CORRECT
          if [[ $flags == *i* ]]; then
            opts=( "${opts[@]}" "$1" )
          elif [[ $flags == *p* ]]; then
            params=( "${params[@]}" "$@" )
            break
          else
            params=( "${params[@]}" "$1" )
          fi
      esac

      shift
    done

    if [[ $flags == *Q* ]]; then
      true  # generate no output
    else
      echo -n ' '
      if [[ $flags == *[cu]* ]]; then
        printf '%s -- %s' "${opts[*]}" "${params[*]}"
      else
        if [[ $flags == *t* ]]; then
          _getopt_quote_csh "${opts[@]}" -- "${params[@]}"
        else
          _getopt_quote "${opts[@]}" -- "${params[@]}"
        fi
      fi
      echo
    fi

    return $error
  }

  _getopt_err() {
    if [[ $flags != *q* ]]; then
      printf '%s\n' "$1" >&2
    fi
  }

  _getopt_resolve_abbrev() {
    # Resolves an abbrevation from a list of possibilities.
    # If the abbreviation is unambiguous, echoes the expansion on stdout
    # and returns 0.  If the abbreviation is ambiguous, prints a message on
    # stderr and returns 1. (For first parse this should convert to exit
    # status 2.)  If there is no match at all, prints a message on stderr
    # and returns 2.
    declare a q="$1"
    declare -a matches=()
    shift
    for a; do
      if [[ $q == "$a" ]]; then
        # Exact match. Squash any other partial matches.
        matches=( "$a" )
        break
      elif [[ $flags == *a* && $q == -[^-]* && $a == -"$q" ]]; then
        # Exact alternative match. Squash any other partial matches.
        matches=( "$a" )
        break
      elif [[ $a == "$q"* ]]; then
        # Abbreviated match.
        matches=( "${matches[@]}" "$a" )
      elif [[ $flags == *a* && $q == -[^-]* && $a == -"$q"* ]]; then
        # Abbreviated alternative match.
        matches=( "${matches[@]}" "${a#-}" )
      fi
    done
    case ${#matches[@]} in
      (0)
        [[ $flags == *q* ]] || \
        printf "$name: unrecognized option %s\\n" >&2 \
          "$(_getopt_quote "$q")"
        return 2 ;;
      (1)
        printf '%s' "${matches[0]}"; return 0 ;;
      (*)
        [[ $flags == *q* ]] || \
        printf "$name: option %s is ambiguous; possibilities: %s\\n" >&2 \
          "$(_getopt_quote "$q")" "$(_getopt_quote "${matches[@]}")"
        return 1 ;;
    esac
  }

  _getopt_split() {
    # Splits $2 at commas to build array specified by $1
    declare IFS=,
    eval "$1=( \$2 )"
  }

  _getopt_quote() {
    # Quotes arguments with single quotes, escaping inner single quotes
    declare s space='' q=\'
    for s; do
      printf "$space'%s'" "${s//$q/$q\\$q$q}"
      space=' '
    done
  }

  _getopt_quote_csh() {
    # Quotes arguments with single quotes, escaping inner single quotes,
    # bangs, backslashes and newlines
    declare s i c space
    for s; do
      echo -n "$space'"
      for ((i=0; i<${#s}; i++)); do
        c=${s:i:1}
        case $c in
          (\\|\'|!)
            echo -n "'\\$c'" ;;
          ($'\n')
            echo -n "\\$c" ;;
          (*)
            echo -n "$c" ;;
        esac
      done
      echo -n \'
      space=' '
    done
  }

  _getopt_help() {
    cat <<-EOT

	Usage:
	 getopt <optstring> <parameters>
	 getopt [options] [--] <optstring> <parameters>
	 getopt [options] -o|--options <optstring> [options] [--] <parameters>

	Parse command options.

	Options:
	 -a, --alternative             allow long options starting with single -
	 -l, --longoptions <longopts>  the long options to be recognized
	 -n, --name <progname>         the name under which errors are reported
	 -o, --options <optstring>     the short options to be recognized
	 -q, --quiet                   disable error reporting by getopt(3)
	 -Q, --quiet-output            no normal output
	 -s, --shell <shell>           set quoting conventions to those of <shell>
	 -T, --test                    test for getopt(1) version
	 -u, --unquoted                do not quote the output

	 -h, --help                    display this help
	 -V, --version                 display version

	For more details see getopt(1).
	EOT
  }

  _getopt_version_check() {
    if [[ -z $BASH_VERSION ]]; then
      echo "getopt: unknown version of bash might not be compatible" >&2
      return 1
    fi

    # This is a lexical comparison that should be sufficient forever.
    if [[ $BASH_VERSION < 2.05b ]]; then
      echo "getopt: bash $BASH_VERSION might not be compatible" >&2
      return 1
    fi

    return 0
  }

  _getopt_version_check
  _getopt_main "$@"
  declare status=$?
  unset -f _getopt_main _getopt_err _getopt_parse _getopt_quote \
    _getopt_quote_csh _getopt_resolve_abbrev _getopt_split _getopt_help \
    _getopt_version_check
  return $status
}
getopt $@
;;
grep)
#!/bin/bash
PATTERN="$1"
shift
IFS=$'\n'
INPUT=( "${@:-"-"}" )
for i in "${INPUT[@]}"; do
	if [[ "$i" == "-" ]]; then
		exec 3<&0
	else
		exec 3< "$i" || exit 1
	fi

	while read -ru 3 line; do
		[[ "$line" =~ .*$PATTERN.* ]] && echo -E "$line"
	done
done
;;
hd)
#!/usr/bin/env bash
hd() {
  if (($#)); then
    hd <"$1"
    return
  fi
  local IFS='' # disables interpretation of \t, \n and space
  local LANG=C # allows characters > 0x7F
  local bytes=0 char chars=''
  declare -i bytes
  printf '%08x  ' 0
  while read -s -d '' -r -n 1 char; do  # -d '' allows newlines, -r allows \
    printf '%02x ' "'$char" # see https://pubs.opengroup.org/onlinepubs/009695399/utilities/printf.html
    [[ "$char" =~ [[:print:]] ]] || char='.' # display non-printables as a dot
    chars+=$char
    ((++bytes % 8)) && continue
    printf ' '
    ((bytes % 16)) && continue
    printf '|%s|\n%08x  ' "$chars" "$bytes"
    chars=''
  done
  if [[ "$chars" ]]; then
    len=${#chars}
    ((len > 7 && len--, len += (16 - (bytes % 16)) * 3 + 4))
    printf "%${len}s\n%08x  " "|$chars|" "$bytes"
  fi
  printf '\n'
}

hd "$@"
;;
head)
#!/usr/bin/env bash
#
# head in pure bash.

while getopts ":n:" opt; do
    case $opt in
        n) max_lines="$OPTARG" ;;

        :)
            printf '%s\n' "option -$OPTARG requires an argument." >&2
            exit 1
        ;;

        ?)
            printf '%s\n' "error: -$OPTARG not a valid option." >&2
            exit 1
        ;;
    esac

    shift "$((OPTIND - 1))"
done

[[ ! -f $1 ]] && {
    printf '%s\n' "head: ${1:-null}: No such file or directory." >&2
    exit 1
}

mapfile -n "${max_lines:-10}" file_data < "$1"
printf '%s' "${file_data[@]}"
;;
hextorgb)
#!/bin/bash
# Convert a hex color to rgb.
# Usage: hex_to_rgb "color"
r="${1:1:2}"
g="${1:3:2}"
b="${1:5:6}"
[ -z "$1" ] && echo no color specified && exit
printf "%s %s %s\\n" "$((16#$r))" "$((16#$g))" "$((16#$b))"
;;
hostname)
#!/usr/bin/env bash
#
# hostname in pure bash.

: '\h'
printf '%s\n' "${_@P}"
;;
kill)
#!/bin/bash
#seems like kill is bash builtin so this is another useless script
kill $@
;;
less)
#!/usr/bin/env bash
#stolen from https://github.com/comfies/bed
printf '\e[?7l'
declare -a buffer
declare -i line base
declare message modified

buffer=() # File contents
line=0 # Currently selected line (0 means the buffer is empty)
base=1 # Top-most line shown
modified=false # Tracking whether a file was modified

shopt -s extglob # Ensure advanced pattern matching is available
shopt -s checkwinsize; (:) # Enable and then trigger a terminal size refresh
trap redraw WINCH ALRM # Attach WINCH and ALRM to redraw the screen
trap die EXIT HUP USR1 # Attach most exit codes to cleanup and exit
trap quit INT

read_buffer() {
    mapfile -t -O 1 buffer # Read file into an array
    if [[ "${buffer[1]}" ]]; then # Ensure that something was actually read into the file
        line=1 # Indicate that we have a buffer loaded
        modified=false
        message="Read ${#buffer[@]} lines"
    else
        message="'$file' is empty"
    fi
}


quit() {
	die
}

up() {
    for ((i = 0; i < ${1:-1}; i++)); do
        ((line > 1)) && ((line--)) # As long as we can keep going up, go up
        ((line < base)) && ((base--)) # Push back the top if we need to
        ((base <= 0)) && base=1 # Don't push back if our base is at 1
    done
}

page_up() {
    up $((LINES - 3))
}

down() {
    for ((i = 0; i < ${1:-1}; i++)); do
        ((line < ${#buffer[@]})) && ((line++)) # If we can go down, go down
        ((line > base + LINES - 3)) && ((base++)) # Move window down if needed
    done
}

page_down() {
    down $((LINES - 3))
}

die() {
    bind 'set disable-completion off' 2>/dev/null # Enable completion
    printf '\e[?25h\e[?7h\e[?1047l' # Reset terminal to sane mode
    exit "${errno:-0}" # Assume that we're exiting without an error
}

redraw() {
    (printf '\e[H\e[?25l\e[100m%*s\r %s \e[46;30m %s \e[0;100m L%s W%s\e[m' \
        "$COLUMNS" "$message" "bashbox less" \
        "$line" "${#buffer[line]}") # Status line, among others
    for ((i = base; i - base < LINES - 2; i++)); do # Iterate over shown lines
        ((i != line)) && printf '\e[90m' # Fade line number if not selected
        ((i > ${#buffer[@]})) && printf '\n\e[K   ~\e[m' || \
            printf '\n\e[K%4s\e[m %s' "$i" "${buffer[i]}" # Print the line
    done
    printf '\n' # Add final newline to seperate commandline
}

key() {
    case "$1" in
    ${BED_KEY_PGUP:=$'\E[5~'}) page_up;;
    ${BED_KEY_PGDN:=$'\E[6~'}) page_down;;
    ${BED_KEY_UP:=$'\E[A'}*) up;;
    ${BED_KEY_DOWN:=$'\E[B'}*) down;;
    ${BED_KEY_QUIT:=q}) quit;;
    esac
}

main() {
    printf '\e[?1047h' # Switch to alternative buffer
    redraw # Draw out the UI before loading file
    read_buffer
    while redraw; do # Keep redrawing when we can (allow WINCH signals to get handled)
        local -a k=()
        local -i i=1
        if read -rsN1 -t"${BED_REFRESH_TIMEOUT:=0.1}" k[0] </dev/tty; then # Check for ready input
            while read -rsN1 -t0.0001 k[$i]</dev/tty; do ((i++)); done # Multibyte hack
            key "$(printf '%s' "${k[@]}")"
        fi
    done
}

main "$@"
printf '\e[?7h'
;;
locale)
#!/usr/bin/env bash
#
# locale in pure bash.

locale_vars=(
    LANG
    LC_CTYPE
    LC_NUMERIC
    LC_TIME
    LC_COLLATE
    LC_MONETARY
    LC_MESSAGES
    LC_PAPER
    LC_NAME
    LC_ADDRESS
    LC_TELEPHONE
    LC_MEASUREMENT
    LC_IDENTIFICATION
)


for var in "${locale_vars[@]}"; do
    printf '%s=\"%s\"\n' "$var" "${!var:-$LANG}"
done
printf '%s=%s\n' "LC_ALL" "$LC_ALL"
;;
logname)
#!/usr/bin/env bash
#
# logname in pure bash.

: '\u'
printf '%s\n' "${_@P}"
;;
lolcat)
#!/bin/bash
#based on https://github.com/yokkidack/shaverma
#generate colors
repeat() {
	[[ -z $1 ]] && {
	    printf '%s\n' "seq: error: missing arguments." >&2
	    exit 1
	}
	
	[[ $2 ]] &&
	    first="$1"
	
	[[ $3 ]] &&
	    increment="$2"
	
	last="${*: -1}"
	
	for ((i=${first:=1};i<=last;i+=${increment:=1})); {
	    printf '%s\n' "$i"
	}
	
}
genrgb(){
	nummin=255
	numadd=-1
	for a in $(repeat 0 1540)
	do
		numadd=$(( numadd + 1 ))
		nummin=$(( nummin - 1 ))
		[ $a -lt 256 ] && echo -n "\033[38;2;255"
		[ $a -lt 256 ] && echo -n ";$numadd"
		[ $a -lt 256 ] && echo -n ";0m" && echo
		[ $a = 256 ] && numadd=0 && nummin=255
		[ $a -gt 256 ] && [ $a -lt 512 ] && echo -n "\033[38;2;$nummin"
		[ $a -gt 256 ] && [ $a -lt 512 ] && echo -n ";255"
		[ $a -gt 256 ] && [ $a -lt 512 ] && echo -n ";0m" && echo
		[ $a = 512 ] && numadd=0 && nummin=256
		[ $a -gt 512 ] && [ $a -lt 768 ] && echo -n "\033[38;2;0"
		[ $a -gt 512 ] && [ $a -lt 768 ] && echo -n ";255"
		[ $a -gt 512 ] && [ $a -lt 768 ] && echo -n ";${numadd}m" && echo
		[ $a = 768 ] && numadd=0 && nummin=255
		[ $a -gt 768 ] && [ $a -lt 1024 ] && echo -n "\033[38;2;0"
		[ $a -gt 768 ] && [ $a -lt 1024 ] && echo -n ";$nummin"
		[ $a -gt 768 ] && [ $a -lt 1024 ] && echo -n ";255m" && echo
		[ $a = 1024 ] && numadd=0 && nummin=255
		[ $a -gt 1024 ] && [ $a -lt 1280 ] && echo -n "\033[38;2;$numadd"
		[ $a -gt 1024 ] && [ $a -lt 1280 ] && echo -n ";0"
		[ $a -gt 1024 ] && [ $a -lt 1280 ] && echo -n ";255m" && echo
		[ $a = 1280 ] && numadd=0 && nummin=255
		[ $a -gt 1280 ] && [ $a -lt 1536 ] && echo -n "\033[38;2;255"
		[ $a -gt 1280 ] && [ $a -lt 1536 ] && echo -n ";0"
		[ $a -gt 1280 ] && [ $a -lt 1536 ] && echo -n ";${nummin}m" && echo
	done
}
igenrgb(){
	nummin=255
	numadd=-1
	for a in $(repeat 0 1540)
	do
		numadd=$(( numadd + 1 ))
		nummin=$(( nummin - 1 ))
		[ $a -lt 256 ] && echo -n "\033[48;2;255"
		[ $a -lt 256 ] && echo -n ";$numadd"
		[ $a -lt 256 ] && echo -n ";0m" && echo
		[ $a = 256 ] && numadd=0 && nummin=255
		[ $a -gt 256 ] && [ $a -lt 512 ] && echo -n "\033[48;2;$nummin"
		[ $a -gt 256 ] && [ $a -lt 512 ] && echo -n ";255"
		[ $a -gt 256 ] && [ $a -lt 512 ] && echo -n ";0m" && echo
		[ $a = 512 ] && numadd=0 && nummin=256
		[ $a -gt 512 ] && [ $a -lt 768 ] && echo -n "\033[48;2;0"
		[ $a -gt 512 ] && [ $a -lt 768 ] && echo -n ";255"
		[ $a -gt 512 ] && [ $a -lt 768 ] && echo -n ";${numadd}m" && echo
		[ $a = 768 ] && numadd=0 && nummin=255
		[ $a -gt 768 ] && [ $a -lt 1024 ] && echo -n "\033[48;2;0"
		[ $a -gt 768 ] && [ $a -lt 1024 ] && echo -n ";$nummin"
		[ $a -gt 768 ] && [ $a -lt 1024 ] && echo -n ";255m" && echo
		[ $a = 1024 ] && numadd=0 && nummin=255
		[ $a -gt 1024 ] && [ $a -lt 1280 ] && echo -n "\033[48;2;$numadd"
		[ $a -gt 1024 ] && [ $a -lt 1280 ] && echo -n ";0"
		[ $a -gt 1024 ] && [ $a -lt 1280 ] && echo -n ";255m" && echo
		[ $a = 1280 ] && numadd=0 && nummin=255
		[ $a -gt 1280 ] && [ $a -lt 1536 ] && echo -n "\033[48;2;255"
		[ $a -gt 1280 ] && [ $a -lt 1536 ] && echo -n ";0"
		[ $a -gt 1280 ] && [ $a -lt 1536 ] && echo -n ";${nummin}m" && echo
	done
}
gencol(){
	for a in $(repeat 255)
	do
		echo "\033[38;5;${a}m"
	done
}
igencol(){
	for a in $(repeat 255)
	do
		echo "\033[48;5;${a}m"
	done
}
#default limit
limit=255
#help
printhelp(){
	Rainbow=($(genrgb))
	limit=1536
	lolcate "
Usage: lolcat [OPTION]...

Concatenate standard input, to standard output

  -i, --invert             Invert fg and bg
  -t, --truecolor          24-bit (truecolor)
  -it, --invert-truecolor  24-bit (inverted) 
  -h, --help               Show this message
  -v, --version            Print version and exit

Examples:
  echo hello | bashbox lolcat   prints hello in rainbow
  echo hello | bashbox lolcat -t   prints hello in truecolor rainbow

"
	exit
}
index=0
lolcate(){
    string=$1
    ((j=$index % $limit))
    ((index++))
    for (( i=0; i<${#string}; i++ )); do
        ((j++))
        if (($j == $limit))
        then
            ((j=0))
        fi
      echo -ne "${Rainbow[$j]}${string:$i:1}"
    done
    printf "\033[0;0m"
}
case "$1" in
	"-i"|"--invert") Rainbow=($(igencol));limit=256;;
	"-t"|"--truecolor") Rainbow=($(genrgb));limit=1536;;
	"-it"|"--invert-truecolor") Rainbow=($(igenrgb));limit=1536;;
	"-h"|"--help") printhelp;;
	"-v"|"--version") echo "bashbox lolcat";exit;;
	*)Rainbow=($(gencol));limit=256;;
esac
	

IFS=$'\n'

while read string
do
    lolcate $string
done
;;
lowercase)
#!/bin/bash
# Lowercase a string.
# Usage: lower "string"
while read -r line
do
	printf "%s\\n" "${line,,}"
done
;;
ls)
#!/usr/bin/bash
#!/usr/bin/env bash
infofile() {
	if [ -L $1 ]; then
		echo -n l
	elif [ -d $1 ]; then
		echo -n d
	else
		echo -n '-'
	fi
	[ -r $1 ] && echo -n r || echo -n '-'
	[ -w $1 ] && echo -n w || echo -n '-'
	[ -x $1 ] && echo -n x || echo -n '-'
	[ -L $1 ] && [ -d $1 ] && cd -P "$1" && echo " $1 -> $PWD" && cd .. || echo " $1"
}
infofiles() {
	for f in $(printf '%s\n' *); {
		infofile "$f"
	}
}
infofilesall() {
	for f in $(printf '%s\n' .* && printf '%s\n' *); {
		infofile "$f"
	}
}
[ -z "$1" ] && printf '%s\n' *
[ "$1" = "-a" ] && printf '%s\n' .* && printf '%s\n' *
[ "$1" = "-l" ] && infofiles
[ "$1" = "-la" ] && infofilesall
[ "$1" = "-al" ] && infofilesall
;;
lscpu)
#!/bin/bash
uniq_lscpu() {
	while read -r line; do
	for check in "${hab[@]}"
	do
		if [ "$line" = "$check" ]; then
			repeat=yes
		fi
	done
	#echo $repeat : $line
	[ "$repeat" = "no" ] && echo "$line"
	repeat=no
	hab+=("$line")
	done
}
if [ -f /proc/cpuinfo ]; then
	printf '%s\n' "$(</proc/cpuinfo)" | uniq_lscpu
fi
;;
makewords)
#!/bin/bash
[ -z "$1" ] && {
while read -rd ' ' word
do
	echo "$word"
done }
[ -n "$1" ] && {
	for arg in "$@"; {
		while read -rd ' ' word
		do
			echo "$word"
		done < "$arg"
	}
}
;;
man)
#!/bin/bash
[ -z "$1" ] && echo specify arguments && exit
[ -z "$2" ] && page="$1" && section="1"
[ -n "$2" ] && page="$2" && section="$1"

getpage() {
	IFS=':' read -ra dirs <<< "$MANPATH"
	for i in "${dirs[@]}"; {
		[ -f "${i}/man${section}/${page}.${section}" ] && file="${i}/man${section}/${page}.${section}" && break
	}
}
print() {
	#really shitty solution
	content=$(printf '%s\n' "$(<"$file")")
	content="${content//.RE/ }"	
	for n in {0..100}; {
		content="${content//.RS ${n}/ }"		
	}
	content="${content//\\fR/ }"	
	content="${content//\\fI/ }"	
	content="${content//\\f?/ }"	
	content="${content//\\&/ }"	
	content="${content//\\/ }"
	#echo "$content"
	IFS=$'\n'
	for w in $content; {
		[ ! "${w:0:1}" = '.' ] && echo "$w"
		#echo "$w"
	}
}
getpage
print
;;
more)
#!/usr/bin/env bash
#stolen from https://github.com/comfies/bed
declare -a buffer
declare -i line base
declare message modified

buffer=() # File contents
line=0 # Currently selected line (0 means the buffer is empty)
base=1 # Top-most line shown
modified=false # Tracking whether a file was modified

shopt -s extglob # Ensure advanced pattern matching is available
shopt -s checkwinsize; (:) # Enable and then trigger a terminal size refresh
trap redraw WINCH ALRM # Attach WINCH and ALRM to redraw the screen
trap die EXIT HUP USR1 # Attach most exit codes to cleanup and exit
trap quit INT

read_buffer() {
    mapfile -t -O 1 buffer # Read file into an array
    if [[ "${buffer[1]}" ]]; then # Ensure that something was actually read into the file
        line=1 # Indicate that we have a buffer loaded
        modified=false
        message="Read ${#buffer[@]} lines"
    else
        message="'$file' is empty"
    fi
}


quit() {
	die
}

up() {
    for ((i = 0; i < ${1:-1}; i++)); do
        ((line > 1)) && ((line--)) # As long as we can keep going up, go up
        ((line < base)) && ((base--)) # Push back the top if we need to
        ((base <= 0)) && base=1 # Don't push back if our base is at 1
    done
}

page_up() {
    up $((LINES - 3))
}

down() {
    for ((i = 0; i < ${1:-1}; i++)); do
        ((line < ${#buffer[@]})) && ((line++)) # If we can go down, go down
        ((line > base + LINES - 3)) && ((base++)) # Move window down if needed
    done
}

page_down() {
    down $((LINES - 3))
}

die() {
    bind 'set disable-completion off' 2>/dev/null # Enable completion
    printf '\e[?25h\e[?7h\e[?1047l' # Reset terminal to sane mode
    exit "${errno:-0}" # Assume that we're exiting without an error
}

redraw() {
    (printf '\e[H\e[?25l\e[100m%*s\r %s \e[46;30m %s \e[0;100m L%s W%s\e[m' \
        "$COLUMNS" "$message" "bashbox more" \
        "$line" "${#buffer[line]}") # Status line, among others
    for ((i = base; i - base < LINES - 2; i++)); do # Iterate over shown lines
        ((i != line)) && printf '\e[90m' # Fade line number if not selected
        ((i > ${#buffer[@]})) && printf '\n\e[K   ~\e[m' || \
            printf '\n\e[K%4s\e[m %s' "$i" "${buffer[i]}" # Print the line
    done
    printf '\n' # Add final newline to seperate commandline
}

key() {
    case "$1" in
    ${BED_KEY_PGUP:=$'\E[5~'}) up;;
    ${BED_KEY_PGDN:=$'\E[6~'}) down;;
    ${BED_KEY_UP:=$'\E[A'}*) page_up;;
    ${BED_KEY_DOWN:=$'\E[B'}*) page_down;;
    ${BED_KEY_QUIT:=q}) quit;;
    esac
}

main() {
    printf '\e[?1047h' # Switch to alternative buffer
    redraw # Draw out the UI before loading file
    read_buffer
    while redraw; do # Keep redrawing when we can (allow WINCH signals to get handled)
        local -a k=()
        local -i i=1
        if read -rsN1 -t"${BED_REFRESH_TIMEOUT:=0.1}" k[0] </dev/tty; then # Check for ready input
            while read -rsN1 -t0.0001 k[$i]</dev/tty; do ((i++)); done # Multibyte hack
            key "$(printf '%s' "${k[@]}")"
        fi
    done
}

main "$@"
;;
nano)
#!/usr/bin/env bash
#stolen from https://github.com/comfies/bed and edited to be like nano and added few stuff like syntax highlighting
#i guess i will turn this into ebashs later :)
printf '\e[?7l'

declare -A syntax
declare -a buffer
declare -a buffersyntax
declare -i line base rl
declare file message modified filetype enable_mouse comment stringone stringtwo reservedlines

printf "\e[?1049h" #switch to alternative buffer

buffer=() # File contents
buffersyntax=() # File contents
line=0 # Currently selected line (0 means the buffer is empty)
base=1 # Top-most line shown
rl=0 # how left or right the cursor is
file= # Currently addressed file
message="Welcome to bano (press 'x' to quit)." # Feedback text in the status bar
modified=false # Tracking whether a file was modified
enable_mouse=true # Xterm mouse support
reservedlines=1 # Number of lines not displaying file

shopt -s lastpipe
shopt -s extglob # Ensure advanced pattern matching is available
shopt -s checkwinsize; (:) # Enable and then trigger a terminal size refresh
trap redraw WINCH ALRM # Attach WINCH and ALRM to redraw the screen
trap die EXIT HUP USR1 # Attach most exit codes to cleanup and exit
trap quit INT
trap quit SIGTERM

syntax[bash]=builtin_syntax_bash
syntax[sh]=builtin_syntax_bash #there isnt anything really bash specific currently
syntax[ksh]=builtin_syntax_bash
syntax[mksh]=builtin_syntax_bash
syntax[dash]=builtin_syntax_bash
syntax[zsh]=builtin_syntax_bash
syntax[conf]=builtin_syntax_conf
syntax[unknown]=builtin_syntax_unknown

builtin_syntax_bash() {
	case "${word:0:2}" in
		'"$') colour 0 36 48 "${word}"; return ;;
	esac
	case "${word:0:1}" in
		'#') colour 0 37 48 "${word}" && comment=true; return;;
		'$') colour 0 96 108 "${word}"; return ;;
		'-') colour 0 93 108 "${word}"; return ;;
	esac
	"${comment}" && colour 0 37 48 "${word}" && return
	case "${word}" in
		'||') colour 0 95 108 "${word}"; return ;;
		'&&') colour 0 95 108 "${word}"; return ;;
		']') colour 1 95 108 "${word}"; return ;;
		'[') colour 1 95 108 "${word}"; return ;;
		'[[') colour 1 95 108 "${word}"; return ;;
		']]') colour 1 95 108 "${word}"; return ;;
		')') colour 1 95 108 "${word}"; return ;;
		'(') colour 1 95 108 "${word}"; return ;;
		'{') colour 1 95 108 "${word}"; return ;;
		'}') colour 1 95 108 "${word}"; return ;;
		';') colour 0 95 108 "${word}"; return ;;
		*"'"*) colour 0 92 108 "${word}" && return ;;
		*'"'*) colour 0 32 48 "${word}" && return ;;
		*'='*) colour 0 94 108 "${word}"; return ;;
	esac
		   
	[[ "${word: -2}" = '()' ]] && colour 0 30 44 "${word}" && return
	case "${word}" in
		'echo'|'return'|'case'|'esac'|'for'|'while'|'do'|'done'|'if'|'elif'|'else'|'printf'|'fi'|'continue'|'exit'|'bind'|'then'|'break'|'read'|'declare'|'typeset'|'local'|'let'|'shopt'|'trap'|'set') colour 0 91 108 "${word}" && return
	esac
	colour 0 0 0 "${word}"
}
builtin_syntax_unknown() {
	colour 0 0 0 "${word}"
}
builtin_syntax_conf(){
	[[ "${word}" =~ "#" ]] && colour 38 5 4 "${word}" && comment=true && return
	"${comment}" && colour 38 5 4 "${word}" && return
	colour 0 0 0 "${word}"
}

syntax() {
	for s in "${!syntax[@]}"; {
		[ "$s" = "$filetype" ] && "${syntax[$s]}" && return
	}
	"${syntax[unknown]}"
}
basenam() {
	for file in "$@"; do
	    file="${file%/}"
	    printf '%s\n' "${file##*/}"
	done
}
filetype(){
	[ $# = 0 ] && return
	IFS='.'
	filename="${1%/}"
	filename="${filename##*/}"
	filenamesplit=($filename)
	extension="${filenamesplit[-1]}"
	[ "${#filenamesplit[@]}" -gt 1 ] && echo "$extension" && return
	mapfile -n 1 file_data < "$1"
	shebang="$(echo -n "${file_data[@]}")"
	[ ! "${shebang:0:1}" = '#' ] && echo unknown && return
	shebang="${shebang%/}"
	IFS=' '
	shebang="${shebang##*/}"
	shebangsplit=($shebang)
	printf '%s\n' "${shebangsplit[-1]}"	
}
set_buffer_file() {
	printf '\e[%s;0H' "${LINES}"
	printf '\e[D\033[1;93;108m' #make prompt nicer
    bind 'set disable-completion off' 2>/dev/null # Enable completion
    printf '\e[?25h' # Enable cursor
    if read -rei "$1$file" -p "${BED_FILE_PROMPT:=Path: }" file; then
        modified=true
    fi
    bind 'set disable-completion on' 2>/dev/null
}

read_buffer() {
	filetype="$(filetype "$1")"
    set_buffer_file "$1" # Update target file (pass on default if present)
    mapfile -t -O 1 buffer <"$file" # Read file into an array
    pipesyntax < "$file" | mapfile -t -O 1 buffersyntax  # Read file into an array
    if [[ "${buffer[1]}" ]]; then # Ensure that something was actually read into the file
        line=1 # Indicate that we have a buffer loaded
        modified=false
        message="Read ${#buffer[@]} lines from '$file'"
    else
        message="'$file' is empty"
    fi
}

write_buffer() {
    true >"$file" # Set the file to an empty text file
    for ln in "${buffer[@]}"; do # Write in the buffer to the file
        echo "$ln" >>"$file"
    done
    modified=false
    message="Wrote ${#buffer[@]} lines to '$file'"
}
megaredraw() {
	printf '%s\n' "${buffer[@]}" | pipesyntax | mapfile -t -O 1 buffersyntax
}
megaredrawline() {
	buffersyntax[line]="$(printf '%s' "${buffer[line]}" | pipesyntax)"
}
#megaredrawlinesyntax(){
#	buffersyntax[line]="$(printf '%s' "${buffer[line]}" | pipesyntax)"
#}
tabrender() {
	IFSbck="$IFS"
	IFS=
	while read -rsn1 char
	do
		[ "$char" = " " ] && printf ' ' && continue
		[ "$char" = "	" ] && printf '\033[0;37;48m%s\033[0;0m' "${BANO_RENDER_TAB:=.}" && continue
		printf '%s' "$char"
	done
	IFS="$IFSbck"
}
tabrenderraw() {
	IFSbck="$IFS"
	IFS=
	while read -rsn1 char
	do
		[ "$char" = " " ] && printf ' ' && continue
		[ "$char" = "	" ] && printf '%s' "${BANO_RENDER_TAB_ALT:= }" && continue
		printf '%s' "$char"
	done
	IFS="$IFSbck"
}
new_line() {
    buffer=("" "${buffer[@]:1:line}" "" "${buffer[@]:line+1}")
    unset 'buffer[0]'
    modified=true
	megaredraw
	down
	redraw
}

delete_line() {
    buffer=("" "${buffer[@]:1:line-1}" "${buffer[@]:line+1}")
    unset 'buffer[0]'
    ((line > ${#buffer[@]})) && up
    modified=true
    megaredraw
}

quit() {
	printf '\e[%s;0H' "${LINES}"
	printf '\e[D\033[1;93;108m' #make prompt nicer
    if [[ "$modified" == "true" ]]; then
        while :; do
            read -rsN1 -p "Buffer modified, save before close? [Y/n/c]" choice
            case "$choice" in
            Y|y) write_buffer; die;;
            N|n) die;;
            C|c) message="Quit canceled"; break;;
            *) continue;;
            esac
        done
    else
        die
    fi
}

up() {
    for ((i = 0; i < ${1:-1}; i++)); do
        ((line > 1)) && ((line--)) # As long as we can keep going up, go up
        ((line < base)) && ((base--)) # Push back the top if we need to
        ((base <= 0)) && base=1 # Don't push back if our base is at 1
        [ -z "$bckrl" ] && bckrl="${rl}"
        (( "${#buffer[line]}" < "${rl}" )) && rl="${#buffer[line]}"
        (( "${#buffer[line]}" > "${rl}" )) && rl=bckrl
    done
}

page_up() {
    up $((LINES - 3))
}

down() {
    for ((i = 0; i < ${1:-1}; i++)); do
        ((line < ${#buffer[@]})) && ((line++)) # If we can go down, go down
        ((line > base + LINES - 3)) && ((base++)) # Move window down if needed
        [ -z "$bckrl" ] && bckrl="${rl}"
        (( "${#buffer[line]}" < "${rl}" )) && rl="${#buffer[line]}"
        (( "${#buffer[line]}" > "${rl}" )) && rl=bckrl
    done
}

page_down() {
    down $((LINES - 3))
}

execute() {
    ((line == 0)) && return # If the line is not possible, do nothing
    printf '\e[?25h\e[%sH' "$((line + 2 - base))" # Reset cursor position and enable cursor
    read -re -p "$(printf '%4s ' "$")" # Present editable line
    if [[ "$REPLY" != "${buffer[line]}" ]]; then # If the line is changed, update and inform
        buffer[line]="$($REPLY)"
        modified=true
    fi
    megaredraw
    redraw
}
right() {
	case "${buffer[line]}" in
		*)((rl++));;
	esac
	[ "$rl" -gt "${#buffer[line]}" ] && { rl=0; down; }
	bckrl=
}
left() {
	((rl--))
	[ "$rl" -lt 0 ] && { up; rl="${#buffer[line]}"; }
	bckrl=
}
shell() {
	printf "\033c"
	bash
	redraw
}
help() {
	printf '\e[%s;0H' "${LINES}"
	printf '\033[0;0m'
	printf '\n' # Add final newline to seperate commandline
	printf '\e[0;107;30m C-x\e[0;m Exit     \e[0;107;30m⏎   \e[0;m New Line  \e[0;107;30m M-r\e[0;m Set Target \e[0;107;30m C-r\e[0;m Read File \e[0;107;30m C-o\e[0;m Write Out \e[0;107;30m C-d\e[0;m Delete Line \e[0;107;30m C-e\e[0;m Toggle Mouse\n'
	printf '\e[0;107;30m C-l\e[0;m New Line \e[0;107;30m C-p\e[0;m Prev Line \e[0;107;30m C-n\e[0;m Next Line  \e[0;107;30m C-y\e[0;m Prev Page \e[0;107;30m C-v\e[0;m Next Page \e[0;107;30m C-t\e[0;m Execute     \e[0;107;30m C-s\e[0;m Shell       \n'
	read -rsn1
	redraw
}

die() {
    bind 'set disable-completion off' 2>/dev/null # Enable completion
    printf '\e[?25h\e[?7h\e[?1047l' # Reset terminal to sane mode
    printf "\e[?1049l" # switch back to main buffer
    echo -e "\e[?1000;1006;1015l" #disable mouse tracking
    exit "${errno:-0}" # Assume that we are exiting without an error
}
mtoggle() {
	[ "$enable_mouse" = true ] && echo -ne "\e[?1000;1006;1015l" && enable_mouse=false && return
	[ "$enable_mouse" = false ] && echo -ne "\e[?1000;1006;1015h" && enable_mouse=true && return
}

redraw() {
    (printf '\e[0;30m \e[H\e[?25l\e[107m%*s\r %s \e[46;30m %s \e[0;107;30m L%s W%s\e[m' \
        "$COLUMNS" "$message" "bano (press C-g for help)" \
        "$(basenam "$file") ($filetype)" "$line" "${rl}") # Status line, among others
    for ((i = base; i - base < LINES - reservedlines; i++)); do # Iterate over shown lines
        ((i != line)) && printf '\e[90m' # Fade line number if not selected
        ((i > ${#buffer[@]})) && printf '\n\e[K   ~\e[m' || \
            case "${buffer[i]}" in
                *"TODO: "*|*TODO:) printf '\n\e[K%4s\e[m \033[0;45m%s\033[0;0m' "$i" "$(printf '%s' "${buffer[i]}" | tabrenderraw)";;
                *"NOTE: "*|*NOTE:) printf '\n\e[K%4s\e[m \033[0;47m%s\033[0;0m' "$i" "$(printf '%s' "${buffer[i]}" | tabrenderraw)";;
				*) printf '\n\e[K%4s\e[m %s' "$i" "${buffersyntax[i]}";;
            esac
            #TODO: make proper coloring based on variable for future config
    done
    printf '\e[?25h\e[%s;%sH' $((line + 2 - base)) $(( rl + 6 )) # move cursor to the line
}
backspace() {
	while [ "${#buffer[line]}" = 0 ]; do
		delete_line
	done
	buffer[line]="${buffer[line]:0:$(( rl - 1 ))}${buffer[line]:${rl}}" #add the key at $rl (cursor position)
	left #go left with cursor
	megaredrawline #not sure why this is needed but it prevents duplication of the letter
	redraw #draw it
	modified=true
}
keytype() {
	mouse=false
	case "$1" in
		${BANO_KEY_PGUP:=$'\E[5~'}) page_up; redraw; return;;
		${BANO_KEY_PGDN:=$'\E[6~'}) page_down; redraw; return;;
		${BANO_KEY_UP:=$'\E[A'}*) up; redraw; return;;
		${BANO_KEY_DOWN:=$'\E[B'}*) down; redraw; return;;
		${BANO_KEY_RIGHT:=$'\E[C'}*) right; redraw; return;;
		${BANO_KEY_LEFT:=$'\E[D'}*) left; redraw; return;;
	esac
	hexkey=$(printf "%x\n" "'$1")
	#clear        #stuff for debugging
	#echo $hexkey #stuff for debugging
	#read         #stuff for debugging
	#[ "$hexkey" = "$1b" ] && { read -r a; clear; echo $a; read; } && return
	#[ "${1:1:2}" = '[' ] && echo E && return
	case "$hexkey" in
		${BANO_KEY_EXIT:=18}) quit; return;;
		${BANO_KEY_PREVIOUS:=10}) up; redraw; return;;
		${BANO_KEY_NEXT:=e}) down; redraw; return;;
		${BANO_KEY_FORTH:=6}) right; redraw; return;;
		${BANO_KEY_BACK:=2}) left; redraw; return;;
		${BANO_KEY_PGPREVIOUS:=19}) page_down; redraw; return;;
		${BANO_KEY_PGNEXT:=16}) page_up; redraw; return;;
		${BANO_KEY_NEWLINE:=0}) new_line; return;;
		${BANO_KEY_NEWLINEALT:=c}) new_line; return;;
		${BANO_KEY_HELP:=7}) help; return;;
		${BANO_KEY_SAVE:=f}) write_buffer; return;;
		${BANO_KEY_READ:=12}) read_buffer; return;;
		${BANO_KEY_READ:=1b}) set_buffer_file; return;;
		${BANO_KEY_EXECUTE:=14}) execute; return;;
		${BANO_KEY_DELETE:=4}) delete_line; redraw; return;;
		${BANO_KEY_SHELL:=13}) shell; return;;
		${BANO_KEY_MOUSE_TOGGLE:=5}) mtoggle; return;;
		${BANO_KEY_SCROLL:=1b}) mouse=true;;
		${BANO_KEY_BACKSPACE:=7f}) backspace; return;; #delete last char when backspace is pressed
	esac
	#TODO: make mouse scrolling nice instead of ignoring it

	#parse mouse stuff somewhatish weirdly
	$mouse && {
		a=$(echo "$1")
		[ "${a: -1}" = 'm' ] && {
			value=0
			echo "$a" | while read -rsn1 mchar; do
				case "$mchar" in
					'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|9)tmp="${tmp}${mchar}";;
					'm'|'M'|';') {
						[ "$value" = '0' ] && mode="${tmp}" && tmp=
						[ "$value" = '1' ] && y="${tmp}" && tmp=
						[ "$value" = '2' ] && x="${tmp}" && tmp=
					};;
				esac
				case "$mchar" in
					';')((value++));;
					'm'|'M')value=0 && break;;
				esac
			done
		}
		#limitations of movenment
		[ $x = 1 ] && return
		[ $y -lt 6 ] && return
		line=$(( base + ( x - 2 ) ))
		rl=$(( y - 6 ))
		((line > ${#buffer[@]})) && line=${#buffer[@]}
		((rl > ${#buffer[line]})) && rl=${#buffer[line]}
		redraw
		return
	}
	
	buffer[line]="${buffer[line]:0:${rl}}$1${buffer[line]:${rl}}" #add the key at $rl (cursor position)
	right #go right with cursor
	megaredrawline #not sure why this is needed but it prevents duplication of the letter
	redraw #draw it
	modified=true
}

main() {
    printf '\e[?1047h' # Switch to alternative buffer
    echo -ne "\e[?1000;1006;1015h" #enable mouse tracking
    if [[ "$1" ]]; then # If a file was provided in the terminal pre-load it
        redraw # Draw out the UI before loading file
        read_buffer "$1"
    fi
    redraw
    while true; do
        local -a k=()
        local -i i=1
        
        if read -rsN1 -t"${BED_REFRESH_TIMEOUT:=1}" k[0]; then # Check for ready input
           while read -rsN1 -t0.0001 k[$i]; do ((i++)); done # Multibyte hack
            keytype "$(printf '%s' "${k[@]}")" # Handle keypress event
        fi
    done
}
pipesyntax() {
	comment=false
	stringone=false
	stringtwo=false
	word=
	bckIFS="${IFS}"
	IFS=
	colour(){
		printf "\033[%s;%s;%sm%s\033[0;0m" "$1" "$2" "$3" "$4"
	}
	readstuff() {
		while read -rsn1 char
		do
			[ "$char" = " " ] && syntax && word='' && printf ' ' && continue
			[ "$char" = "	" ] && syntax && word='' && printf '\033[0;37;48m%s\033[0;0m' "${BANO_RENDER_TAB:=.}" && continue
			[ -z "$char" ] && syntax && word='' comment='false' && echo && continue
			word="${word}${char}" && printf '%s\e[%sD' "$word" "${#word}"
		done
	}
	readstuff
	IFS="${bckIFS}"
}
main "$@"
printf '\e[?7h'
;;
nl)
#!/bin/bash
n=1
[ "$1" = '-v' ] && n="$2" && shift 2
[ -z "$1" ] && {
while read -r line
do
	echo "$n $line"
	((n++))
done }
[ -n "$1" ] && {
	for arg in "$@"; {
		while read -r line
		do
			echo "$n $line"
			((n++))
		done < "$arg"
	}
}
;;
nosj)
#!/usr/bin/env bash
#
# nosj - json parser in pure bash

tokenize() {
    local j str

    while read -rN 1; do
        case $REPLY in
            [\{\}\[\],])
                [[ $str ]] && j+=$REPLY
                [[ $str ]] || { tokens+=("$j" "$REPLY"); j=; }
            ;;

            :)
                [[ $str ]] && j+=:
                [[ $str ]] || j+='\ '
            ;;

            [[:space:]])
                [[ $str ]] && j+=$REPLY
            ;;

            [\"\'])
                [[ $str ]] && str= || str=1
                [[ ${j: -1} == \\ ]] && { str=1; j+=$REPLY; }
            ;;

            *) j+=$REPLY ;;
        esac
    done
}

parse() {
    local i key key_plain nosj objects o out val

    declare -A nosj

    for ((i=0;i<${#tokens[@]};i++)) {
        case ${tokens[i]} in
            \{|\[)
                objects+=("${tokens[i-1]}")
            ;;

            \}|\])
                unset 'objects[-1]'
            ;;

            *\\\ *)
                key=${objects[*]//\\ /.}${tokens[i]/\\ *}
                key_plain=index_${key//[^A-Za-z0-9]/_}
                val=${tokens[i]/*\\ }

                if [[ -n ${nosj[$key]} ]]; then
                    [[ -n ${nosj[${key}[0]]} ]] || {
                        nosj["${key}[0]"]=${nosj[$key]}
                        printf -v o 'nosj[%q]=%q' "${key}[0]" "${nosj[$key]}"
                        out+=("$o")
                    }

                    declare -i "$key_plain+=1"
                    printf -v o 'nosj[%q]=%q' "${key}[${!key_plain}]" "$val"
                    out+=("$o")

                elif [[ $val ]]; then
                    nosj["$key"]=$val
                    printf -v o 'nosj[%q]=%q' "$key" "$val"
                    out+=("$o")
                fi
            ;;
        esac
    }

    printf '%s\n%s\n' "declare -A nosj" "${out[@]}"
}

main() {
    tokenize < "${1:-/dev/stdin}"
    parse
}

LANG=C LC_ALL=C IFS= main "$1"
;;
od)
#!/bin/bash
 
while read line
do
    for ((i=0;i<${#line};i++))
    do
        printf " %02X" \'${line:$i:1}
    done
done < ${1:-/dev/fd/0}
;;
ord)
#!/bin/bash
ord() {
  LC_CTYPE=C printf '%d' "'$1"
}
ord "$@"
;;
ping)
#!/bin/bash
declare -i n
n=0
interval=1
TIMEFORMAT='%3lR'
[ -z "$1" ] && echo not enough arguments && exit
[ -z "$2" ] && port=80
[ -n "$2" ] && port="$2"
( (echo >/dev/tcp/"${1}"/"${port}") &>/dev/null && echo "PING ${1}:${port}") || exit
while true
do
	((n++))
	echo "icmp_seq=${n} time=$( (time echo >/dev/tcp/"${1}"/"${port}") 2>&1 )"
	sleep "${interval}"
done
;;
pr)
#!/bin/bash
#
# pr sort of
shopt -s checkwinsize; (:;:)
get() {
	while getopts "lcw" opt; do
	    case $opt in
	        l) lines=1 ;;
	        c) bytes=1 ;;
	        w) words=1 ;;
	
	        ?)
	            printf '%s\n' "error: -$OPTARG not a valid option." >&2
	            exit 1
	        ;;
	    esac
	done
	
	[[ -t 0 && -f ${*: -1} ]] &&
	    file=${*: -1}
	
	[[ -t 0 && ! -f $file ]] && {
	    printf '%s\n' "wc: ${file:-null}: No such file or directory." >&2
	    exit 1
	}
	
	mapfile file_data < "${file:-/dev/stdin}"
	
	for line in "${file_data[@]}"; do
	    read -ra line_split <<< "$line"
	    ((splits+=${#line_split[@]}, chars+=${#line}))
	done
	
	[[ -z $lines && -z $bytes && -z $words ]] &&
	    ((lines=1, bytes=1, words=1))
	
	[[ $lines ]] && printf '%s ' "${#file_data[@]}"
	[[ $words ]] && printf '%s ' "$splits"
	[[ $bytes ]] && printf '%s ' "$chars"
}
if [[ "$#" == 0 ]]; then
    while read -rn1; do echo "$REPLY"; done
else
    for file in "$@"; do
        if [[ -f $file ]]; then
            lines=$(( LINES - $(get -l "$file") - 1 ))
            printf '%s\n' "$(<"$file")"
            for ((i=1;i<=lines;i+=1)); {
                printf '\n'
            }
        else
            printf '%s\n' "pr: $file: No such file or directory" >&2
        fi
    done
fi
;;
print)
#!/usr/bin/env bash
#
# echo in pure bash.

echo "$@"
;;
printenv)
#!/usr/bin/env bash
#
# printenv in pure bash.

[[ $1 ]] && {
    printf '%s\n' "${!1}"
    exit 0
}

mapfile -t envars < <(compgen -v)

for var in "${envars[@]}"; do
    printf '%s=%s\n' "$var" "${!var}"
done
;;
printf)
#!/usr/bin/env bash
#
# printf in pure bash.

printf "$@"
;;
ps)
#!/bin/bash
cd /proc || exit 1
for item in *; {
	if [[ ! "$item" =~ [^[:digit:]] ]]; then
		echo -n "$item "
		printf '%s\n' "$(<"$item/comm")"
	fi
}
;;
pwd)
#!/usr/bin/env bash
#
# pwd in pure bash.

printf '%s\n' "$PWD"
;;
pwdx)
#!/usr/bin/env bash
for pid in "$@"
do
	cd -P "/proc/$pid/cwd"
	echo "$PWD"
done
;;
readlink)
#!/usr/bin/env bash
#
# realpath in pure bash.

for file in "$@"
do
	[ -f "$file" ] && {
		cd -P "${file%/*}" &&
			echo "$PWD/${file##*/}"
	}
	[ -d "$file" ] && {
		cd -P "$file" &&
			echo "$PWD"
	}
done
;;
readsyntax)
#!/bin/bash
tmp=
comment=false
IFS=
syntax(){
	word="$*"
	[[ "${word}" =~ "#" ]] && colour 38 5 4 "${word}" && comment=true && return
	"${comment}" && colour 38 5 4 "${word}" && return
	[[ "${word}" = '||' ]] && colour 38 5 5 "${word}" && return
	[[ "${word}" = '&&' ]] && colour 38 5 5 "${word}" && return
	[[ "${word}" = ']' ]] && colour 38 5 5 "${word}" && return
	[[ "${word}" = '[' ]] && colour 38 5 5 "${word}" && return
	[[ "${word}" = ')' ]] && colour 38 5 5 "${word}" && return
	[[ "${word}" = '(' ]] && colour 38 5 5 "${word}" && return
	[[ "${word}" = '{' ]] && colour 38 5 5 "${word}" && return
	[[ "${word}" = '}' ]] && colour 38 5 5 "${word}" && return
	[[ "${word}" = ';' ]] && colour 38 5 5 "${word}" && return
	[[ "${word}" =~ '$' ]] && colour 38 5 6 "${word}" && return
	[[ "${word}" =~ '"' ]] && colour 38 5 1 "${word}" && return
	[[ "${word}" =~ "'" ]] && colour 38 5 1 "${word}" && return
	#colour 0 97 108 "${word}"
}
colour(){
	printf '\e[%sD' "${#tmpword}"
	printf "\033[%s;%s;%sm%s" "$1" "$2" "$3" "$4"
	printf "\033[0;0m"
}
readstuff() {
	while read -rsn1 cmd
	do
	[ -z "${cmd}" ] && {
		printf '\n'
		tmpword=
		tmp=
		comment=false
	}
		case "${cmd}" in
			" ")
				printf '%s' "${cmd}"
				tmp="${tmp}${cmd}"
				tmpword=
			;;
			*)
				printf '%s' "${cmd}"
				tmp="${tmp}${cmd}"
				tmpword="${tmpword}${cmd}"
				syntax "${tmpword}"
			;;
		esac
	done
	
}
readstuff
;;
realpath)
#!/usr/bin/env bash
#
# realpath in pure bash.

for file in "$@"
do
	[ -f "$file" ] && {
		cd -P "${file%/*}" &&
			echo "$PWD/${file##*/}"
	}
	[ -d "$file" ] && {
		cd -P "$file" &&
			echo "$PWD"
	}
done
;;
rev)
#!/bin/bash
if [[ "$#" == 0 ]]; then
	while read -r line
	do
		rev=
		len=${#line}
		for((i=len-1;i>=0;i--)); do rev="$rev${line:$i:1}"; done
		echo "$rev"
	done
else
	for file in "$@"; do
		if [[ -f $file ]]; then
			while read -r line
			do
				rev=
				len=${#line}
				for((i=len-1;i>=0;i--)); do rev="$rev${line:$i:1}"; done
				echo "$rev"
			done < "$file"
		else
			printf '%s\n' "rev: $file: No such file or directory" >&2
		fi
	done
fi
;;
rgbtohex)
#!/bin/bash
# Convert an rgb color to hex.
# Usage: rgb_to_hex "r" "g" "b"
[ -z "$3" ] && echo not enough arguments && exit
printf "#%02x%02x%02x\\n" "$1" "$2" "$3"
;;
sed)
#!/usr/bin/env bash
# Usage: bash_sed <before> <after> filename
# s command + global option (s///g) only.
bash_sed () {
  local _pat="$1" ;shift
  local _pat_update="$1" ;shift
  local _fname=${1:-/dev/stdin}
  while read -r line ; do
    if [[ "${line}" =~ $_pat ]];then
      printf "%s\\n" "${line//$_pat/$_pat_update}"
    else
      printf "%s\\n" "${line}"
    fi
  done < "$_fname"
}
;;
seq)
#!/usr/bin/env bash
#
# seq in pure bash.

[[ -z $1 ]] && {
    printf '%s\n' "seq: error: missing arguments." >&2
    exit 1
}
[[ $1 = --help ]] && {
printf '%s\n' "Usage: seq [OPTION]... LAST
  or:  seq [OPTION]... FIRST LAST
  or:  seq [OPTION]... FIRST INCREMENT LAST
Print numbers from FIRST to LAST, in steps of INCREMENT.

      --help     display this help and exit

If FIRST or INCREMENT is omitted, it defaults to 1.  That is, an
omitted INCREMENT defaults to 1 even when LAST is smaller than FIRST.
The sequence of numbers ends when the sum of the current number and
INCREMENT would become greater than LAST."
	exit 0
}

[[ $2 ]] &&
    first="$1"

[[ $3 ]] &&
    increment="$2"

last="${*: -1}"

for ((i=${first:=1};i<=last;i+=${increment:=1})); {
    printf '%s\n' "$i"
}
;;
sh)
#!/usr/bin/env bash
bash --posix $@
;;
sha256sum)
#!/usr/bin/env bash

# Released into the Public Domain.
#
# Original implementation in C by Brad Conte (brad@bradconte.com) <https://github.com/B-Con/crypto-algorithms>
# Ported to Bash (lol) by Josh Junon (josh@junon.me) <https://github.com/qix->
#
# Yes, it's absolutely as slow as it looks.
#
# The only external dependency it has is on a utility called `od`,
# located around line 125. You're more than welcome to replace it with `xxd`
# or some other utility that converts binary to ASCII decimal representation.

function sha256 {
	typeset -a k
	typeset -a data
	typeset -a rhash
	typeset -a bitlen
	typeset -a state
	typeset -i datalen
	
	k=($((0x428a2f98)) $((0x71374491)) $((0xb5c0fbcf)) $((0xe9b5dba5)) $((0x3956c25b)) $((0x59f111f1)) $((0x923f82a4)) $((0xab1c5ed5)) \
		 $((0xd807aa98)) $((0x12835b01)) $((0x243185be)) $((0x550c7dc3)) $((0x72be5d74)) $((0x80deb1fe)) $((0x9bdc06a7)) $((0xc19bf174)) \
		 $((0xe49b69c1)) $((0xefbe4786)) $((0x0fc19dc6)) $((0x240ca1cc)) $((0x2de92c6f)) $((0x4a7484aa)) $((0x5cb0a9dc)) $((0x76f988da)) \
		 $((0x983e5152)) $((0xa831c66d)) $((0xb00327c8)) $((0xbf597fc7)) $((0xc6e00bf3)) $((0xd5a79147)) $((0x06ca6351)) $((0x14292967)) \
		 $((0x27b70a85)) $((0x2e1b2138)) $((0x4d2c6dfc)) $((0x53380d13)) $((0x650a7354)) $((0x766a0abb)) $((0x81c2c92e)) $((0x92722c85)) \
		 $((0xa2bfe8a1)) $((0xa81a664b)) $((0xc24b8b70)) $((0xc76c51a3)) $((0xd192e819)) $((0xd6990624)) $((0xf40e3585)) $((0x106aa070)) \
		 $((0x19a4c116)) $((0x1e376c08)) $((0x2748774c)) $((0x34b0bcb5)) $((0x391c0cb3)) $((0x4ed8aa4a)) $((0x5b9cca4f)) $((0x682e6ff3)) \
		 $((0x748f82ee)) $((0x78a5636f)) $((0x84c87814)) $((0x8cc70208)) $((0x90befffa)) $((0xa4506ceb)) $((0xbef9a3f7)) $((0xc67178f2)))
	
	local data=(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
	local rhash=(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
	local datalen=0
	local bitlen=(0 0)
	local state=($((0x6a09e667)) $((0xbb67ae85)) $((0x3c6ef372)) $((0xa54ff53a)) $((0x510e527f)) $((0x9b05688c)) $((0x1f83d9ab)) $((0x5be0cd19)))
	
	function dbl_int_add {
		if [ ${bitlen[0]} -gt $(( 0xffffffff - ${1} )) ]; then
			bitlen[1]=$(( ${bitlen[1]} + 1 ))
		fi
		bitlen[0]=$(( ${bitlen[0]} + ${1} ))
	}
	
	function rotright {
		echo $(( ((${1} >> ${2}) | (${1} << (32 - ${2}))) & 0xFFFFFFFF ))
	}
	function ch {
		echo $(( (${1} & ${2}) ^ ($(not32 ${1}) & ${3}) ))
	}
	function maj {
		echo $(( (${1} & ${2}) ^ (${1} & ${3}) ^ (${2} & ${3}) ))
	}
	function ep0 {
		echo $(( $(rotright ${1} 2) ^ $(rotright ${1} 13) ^ $(rotright ${1} 22) ))
	}
	function ep1 {
		echo $(( $(rotright ${1} 6) ^ $(rotright ${1} 11) ^ $(rotright ${1} 25) ))
	}
	function sig0 {
		echo $(( $(rotright ${1} 7) ^ $(rotright ${1} 18) ^ (${1} >> 3) ))
	}
	function sig1 {
		echo $(( $(rotright ${1} 17) ^ $(rotright ${1} 19) ^ (${1} >> 10) ))
	}
	function b32 {
		echo $(( ${1} & 0xFFFFFFFF ))
	}
	function not32 {
		b32 $(( ~${1} ))
	}
	
	function sha256_transform {
		declare -a m
		m=(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
		for i in `seq 0 15`; do
			local j=$(($i * 4))
			m[$i]=$(b32 $(( (${data[$j]} << 24) | (${data[$(($j + 1))]} << 16) | (${data[$(($j + 2))]} << 8) | ${data[$(($j + 3))]} )))
		done
		for i in `seq 16 63`; do
			m[$i]=$(b32 $(( $(sig1 ${m[$(($i - 2))]}) + ${m[$(($i - 7))]} + $(sig0 ${m[$(($i - 15))]}) + ${m[$(($i - 16))]} )))
		done

		local a=${state[0]}
		local b=${state[1]}
		local c=${state[2]}
		local d=${state[3]}
		local e=${state[4]}
		local f=${state[5]}
		local g=${state[6]}
		local h=${state[7]}
	
		for i in `seq 0 63`; do
			local t1=$(b32 $(( $h + $(ep1 $e) + $(ch $e $f $g) + ${k[$i]} + ${m[$i]} )))
			local t2=$(b32 $(( $(ep0 $a) + $(maj $a $b $c) )))
			h=$g
			g=$f
			f=$e
			e=$(b32 $(( $d + $t1 )))
			d=$c
			c=$b
			b=$a
			a=$(b32 $(( $t1 + $t2 )))
		done
	
		state[0]=$(b32 $(( ${state[0]} + $a )))
		state[1]=$(b32 $(( ${state[1]} + $b )))
		state[2]=$(b32 $(( ${state[2]} + $c )))
		state[3]=$(b32 $(( ${state[3]} + $d )))
		state[4]=$(b32 $(( ${state[4]} + $e )))
		state[5]=$(b32 $(( ${state[5]} + $f )))
		state[6]=$(b32 $(( ${state[6]} + $g )))
		state[7]=$(b32 $(( ${state[7]} + $h )))
	}
	
	while read line; do
		for byte in $line; do
			data[$datalen]=$byte
			datalen=$(( $datalen + 1 ))
			if [ $datalen -eq 64 ]; then
				sha256_transform
				dbl_int_add 512
				datalen=0
			fi
		done
	done < <(bod -An -t d1) # Replace the call to `od` with your favorite
	                       # binary -> ASCII dec converter here (e.g. xxd)
	
	local i=$datalen
	
	if [ $datalen -lt 56 ]; then
		data[$i]=$(( 0x80 ))
		i=$(( $i + 1 ))
		while [ $i -lt 56 ]; do
			data[$i]=0
			i=$(( $i + 1 ))
		done
	else
		data[$i]=$(( 0x80 ))
		i=$(( $i + 1 ))
		while [ $i -lt 64 ]; do
			data[$i]=0
			i=$(( $i + 1 ))
		done
		sha256_transform
		for j in `seq 0 55`; do
			data[$j]=0
		done
	fi
	
	dbl_int_add $(( $datalen * 8 ))
	data[63]=$(( ${bitlen[0]} & 0xFF ))
	data[62]=$(( (${bitlen[0]} >> 8) & 0xFF ))
	data[61]=$(( (${bitlen[0]} >> 16) & 0xFF ))
	data[60]=$(( (${bitlen[0]} >> 24) & 0xFF ))
	data[59]=$(( ${bitlen[1]} & 0xFF ))
	data[58]=$(( (${bitlen[1]} >> 8) & 0xFF ))
	data[57]=$(( (${bitlen[1]} >> 16) & 0xFF ))
	data[56]=$(( (${bitlen[1]} >> 24) & 0xFF ))
	sha256_transform
	
	for j in `seq 0 3`; do
		rhash[$j]=$(( (${state[0]} >> (24 - $j * 8)) & 0xff ))
		rhash[$(( $j + 4 ))]=$(( (${state[1]} >> (24 - $j * 8)) & 0xff ))
		rhash[$(( $j + 8 ))]=$(( (${state[2]} >> (24 - $j * 8)) & 0xff ))
		rhash[$(( $j + 12 ))]=$(( (${state[3]} >> (24 - $j * 8)) & 0xff ))
		rhash[$(( $j + 16 ))]=$(( (${state[4]} >> (24 - $j * 8)) & 0xff ))
		rhash[$(( $j + 20 ))]=$(( (${state[5]} >> (24 - $j * 8)) & 0xff ))
		rhash[$(( $j + 24 ))]=$(( (${state[6]} >> (24 - $j * 8)) & 0xff ))
		rhash[$(( $j + 28 ))]=$(( (${state[7]} >> (24 - $j * 8)) & 0xff ))
	done
	
	printf "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n" ${rhash[@]}
}
bod()
{
	local c x
	while IFS= read -r -n 1 -d '' c; do
		printf -v x "%d" "'$c"
		printf '%4d' $(( $x & 0xff ))
	done
	printf '\n'
}
sha256
;;
sha512)
#!/bin/bash

# 64-bit rotate right function
# $1 = value to rotate
# $2 = magnitude of rotation
rotate()
{
	lshtmp=$(($(($1>>1))&$((0x7fffffffffffffff))))
	tmp=$(($lshtmp>>$(($2-1))))
	tmp=$(($(($(($1<<$((64-$2))))&$((0xffffffffffffffff))))|$tmp))

	# "return" $tmp
	echo $tmp
}


# Logical left shift: bash provides only an arithmetic left shift, which is not what we want for crypto
#this is an ugly hack, but it works and I couldn't think of another way to do this in pure bash
lshft()
{
	lshtmp=$(($(($1>>1))&$((0x7fffffffffffffff))))
	tmp=$(($lshtmp>>$(($2-1))))

	# "return" $tmp
	echo $tmp
}

#Compute and output the sha512 value of the first argument (a string, not a file)
sha512()
{
	input=$1

	input_hex=''
	for (( i=0; i < ${#input}; i++ ))
	do
		input_hex="$input_hex$(printf "%02x" "'${input:$i:1}")"
	done

	# Yay! sha512 in pure bash

	# pure bash = using only bash, no external applications. printf and echo are used, both of which are bash builtins

	# Initialize hash values
	#(first 64 bits of the fractional parts of the square roots of the first 8 primes 2..19):
	declare -a h
	h[0]=$((0x6a09e667f3bcc908))
	h[1]=$((0xbb67ae8584caa73b))
	h[2]=$((0x3c6ef372fe94f82b))
	h[3]=$((0xa54ff53a5f1d36f1))
	h[4]=$((0x510e527fade682d1))
	h[5]=$((0x9b05688c2b3e6c1f))
	h[6]=$((0x1f83d9abfb41bd6b))
	h[7]=$((0x5be0cd19137e2179))

	# Initialize array of round constants
	#(first 64 bits of the fractional parts of the cube roots of the first 80 primes 2..409):
	declare -a k
	k=(0x428a2f98d728ae22 0x7137449123ef65cd 0xb5c0fbcfec4d3b2f 0xe9b5dba58189dbbc 0x3956c25bf348b538 0x59f111f1b605d019 0x923f82a4af194f9b 0xab1c5ed5da6d8118 0xd807aa98a3030242 0x12835b0145706fbe 0x243185be4ee4b28c 0x550c7dc3d5ffb4e2 0x72be5d74f27b896f 0x80deb1fe3b1696b1 0x9bdc06a725c71235 0xc19bf174cf692694 0xe49b69c19ef14ad2 0xefbe4786384f25e3 0x0fc19dc68b8cd5b5 0x240ca1cc77ac9c65 0x2de92c6f592b0275 0x4a7484aa6ea6e483 0x5cb0a9dcbd41fbd4 0x76f988da831153b5 0x983e5152ee66dfab 0xa831c66d2db43210 0xb00327c898fb213f 0xbf597fc7beef0ee4 0xc6e00bf33da88fc2 0xd5a79147930aa725 0x06ca6351e003826f 0x142929670a0e6e70 0x27b70a8546d22ffc 0x2e1b21385c26c926 0x4d2c6dfc5ac42aed 0x53380d139d95b3df 0x650a73548baf63de 0x766a0abb3c77b2a8 0x81c2c92e47edaee6 0x92722c851482353b 0xa2bfe8a14cf10364 0xa81a664bbc423001 0xc24b8b70d0f89791 0xc76c51a30654be30 0xd192e819d6ef5218 0xd69906245565a910 0xf40e35855771202a 0x106aa07032bbd1b8 0x19a4c116b8d2d0c8 0x1e376c085141ab53 0x2748774cdf8eeb99 0x34b0bcb5e19b48a8 0x391c0cb3c5c95a63 0x4ed8aa4ae3418acb 0x5b9cca4f7763e373 0x682e6ff3d6b2b8a3 0x748f82ee5defb2fc 0x78a5636f43172f60 0x84c87814a1f0ab72 0x8cc702081a6439ec 0x90befffa23631e28 0xa4506cebde82bde9 0xbef9a3f7b2c67915 0xc67178f2e372532b 0xca273eceea26619c 0xd186b8c721c0c207 0xeada7dd6cde0eb1e 0xf57d4f7fee6ed178 0x06f067aa72176fba 0x0a637dc5a2c898a6 0x113f9804bef90dae 0x1b710b35131c471b 0x28db77f523047d84 0x32caab7b40c72493 0x3c9ebe0a15c9bebc 0x431d67c49c100d4c 0x4cc5d4becb3e42b6 0x597f299cfc657e2a 0x5fcb6fab3ad6faec 0x6c44198c4a475817)

	# Pad using MD-Compliant padding:
	input_len=${#input}
	input_len_bin=$(echo -e "\x"$(printf "%x" $(($input_len*8))))
	final_len=$(($(($(($input_len+128))>>7))<<7))

	pad_n=$(($final_len-$input_len))
	input_hex=$input_hex'80'
	for (( i=1; i < $(($pad_n-16)); i++ ))
	do
		input_hex=$input_hex'00'
	done
	input_hex=$input_hex$(printf "%032x" "$(($input_len<<3))")

	# This is the 80 word message schedule array:
	declare -a w

	# Process the message in successive 512-bit chunks:
	for (( i=0; i<$(($final_len<<1)); i+=256 ))
	do
		chunk=${input_hex:$i:256}

		# Clear message schedule array:
		for (( j=0; j<64; j++ ))
		do
			w[$j]=00000000
		done

		# Copy chunk into schedule array:
		for (( j=0; j<16; j++ ))
		do
			w[$j]=$((0x${chunk:$(($j<<4)):16}))
		done


		# Extend the first 16 words into the remaining 64 words w[16..80] of the message schedule array:
		for (( j=16; j<80; j++ ))
		do
			sz=$(($(($(rotate ${w[$(($j-15))]} 1)^$(rotate ${w[$(($j-15))]} 8)))^$(lshft ${w[$(($j-15))]} 7)))
			so=$(($(($(rotate ${w[$(($j-2))]} 19)^$(rotate ${w[$(($j-2))]} 61)))^$(lshft ${w[$(($j-2))]} 6)))
			w[$j]=$((${w[$(($j-16))]}+$sz+${w[$(($j-7))]}+$so))
		done

		# Initialize working variables to current hash value:
		a=${h[0]}
		b=${h[1]}
		c=${h[2]}
		d=${h[3]}
		e=${h[4]}
		f=${h[5]}
		g=${h[6]}
		hay=${h[7]}

		# Compression function main loop:
		for (( j=0; j<80; j++ ))
		do
			SO=$(($(rotate $e 14)^$(rotate $e 18)^$(rotate $e 41)))
			ch=$(($(($e&$f))^$(($((~$e))&$g))))
			temp1=$(($hay+$SO+$ch+${k[$j]}+${w[$j]}))
			SZ=$(($(rotate $a 28)^$(rotate $a 34)^$(rotate $a 39)))
			maj=$(($(($a&$b))^$(($a&$c))^$(($b&$c))))
			temp2=$(($SZ+$maj))

			hay=$g
			g=$f
			f=$e
			e=$(($d+$temp1))
			d=$c
			c=$b
			b=$a
			a=$(($temp1+$temp2))
		done

		# Add the compressed chunk to the current hash value:
		h[0]=$((${h[0]}+$a))
		h[1]=$((${h[1]}+$b))
		h[2]=$((${h[2]}+$c))
		h[3]=$((${h[3]}+$d))
		h[4]=$((${h[4]}+$e))
		h[5]=$((${h[5]}+$f))
		h[6]=$((${h[6]}+$g))
		h[7]=$((${h[7]}+$hay))
	done

	# Produce the final hash value (big-endian):
	for (( i=0; i<8; i++ ))
	do
		printf "%016x" ${h[$i]}
	done
}

sha512 $1
echo # newline
;;
sleep)
#!/usr/bin/env bash
if [ -z "$1" ]; then
  echo "bashbox: sleep: amount of time to sleep not provided"
  exit
fi
read -d "" -rt "$1"
;;
stat)
#!/usr/bin/env bash
testfile(){
	echo "$1"
	[ -b "$1" ] && echo "block special"
	[ -c "$1" ] && echo "char special"
	[ -e "$1" ] && echo "exists"
	[ -d "$1" ] && echo "dir"
	[ -f "$1" ] && echo "regular"
	[ -g "$1" ] && echo "set-group-ID"
	[ -G "$1" ] && echo "owner by effective group-ID"
	[ -L "$1" ] && echo "symlink"
	[ -k "$1" ] && echo "sticky"
	[ -O "$1" ] && echo "owned by effective user-id"
	[ -p "$1" ] && echo "named pipe"
	[ -r "$1" ] && echo "read permission"
	[ -s "$1" ] && echo "size greater 0"
	[ -S "$1" ] && echo "socket"
	[ -u "$1" ] && echo "set-user-ID"
	[ -w "$1" ] && echo "write permission granted"
	[ -x "$1" ] && echo "execute/search granted"
}
for file in "$@"
do
	testfile "$file"
done
;;
strip)
#!/bin/bash
# Strip characters from a string.
# Usage: strip "string" "chars to remove"
if [ "$1" = -e ]; then
	[ -z "$3" ] && echo not enough arguments && exit
	printf "%s\\n" "${2%%$3}"
elif [ "$1" = -s ]; then
	printf "%s\\n" "${2##$3}"
elif [ "$1" = -h ]; then
	printf "Usage: strip string chars-to-remove\n"
	printf "    strip -s to remove from start of string\n"	
	printf "    strip -e to remove from end of string\n"	
else
	[ -z "$2" ] && echo not enough arguments && exit
	printf "%s\\n" "${1//$2}"
fi
;;
syntax)
#!/bin/bash
comment=false
word=
IFS=
syntax(){
	[[ "${word}" =~ "#" ]] && colour 38 5 4 "${word}" && comment=true && return
	"${comment}" && colour 38 5 4 "${word}" && return
	[[ "${word}" = '||' ]] && colour 38 5 5 "${word}" && return
	[[ "${word}" = '&&' ]] && colour 38 5 5 "${word}" && return
	[[ "${word}" = ']' ]] && colour 38 5 5 "${word}" && return
	[[ "${word}" = '[' ]] && colour 38 5 5 "${word}" && return
	[[ "${word}" = ')' ]] && colour 38 5 5 "${word}" && return
	[[ "${word}" = '(' ]] && colour 38 5 5 "${word}" && return
	[[ "${word}" = '{' ]] && colour 38 5 5 "${word}" && return
	[[ "${word}" = '}' ]] && colour 38 5 5 "${word}" && return
	[[ "${word}" = ';' ]] && colour 38 5 5 "${word}" && return
	[[ "${word}" =~ '$' ]] && colour 38 5 6 "${word}" && return
	[[ "${word}" =~ '"' ]] && colour 38 5 1 "${word}" && return
	[[ "${word}" =~ "'" ]] && colour 38 5 1 "${word}" && return
	colour 0 97 108 "${word}"
}
colour(){
	printf "\033[%s;%s;%sm%s" "$1" "$2" "$3" "$4"
	printf "\033[0;0m"
}
readstuff() {
	while read -rsn1 char
	do
		[ "$char" = " " ] && syntax && word='' && printf ' ' && continue
		[ -z "$char" ] && syntax && word='' comment='false' && echo && continue
		word="${word}${char}"
	done
}
readstuff "$@"
;;
tac)
#!/usr/bin/env bash
for file in "$@"
do
	i=0 
	
	while read line[$i] ; do
	    i=$(($i+1))
	done < $file
	
	
	for (( i=${#line[@]}-1 ; i>=0 ; i-- )) ; do
	    echo ${line[$i]}
	done
done
;;
tail)
#!/usr/bin/env bash
#
# tail in pure bash.

while getopts ":n:" opt; do
    case $opt in
        n) max_lines="$OPTARG" ;;

        :)
            printf '%s\n' "option -$OPTARG requires an argument." >&2
            exit 1
        ;;

        ?)
            printf '%s\n' "error: -$OPTARG not a valid option." >&2
            exit 1
        ;;
    esac

    shift "$((OPTIND - 1))"
done

[[ ! -f $1 ]] && {
    printf '%s\n' "tail: ${1:-null}: No such file or directory." >&2
    exit 1
}

mapfile -tn 0 file_data < "$1"

[[ ${max_lines:=0} -gt "${#file_data[@]}" ]] &&
    max_lines="${#file_data[@]}"

printf '%s\n' "${file_data[@]: -$max_lines}"
;;
tee)
#!/bin/bash
if [ -z "$1" ]; then
	printf '%s\n' "$(<"/dev/stdin")"
elif [ "$1" = "-a" ]; then
	if [ -z "$2" ]; then
		printf '%s\n' "$(<"/dev/stdin")"
	else
		printf '%s\n' "$(<"/dev/stdin")" >> "$2"
	fi
else
	printf '%s\n' "$(<"/dev/stdin")" > "$1"
fi
;;
time)
#!/bin/bash
$@
echo "$SECONDS"
;;
timeout)
#!/bin/bash
#today i learned that kill is bash builtin

#basically spawn process which waits the timeout
#and then kills this script (which means also the command ) if it still runs 
[ -z "$1" ] && echo timeout not provided && exit 125
[ -z "$2" ] && echo no command provided && exit 125
manage() {
	sleep "$2"
	[ -d "/proc/$1" ] && kill "$1"
}
manage $$ "$1" &
shift
"$@"
;;
top)
#!/bin/bash
timeup() {
	: "$(</proc/uptime)"
	seconds_up=${_%%.*}
	minutes_up=$((seconds_up/60))
	printf ' %(%H:%M:%S)T up '
	if [[ $((minutes_up)) -ge 1440 ]]; then
		printf '%d days, ' $((minutes_up/1440))
	fi
	if [[ $((minutes_up)) -ge 60 ]]; then
		printf '%2d:%02d' $((minutes_up%1440/60)) $((minutes_up%60))
	else
		printf '%d min' $minutes_up
	fi
}
parseuid() {
	m=0
	while IFS=':' read -ra addr; do
		n=0
		for i in "${addr[@]}"; do
			if [ $n = 2 ]; then
				e=0
				for y in "${addr[@]}"; do
					[ $e = 0 ] && uid[$i]="$y"
					e=notzero
					break
				done
			fi
			n=$(( n + 1 ))
		done
		m=$(( m + 1 ))
	done < /etc/passwd
}
linesget() {
	n=0
	while read -r line
	do
		n=$(( n + 1 ))
		lines[$n]="$line"
	done
	for arg in "$@"
	do
		#echo the line requested from the array
		echo "${lines[$arg]}"
	done
}
mem() {
	printf '%s\n' "$(</proc/meminfo)" | linesget 1 2 21 5 3
}
getproc() {
	cd /proc || exit 1
	proc=$(echo *)
	a=8
	ignore=$(( $1 + 7 ))
	for item in $proc; {
		if [ -d "$item" ]; then
			if [ "$a" -gt "$ignore" ]; then
				[ "$a" = $(( LINES + $1 )) ] && break
				if [[ ! "$item" =~ [^[:digit:]] ]]; then
					printf '\r%*s\r' 10 ' '
					printf '%-10s' "$item "
					c=0
					for word in $(linesget 9 < "$item"/status); {
						[ $c = 1 ] && printf '%*s\e[10G' 10 ' ' && printf '%-10s' "${uid[$word]}"
						c=$(( c + 1 ))
					}
					printf '%*s\e[20G' $((COLUMNS - 20)) ' '
					printf '%s\n' "$(<"$item/comm")"
				fi
			fi
			a=$(( a + 1 ))
		fi
	}
}
draw() {
	#clear the screen
	#	printf "\033c"
	printf '\e[0;0H'
	#print lines
	printf '%*s\n' $COLUMNS ' '
	printf '%*s\n' $COLUMNS ' '
	printf '%*s\n' $COLUMNS ' '
	printf '%*s\n' $COLUMNS ' '
	printf '%*s\n' $COLUMNS ' '
	printf '%*s\n' $COLUMNS ' '
	printf '\e[0;0H'
	echo -n top; timeup; echo
	mem
	printf '\033[0;30;107mPID      USER      COMMAND%*s\033[0;0m\n' "$((COLUMNS - 26))" ' '
	#this all is 7 lines
	getproc "$1"
	read -rsn1 -t 1 input
	if [[ $input == "$escape" ]]; then
		read -rsn2 input
	fi
	[ -z "$input" ] && draw "$1"
	[ "$input" = "[B" ] && draw $(( $1 + 1 ))
	[ "$input" = "[A" ] && draw $(( $1 - 1 ))
	[ "$input" = "q" ] && exit
}
#prepare
#escape
escape=$(printf "\u1b")
shopt -s checkwinsize; (:;:)
cd /proc || exit 1
proc=$(echo *)
parseuid

draw 0
;;
touch)
#!/usr/bin/env bash
#touch in pure bash
if [ ! -f $1 ]; then
 >$1
fi
;;
tput)
#!/usr/bin/env bash

############################
#TODO: THIS IS SHITE
############################

shopt -s checkwinsize; (:;:)
printhelp() {
 echo "Usage: tput [command]
colors:
 16 colors:
  set - set color and property
  set 0 0 - reset terminal
  tput mode:
   setaf - set foreground color
   setab - set background color
   sgr0 - reset terminal
  256 colors:
  esetf - set foreground color 
  esetb - set backgroud color
 24-bit colors:
  rgb format:
   rsetf - set foreground color
   rsetb - set background color
  hex format:
   hsetf - set foreground color
   hsetb - set background color
cursor:
 moving:
  cup - moves cursor to given position
  cbt - moves cursor backwards
  cha - Move the active position to the n-th character of the active line.
  cnl - Move cursor to next line.
  cpl - Move cursor to previous line.
  cub - moves to left
  cud - moves down
  cuf - moves right
  cuu - moves up
 hide:
  hide - hides cursor
  unhide - unhides cursor
  pos - prints position of cursor
 etc:
  dch - delete characters on right
  decrc - restore cursor
  decsc - save cursor
info:
 cols - width of terminal
 lines - height of terminal
 decaln - fills screen
 decawm-set - enables autowrap
 decawm-reset - disables autowrap
property:
 deccara - sets attribute in area x y end-x end-y:
  0
  (default) 	Attributes off (no bold, no underline, no blink, positive image)
  1 	Bold
  4 	Underline
  5 	Blink
  7 	Negative image
  22 	No bold
  24 	No underline
  25 	No blink
  27 	Positive image
 decdhl:
  top - sets font to big top half
  bottm - sets font to big bottom half
 decdwl - Double-Width, Single-Height Line
 save - saves screen
 restore - restore screen
 "
}
##colors
get_cursor_pos() {
    # Usage: get_cursor_pos
    IFS='[;' read -p $'\e[6n' -d R -rs _ y x _
    printf '%s\n' "$y $x"
}
modeput() {
	printf "\033[$1;$2m"
}
rgbputf() {
	printf "\033[38;2;$1;$2;$3m"
}
rgbputb() {
	printf "\033[48;2;$1;$2;$3m"
}
#cursor
hide() {
	printf '\e[?25l\e[?7l'
}
unhide() {
	printf "\e[?25h\e[?7h"
}

if [ -z $1 ]; then
	printhelp
elif [ $1 = rsetf ]; then
	printf "\033[38;2;$2;$3;$4m"
elif [ $1 = rsetb ]; then
	printf "\033[48;2;$2;$3;$4m"
elif [ $1 = esetf ]; then
	printf "\033[38;5;$2m"
elif [ $1 = esetb ]; then
	printf "\033[48;5;$2m"
elif [ $1 = set ]; then
	modeput $2 $3
elif [ $1 = setaf  ]; then
	if   [ $2 = 0  ]; then modeput 0 30
	elif [ $2 = 1  ]; then modeput 0 31
	elif [ $2 = 2  ]; then modeput 0 32
	elif [ $2 = 3  ]; then modeput 0 33
	elif [ $2 = 4  ]; then modeput 0 34
	elif [ $2 = 5  ]; then modeput 0 35
	elif [ $2 = 6  ]; then modeput 0 36
	elif [ $2 = 7  ]; then modeput 0 37
	elif [ $2 = 8  ]; then modeput 0 90
	elif [ $2 = 9  ]; then modeput 0 91
	elif [ $2 = 10 ]; then modeput 0 92
	elif [ $2 = 11 ]; then modeput 0 93
	elif [ $2 = 12 ]; then modeput 0 94
	elif [ $2 = 13 ]; then modeput 0 95
	elif [ $2 = 14 ]; then modeput 0 96
	elif [ $2 = 15 ]; then modeput 0 97
	elif [ $2 = 16 ]; then modeput 0 98
	else modeput 0 31;echo bashbox tput: tput-mode: unknown color; modeput 0 0; fi
elif [ $1 = setab ]; then
	if   [ $2 = 0  ]; then modeput 0 40
	elif [ $2 = 1  ]; then modeput 0 41
	elif [ $2 = 2  ]; then modeput 0 42
	elif [ $2 = 3  ]; then modeput 0 43
	elif [ $2 = 4  ]; then modeput 0 44
	elif [ $2 = 5  ]; then modeput 0 45
	elif [ $2 = 6  ]; then modeput 0 46
	elif [ $2 = 7  ]; then modeput 0 47
	elif [ $2 = 8  ]; then modeput 0 100
	elif [ $2 = 9  ]; then modeput 0 101
	elif [ $2 = 10 ]; then modeput 0 102
	elif [ $2 = 11 ]; then modeput 0 103
	elif [ $2 = 12 ]; then modeput 0 104
	elif [ $2 = 13 ]; then modeput 0 105
	elif [ $2 = 14 ]; then modeput 0 106
	elif [ $2 = 15 ]; then modeput 0 107
	elif [ $2 = 16 ]; then modeput 0 108
	else modeput 0 41;echo cput: tput-mode: unknown color; modeput 0 0; fi
elif [ $1 = sgr0  ]; then modeput 0 0
elif [ $1 = cup   ]; then printf "\033[$2;$3H"
elif [ $1 = hsetf ]; then
	r=$(printf "%d" "0x$(echo $2 | cut -c 1-2)")
	g=$(printf "%d" "0x$(echo $2 | cut -c 3-4)")
	b=$(printf "%d" "0x$(echo $2 | cut -c 5-6)")
	rgbputf $r $g $b
elif [ $1 = hsetb ]; then
	r=$(printf "%d" "0x$(echo $2 | cut -c 1-2)")
	g=$(printf "%d" "0x$(echo $2 | cut -c 3-4)")
	b=$(printf "%d" "0x$(echo $2 | cut -c 5-6)")
	rgbputb $r $g $b
elif [ $1 = clear              ]; then printf "\033c"
elif [ "$1" = cols             ]; then echo $COLUMNS
elif [ "$1" = lines            ]; then echo $LINES
elif [ "$1" = pos              ]; then get_cursor_pos
elif [ "$1" = hid              ]; then hide
elif [ "$1" = unhid            ]; then unhide
elif [ "$1" = cbt              ]; then printf "\e[$2Z"
elif [ "$1" = cha              ]; then printf "\e[$2G"
elif [ "$1" = cnl              ]; then printf "\e[$2E"
elif [ "$1" = cpl              ]; then printf "\e[$2F"
elif [ "$1" = cub              ]; then printf "\e[$2D"
elif [ "$1" = cud              ]; then printf "\e[$2B"
elif [ "$1" = cuf              ]; then printf "\e[$2C"
elif [ "$1" = cuu              ]; then printf "\e[$2A"
elif [ "$1" = dch              ]; then printf "\e[$2P"
elif [ "$1" = decaln           ]; then printf "\e#8"
elif [ "$1" = decawm-set       ]; then printf "\e[?7h"
elif [ "$1" = decawm-reset     ]; then printf "\e[?lh"
elif [ "$1" = deccara          ]; then printf "\e[$2;$3;$4;$5;$6\$r"
elif [ "$1" = decdhl-top       ]; then printf "\e#3"
elif [ "$1" = decdhl-bottom    ]; then printf "\e#4"
elif [ "$1" = decdwl           ]; then printf "\e#6"
elif [ "$1" = decrc            ]; then printf "\e8"
elif [ "$1" = decsc            ]; then printf "\e7"
elif [ "$1" = save             ]; then printf '\e[?1049h'
elif [ "$1" = restore          ]; then printf '\e[?1049l'
else
 modeput 0 31; echo Error: unknow subcommand, printing help...; modeput 0 0
 printhelp
fi
;;
true)
#!/usr/bin/env bash
#
# true in pure bash.
exit 0
;;
truecolors)
#!/bin/bash
#printf "\033[38;2;$1;$2;$3m"
repeat() {
	[[ -z $1 ]] && {
	    printf '%s\n' "seq: error: missing arguments." >&2
	    exit 1
	}
	
	[[ $2 ]] &&
	    first="$1"
	
	[[ $3 ]] &&
	    increment="$2"
	
	last="${*: -1}"
	
	for ((i=${first:=1};i<=last;i+=${increment:=1})); {
	    printf '%s\n' "$i"
	}
	
}
genrgb(){
	nummin=255
	numadd=-1
	for a in $(repeat 0 1540)
	do
		numadd=$(( numadd + 1 ))
		nummin=$(( nummin - 1 ))
		[ $a -lt 256 ] && echo -n "\033[48;2;255"
		[ $a -lt 256 ] && echo -n ";$numadd"
		[ $a -lt 256 ] && echo -n ";0m" && echo
		[ $a = 256 ] && numadd=0 && nummin=255
		[ $a -gt 256 ] && [ $a -lt 512 ] && echo -n "\033[48;2;$nummin"
		[ $a -gt 256 ] && [ $a -lt 512 ] && echo -n ";255"
		[ $a -gt 256 ] && [ $a -lt 512 ] && echo -n ";0m" && echo
		[ $a = 512 ] && numadd=0 && nummin=256
		[ $a -gt 512 ] && [ $a -lt 768 ] && echo -n "\033[48;2;0"
		[ $a -gt 512 ] && [ $a -lt 768 ] && echo -n ";255"
		[ $a -gt 512 ] && [ $a -lt 768 ] && echo -n ";${numadd}m" && echo
		[ $a = 768 ] && numadd=0 && nummin=255
		[ $a -gt 768 ] && [ $a -lt 1024 ] && echo -n "\033[48;2;0"
		[ $a -gt 768 ] && [ $a -lt 1024 ] && echo -n ";$nummin"
		[ $a -gt 768 ] && [ $a -lt 1024 ] && echo -n ";255m" && echo
		[ $a = 1024 ] && numadd=0 && nummin=255
		[ $a -gt 1024 ] && [ $a -lt 1280 ] && echo -n "\033[48;2;$numadd"
		[ $a -gt 1024 ] && [ $a -lt 1280 ] && echo -n ";0"
		[ $a -gt 1024 ] && [ $a -lt 1280 ] && echo -n ";255m" && echo
		[ $a = 1280 ] && numadd=0 && nummin=255
		[ $a -gt 1280 ] && [ $a -lt 1536 ] && echo -n "\033[48;2;255"
		[ $a -gt 1280 ] && [ $a -lt 1536 ] && echo -n ";0"
		[ $a -gt 1280 ] && [ $a -lt 1536 ] && echo -n ";${nummin}m" && echo
	done
	#grey
	for b in $(repeat 0 255 )
	do
		echo  "\033[48;2;${b};${b};${b}m"
	done
	#red
	for c in $(repeat 0 255 )
	do
		echo  "\033[48;2;${c};0;0m"
	done
	#green
	for d in $(repeat 0 255 )
	do
		echo  "\033[48;2;0;${d};0m"
	done
	#blue
	for e in $(repeat 0 255 )
	do
		echo  "\033[48;2;0;0;${e}m"
	done
	#yellow
	for f in $(repeat 0 255 )
	do
		echo  "\033[48;2;${f};${f};0m"
	done
	#cyan
	for g in $(repeat 0 255 )
	do
		echo  "\033[48;2;0;${g};${g}m"
	done
	#magenta
	for h in $(repeat 0 255 )
	do
		echo  "\033[48;2;${h};0;${h}m"
	done
}
printe() {
	echo '\033[48;2;<r>;<g>;<b>m" - background'
	echo '\033[38;2;<r>;<g>;<b>m" - foreground'
	while read wtf
	do
		printf "\\${wtf} "
	done
}
genrgb | printe
echo
;;
ttysize)
#!/usr/bin/env bash
shopt -s checkwinsize; (:;:)
echo "$COLUMNS $LINES"
;;
type)
#!/bin/bash
type $@
;;
uidname)
#!/bin/bash
parseuid() {
	m=0
	while IFS=':' read -ra addr; do
		n=0
		for i in "${addr[@]}"; do
			if [ $n = 2 ]; then
				e=0
				for y in "${addr[@]}"; do
					[ $e = 0 ] && uid[$i]="$y"
					e=notzero
					break
				done
			fi
			n=$(( n + 1 ))
		done
		m=$(( m + 1 ))
	done < /etc/passwd
}
[ -z "$1" ] && echo no uid provided && exit
parseuid
for arg in "$@"; {
	echo "${uid[$arg]}"
}
;;
uname)
#!/usr/bin/env bash
if [ -z $1 ]; then
	echo $OSTYPE
elif [ $1 = -m ]; then
	printf '%s\n' "$HOSTTYPE"
elif [ $1 = --type ]; then
	echo $MACHTYPE
elif [ $1 = -a ]; then #linux only 
	printf '%s\n' "$(<"/proc/version")" #linux only
elif [ $1 = -n ]; then
	: '\h'
	printf '%s\n' "${_@P}"
else 
	echo "flags: -m --type -n"
fi
;;
uniq)
#!/bin/bash
repeat=no
if [ "$1" = -d ]; then
	while read -r line; do
		for check in "${hab[@]}"
		do
			if [ "$line" = "$check" ]; then
				echo "$line"
			fi
		done
		hab+=("$line")
	done
else
	while read -r line; do
		for check in "${hab[@]}"
		do
			if [ "$line" = "$check" ]; then
				repeat=yes
			fi
		done
		#echo $repeat : $line
		[ "$repeat" = "no" ] && echo "$line"
		repeat=no
		hab+=("$line")
	done
fi
;;
uppercase)
#!/bin/bash
# Uppercase a string.
# Usage: upper "string"
while read -r line
do
	printf "%s\\n" "${line^^}"
done
;;
uptime)
#!/usr/bin/env bash
#
# uptime in pure bash.

: "$(</proc/uptime)"
seconds_up=${_%%.*}
if [[ "$#" == 0 ]]; then
    printf ' %(%H:%M:%S)T up '
    if [[ $((minutes_up)) -ge 1440 ]]; then
        printf '%d days, ' $((minutes_up/1440))
    fi
    if [[ $((minutes_up)) -ge 60 ]]; then
        printf '%2d:%02d' $((minutes_up%1440/60)) $((minutes_up%60))
    else
        printf '%d min' $minutes_up
    fi 
else
   	getopts sp options
    case $options in
        s) current_timestamp=$(printf '%(%s)T')
           printf '%(%Y-%m-%d %H:%M:%S)T\n' $((current_timestamp-seconds_up));;
        p) minutes_up=$((seconds_up/60))
           printf 'up '
           if [[ $((minutes_up)) -ge 60 ]]; then
               printf '%d hours, ' $((minutes_up/60))
           fi
           printf '%d minutes\n' $((minutes_up%60));;
        ?) echo "$0: invalid option -- '$options'
Usage: $0 [-ps]">&2;;
    esac
fi
;;
vdir)
#!/usr/bin/bash
#!/usr/bin/env bash
infofile() {
	if [ -L $1 ]; then
		echo -n l
	elif [ -d $1 ]; then
		echo -n d
	else
		echo -n '-'
	fi
	[ -r $1 ] && echo -n r || echo -n '-'
	[ -w $1 ] && echo -n w || echo -n '-'
	[ -x $1 ] && echo -n x || echo -n '-'
	[ -L $1 ] && [ -d $1 ] && cd -P "$1" && echo " $1 -> $PWD" && cd .. || echo " $1"
}
infofiles() {
	for f in $(printf '%s\n' *); {
		infofile "$f"
	}
}
infofilesall() {
	for f in $(printf '%s\n' .* && printf '%s\n' *); {
		infofile "$f"
	}
}
[ -z "$1" ] && infofiles
[ "$1" = "-a" ] && infofilesall
[ "$1" = "-l" ] && infofiles
[ "$1" = "-la" ] && infofilesall
[ "$1" = "-al" ] && infofilesall
;;
vi)
#!/usr/bin/env bash
### SETTINGS ###
# this is what TAB will insert.
# default value is "  ". possible values are any string.
tabchar="	"

# auto tab with bim_insert, bim_backinsert, or when ENTER is pressed in insert mode.
# default value is "0". possible values are 0 or 1.
autotab="0"
line=0
base=1
version="bashbox vi (bim)"
message="welcome to vi"
unsaved_changes=0

declare -a buffer
declare -i line base
declare file version message
bind 'set disable-completion on' 2>/dev/null
shopt -s checkwinsize; (:)
trap refresh WINCH ALRM
trap cleanup EXIT INT HUP USR1

split() {
   # Usage: split "string" "delimiter"
   # thanks dylan araps :)
   IFS=$'\n' read -d "" -ra arr <<< "${1//$2/$'\n'}"
}

keybinds() {
            case "${key}" in
            
                # motions
                k) bim_up 1;;
                j) bim_down 1;;
                K) bim_up $((LINES - 4));;
                J) bim_down $((LINES - 4));;
                g) bim_bof;;
                G) bim_eof;;
                t) cursor show
                   bim_goto "$(misc_prompt "goto: ")"
                   cursor hide
                   ;;
                
                # editing
                a|i) bim_edit;;
                I) bim_prepend;;
                d) bim_delete;;
                c) bim_clear;;
                o) bim_insert;;
                O) bim_backinsert;;
                n) bim_blank 1; bim_down 1;;
                N) bim_backblank 1;;
                y) bim_yank;;
                p) bim_paste; bim_down 1;;
            
                # misc
                :) bim_prompt;;
                z) bim_center;;
            
            esac
}
        
startup() {
    cursor hide
    cursor spos
    cursor nowrap
    cursor block
}

cleanup() {
    cursor show
    cursor rpos
    cursor goto $LINES 0
    cursor wrap
    cursor block
    exit 0
}

cursor() {
    case "$1" in
    save) printf "\e[?47h";;
    load) printf "\e[?47l";;
    spos) printf "\e7";;
    rpos) printf "\e8\e[B";;
    hide) printf "\e[?25l";;
    show) printf "\e[?25h";;
    goto) printf "\e[%s;%sf" "$2" "$3";;
    wrap) printf "\e[?7h";;
    nowrap) printf "\e[?7l";;
    #beam) printf "\e[5 q";;
    #block) printf "\e[1 q";;
    #underline) printf "\e[3 q";;
    esac
}
clear() {
	printf "\033c"
}
refresh() {
    clear
    #printf "\e[36m %s (%s Lines) %s %sx%s %s \e[m\n" \
        #"$file" "${#buffer[@]}" "$version" "$LINES" "$COLUMNS" "$base"
    for ((i=base; i-base < LINES-2; i++)); do
        ((i !=  line))        && printf "\e[93m"     || printf "\e[31;1m"
        ((i > ${#buffer[@]})) && printf "   ~\e[m\n" || printf "%4s\e[m %s\n" "$i" "${buffer[i]}"
    done
    if [ "$message" ]; then
        printf "\e[32;1m%s\e[m\n" "$message"
    else
        printf "\e[36;1m%s [%s] %s/%s {%sx%s}\e[m\n" \
            "$version" "${file}" "$line" "${#buffer[@]}" "$LINES" "$COLUMNS"
    fi
}

bim_read() {
    if [ "$1" ]; then
        file="$1"
    else
        message="expected argument [FILE]"
        return 1
    fi

    if [ -e "$file" ];then
        mapfile -t -O 1 buffer <"$file"
        message="Read ${#buffer[@]} lines from '$file'"
    else
        message="new file '$file'"
    fi

    [ ${#buffer[@]} -ne 0 ] && line=1
}

bim_write() {
    if [ "$1" ]; then
        myfile="$1"
    elif [ "$file" ]; then
        myfile="$file"
    else
        message="no file to write."
        return 1
    fi
    : >"$myfile"
    for wline in "${buffer[@]}"; do echo "$wline" >> "$myfile"; done
    message="Wrote ${#buffer[@]} lines to '$myfile'"   
    unsaved_changes=0
}

bim_up() {
    [ "$1" ] && num="$1" || num=1
    for ((i=0;i<$num;i++)); do
        ((line > 1))    && ((line--))
    done
}

bim_down() {
    [ "$1" ] && num="$1" || num=1
    for ((i=0;i<$num;i++)); do
        ((line < ${#buffer[@]})) && ((line++))
    done
}

bim_delete() {
    lineyank="${buffer[line]}"
    buffer=([0]="" "${buffer[@]:1:line-1}" "${buffer[@]:line+1}")
    unset "buffer[0]"
    ((line > ${#buffer[@]})) && ((line--))
    message="line cut."
    unsaved_changes=1
}

bim_insert() {
    buffer=([0]="" "${buffer[@]:1:line}" "" "${buffer[@]:line+1}")
    unset "buffer[0]"
    ((line++))
    # check if autotab is on and if the tab block we're extending starts with spaces
    if [ $autotab = 1 ] && [ "${buffer[line-1]::1}" = " " ]; then
        # wacky code to get the tab size of the last line
        local lasttab="${buffer[line-1]%${buffer[line-1]##* }}"
        # put in that same tab length to what we're going to edit
        buffer[line]="$lasttab"
    fi
    # I have no clue why this has to be "-4" here
    ((line > base+LINES-4))  && ((base++))
    bim_edit
}

bim_backinsert() {
    buffer=([0]="" "${buffer[@]:1:line-1}" "" "${buffer[@]:line}")
    unset "buffer[0]"
    # same code as 'bim_insert'
    if [ $autotab = 1 ] && [ "${buffer[line+1]::1}" = " " ]; then
        local lasttab="${buffer[line+1]%${buffer[line+1]##* }}"
        buffer[line]="$lasttab"
    fi
    bim_edit
}

bim_blank() {
    [ "$1" ] && num="$1" || num=1
    for ((i=0;i<$num;i++)); do
        buffer=([0]="" "${buffer[@]:1:line}" "" "${buffer[@]:line+1}")
        unset "buffer[0]"
    done
}

bim_backblank() {
    [ "$1" ] && num="$1" || num=1
    for ((i=0;i<$num;i++)); do
        buffer=([0]="" "${buffer[@]:1:line-1}" "" "${buffer[@]:line}")
        unset "buffer[0]"
    done
}

bim_yank() {
    lineyank="${buffer[line]}"
    message="line yanked."
}

bim_paste() {
    buffer=([0]="" "${buffer[@]:1:line}" "$lineyank" "${buffer[@]:line+1}")
    unset "buffer[0]"
}

bim_clear() {
    ((line == 0)) && return
    cursor goto $((line-base + 2)) 6
    buffer[line]=""
    unsaved_changes=1
}

# insert mode
# my new robust replacement for 'read' that goes character by character
bimput() { # <var> [starting string]
    # starting text of line
    local buf="$2"
    local ch=""
    cursor beam
    cursor show
    while true; do
        IFS='' read -s -n1 ch
        case "$ch" in
            "")
                bimputstatus="esc"
                break
                ;;
            # read -n1 seems to interpret ENTER as nothing
            "")
                bimputstatus="enter"
                break
                ;;
            # vscode is unable do display a backspace
            # but there is one between these quotes
            "")
                if [ "$buf" ]; then
                    buf="${buf%?}"
                    printf "\b \b"
                else
                    bimputstatus="backline"
                    break
                fi
                ;;
            "	")
                buf="${buf}${shiftwidth:="  "}"
                echo -n "${shiftwidth}"
                ;;
            *)
                buf="${buf}${ch}"
                printf "$ch"
                ;;
        esac
    done
    eval "${1}=\${buf}"
    cursor hide
    cursor block
}

bim_edit() {
    # refresh, as 'read' will freeze drawing
    refresh
    # make a line in an empty buffer
    ((line == 0)) && buffer[1]="" && line=1 && refresh
    # print '--INSERT--' at the bottom
    cursor goto $LINES
    printf "\e[32m%s\e[m" "--INSERT--"
    # do the actual thing
    cursor goto $((line-base + 1)) $((6 + ${#buffer[line]}))
    bimput "buffer[line]" "${buffer[line]}"
    case "$bimputstatus" in
        "enter")
            # nice and simple
            bim_insert
            ;;
        "backline")
            # delete line
            buffer=([0]="" "${buffer[@]:1:line-1}" "${buffer[@]:line+1}")
            unset "buffer[0]"
            # go back a line and edit
            ((line--))
            bim_edit
            ;;
    esac
    unsaved_changes=1
}

bim_prepend() {
    # refresh, as 'read' will freeze drawing
    refresh
    # make a line in an empty buffer
    ((line == 0)) && buffer[1]="" && line=1 && refresh
    # print '--INSERT--' at the bottom
    cursor goto $LINES
    printf "\e[32m%s\e[m" "--PREPEND--"
    # do the actual thing
    cursor goto $((line-base + 2)) 4
    printf "^~"
    cursor underline
    cursor show
    read -re
    cursor hide
    cursor block
    # write $REPLY + what was already there
    buffer[line]="${REPLY}${buffer[line]}"
    unsaved_changes=1
}

bim_prompt() {
    bind 'set disable-completion off' 2>/dev/null
    cursor show
    read -rep ":" choice
    bind 'set disable-completion on' 2>/dev/null

    # run command and wait
    if [ "${choice::1}" = "!" ]; then
        eval "${choice##!}"
        cursor hide
        printf "\e[31mpress any key to continue."
        read -N1 -r
    # read command output
    elif [ "${choice::3}" = "r !" ]; then
        eval "output=\"\$(${choice##r !})\""
        split "$output" $'\n'
        bim_blank ${#arr[@]}
        i=0
        while [ $i -lt ${#arr[@]} ]; do
            buffer[line+i+1]="${arr[i]}"
            unset "buffer[0]"
            ((i++))
        done
        cursor hide
        unsaved_changes=1
    # simply run command
    else
        eval "$choice"
        succ=$?
        if [ ! "$(type -t ${choice%% *})" = "function" ]; then
            message="finished with exit code $succ"
        fi
        cursor hide
    fi
    # cursor must be hidden in each case individually.
}

misc_prompt() {
    # cursor must be shown externally
    # as to not pass escape sequences into functions
    [ "$1" ] || return 1
    bind 'set disable-completion off' 2>/dev/null
    read -rep "$1"
    bind 'set disable-completion on' 2>/dev/null

    printf '%s' "$REPLY"
}

quit() {
    if [ "$unsaved_changes" = 0 ]; then
        exit 0
    else
        message="unsaved changes. force quit with \":q!\""
    fi
}

bim_bof() {
	[ ${#buffer[@]} = 0 ] && return 1
    line=1
}

bim_eof() {
    line=${#buffer[@]}
}

bim_goto() {
    [ "$1" ] || return 1
    [ ${#buffer[@]} -ge $1 ] && line=$1
}

bim_center() {
    (( base=line-((LINES-3)/2) ))
    [ $base -lt 1 ] && base=1
}

# functions that are really just aliases
# and shortcuts for the command line

w() {
    bim_write "$@"
}

q() {
    quit
}

q!() {
    exit 0
}
wq() {
    w "$@" && q
}

e() {
    bim_read "$@"
}


keyboard_loop () {
    startup
    [ "$1" ] && bim_read "$1"
    refresh

    while true; do
        read -rsN1 key
        message=""

        # iteration (only 2 digit numbers)
        # cancel with ESC
        case $key in
            1|2|3|4|5|6|7|8|9)
                digit1="$key"
                printf '%d' "$key"
                read -rsN1 key
                case $key in
                    1|2|3|4|5|6|7|8|9|0)
                        digit2="$key"
                        printf '%d' "$key"
                        read -rsN1 key
                        ;;
                    "")
                        digit1="1"
                        digit2=""
                        ;;
                    *)
                        digit2=""
                        ;;
                esac
                ;;
            "")
                digit1="1"
                digit2=""
                ;;
            *)
                digit1="1"
                digit2=""
                ;;
        esac

        # compute keys from rc or defaults
        # reiterate if applicable
        kbj="${digit1}${digit2}"
        for ((kbinc=0; kbinc < kbj; kbinc++)); do
            keybinds
        done

        # universal scrolling system
        if [ $base -gt $line ]; then
            [ $base = 1 ] || base=$line
        elif (( base+LINES-3 < line )); then
            ((base=line-LINES+3))
        fi

        # refresh the UI
        refresh
    done
    clear
}

usage () {
echo '
bim: bash vim

usage: ${0##*/} [ options | file ]

options:
    -h|--help : print this help message
    -k|--keys : print a basic usage document'
}

keys () {
echo '# navigation
  j - move down  (:bim_down [LINES])
  k - page up    (:bim_up [LINES])
  J - page down
  K - page up
  g - first line (:bim_bof)
  G - last line  (:bim_eof)
  t - go to line (:bim_goto [LINE])

# editing
  a - append to line  (:bim_edit)
  I - prepend to line (:bim_prepend)
  d - delete line     (:bim_delete)
  c - clear line      (:bim_clear)
  y - yank line       (:bim_yank)
  p - paste line      (:bim_paste)
  n - create line below (:bim_blank [LINES])
  N - create line above (:bim_backblank [LINES])
  o - create line below and edit (:bim_insert)
  O - create line above and edit (:bim_backinsert)

# commands
# NOTE: the command line is for both editor and shell commands.
   : - open command line
  :w [FILE] - write to current or given file
  :q - quit
 :q! - force quit
 :wq - write and quit
  :e [FILE] - open file
  :![COMMAND] - pause to view the output of a command
:r ![COMMAND] - read output of a command'
}



main() {
    case $1 in
        -h|--help) trap : EXIT; usage;;
        -k|--keys) trap : EXIT; keys;;
        -v|--version) echo "$version"; exit;;
        *) keyboard_loop "$1";;
    esac
}

main "$@"
;;
view)
#!/usr/bin/env bash
### SETTINGS ###
# this is what TAB will insert.
# default value is "  ". possible values are any string.
tabchar="	"

# auto tab with bim_insert, bim_backinsert, or when ENTER is pressed in insert mode.
# default value is "0". possible values are 0 or 1.
autotab="0"
line=0
base=1
version="bashbox vi (bim)"
message="welcome to vi"
unsaved_changes=0

declare -a buffer
declare -i line base
declare file version message
bind 'set disable-completion on' 2>/dev/null
shopt -s checkwinsize; (:)
trap refresh WINCH ALRM
trap cleanup EXIT INT HUP USR1

split() {
   # Usage: split "string" "delimiter"
   # thanks dylan araps :)
   IFS=$'\n' read -d "" -ra arr <<< "${1//$2/$'\n'}"
}

keybinds() {
            case "${key}" in
            
                # motions
                k) bim_up 1;;
                j) bim_down 1;;
                K) bim_up $((LINES - 4));;
                J) bim_down $((LINES - 4));;
                g) bim_bof;;
                G) bim_eof;;
                t) cursor show
                   bim_goto "$(misc_prompt "goto: ")"
                   cursor hide
                   ;;
                
                # editing
                a|i) bim_edit;;
                I) bim_prepend;;
                d) bim_delete;;
                c) bim_clear;;
                o) bim_insert;;
                O) bim_backinsert;;
                n) bim_blank 1; bim_down 1;;
                N) bim_backblank 1;;
                y) bim_yank;;
                p) bim_paste; bim_down 1;;
            
                # misc
                :) bim_prompt;;
                z) bim_center;;
            
            esac
}
        
startup() {
    cursor hide
    cursor spos
    cursor nowrap
    cursor block
}

cleanup() {
    cursor show
    cursor rpos
    cursor goto $LINES 0
    cursor wrap
    cursor block
    exit 0
}

cursor() {
    case "$1" in
    save) printf "\e[?47h";;
    load) printf "\e[?47l";;
    spos) printf "\e7";;
    rpos) printf "\e8\e[B";;
    hide) printf "\e[?25l";;
    show) printf "\e[?25h";;
    goto) printf "\e[%s;%sf" "$2" "$3";;
    wrap) printf "\e[?7h";;
    nowrap) printf "\e[?7l";;
    #beam) printf "\e[5 q";;
    #block) printf "\e[1 q";;
    #underline) printf "\e[3 q";;
    esac
}
clear() {
	printf "\033c"
}
refresh() {
    clear
    #printf "\e[36m %s (%s Lines) %s %sx%s %s \e[m\n" \
        #"$file" "${#buffer[@]}" "$version" "$LINES" "$COLUMNS" "$base"
    for ((i=base; i-base < LINES-2; i++)); do
        ((i !=  line))        && printf "\e[93m"     || printf "\e[31;1m"
        ((i > ${#buffer[@]})) && printf "   ~\e[m\n" || printf "%4s\e[m %s\n" "$i" "${buffer[i]}"
    done
    if [ "$message" ]; then
        printf "\e[32;1m%s\e[m\n" "$message"
    else
        printf "\e[36;1m%s [%s] %s/%s {%sx%s}\e[m\n" \
            "$version" "${file}" "$line" "${#buffer[@]}" "$LINES" "$COLUMNS"
    fi
}

bim_read() {
    if [ "$1" ]; then
        file="$1"
    else
        message="expected argument [FILE]"
        return 1
    fi

    if [ -e "$file" ];then
        mapfile -t -O 1 buffer <"$file"
        message="Read ${#buffer[@]} lines from '$file'"
    else
        message="new file '$file'"
    fi

    [ ${#buffer[@]} -ne 0 ] && line=1
}

bim_write() {
    if [ "$1" ]; then
        myfile="$1"
    elif [ "$file" ]; then
        myfile="$file"
    else
        message="no file to write."
        return 1
    fi
    : >"$myfile"
    for wline in "${buffer[@]}"; do echo "$wline" >> "$myfile"; done
    message="Wrote ${#buffer[@]} lines to '$myfile'"   
    unsaved_changes=0
}

bim_up() {
    [ "$1" ] && num="$1" || num=1
    for ((i=0;i<$num;i++)); do
        ((line > 1))    && ((line--))
    done
}

bim_down() {
    [ "$1" ] && num="$1" || num=1
    for ((i=0;i<$num;i++)); do
        ((line < ${#buffer[@]})) && ((line++))
    done
}

bim_delete() {
    lineyank="${buffer[line]}"
    buffer=([0]="" "${buffer[@]:1:line-1}" "${buffer[@]:line+1}")
    unset "buffer[0]"
    ((line > ${#buffer[@]})) && ((line--))
    message="line cut."
    unsaved_changes=1
}

bim_insert() {
    buffer=([0]="" "${buffer[@]:1:line}" "" "${buffer[@]:line+1}")
    unset "buffer[0]"
    ((line++))
    # check if autotab is on and if the tab block we're extending starts with spaces
    if [ $autotab = 1 ] && [ "${buffer[line-1]::1}" = " " ]; then
        # wacky code to get the tab size of the last line
        local lasttab="${buffer[line-1]%${buffer[line-1]##* }}"
        # put in that same tab length to what we're going to edit
        buffer[line]="$lasttab"
    fi
    # I have no clue why this has to be "-4" here
    ((line > base+LINES-4))  && ((base++))
    bim_edit
}

bim_backinsert() {
    buffer=([0]="" "${buffer[@]:1:line-1}" "" "${buffer[@]:line}")
    unset "buffer[0]"
    # same code as 'bim_insert'
    if [ $autotab = 1 ] && [ "${buffer[line+1]::1}" = " " ]; then
        local lasttab="${buffer[line+1]%${buffer[line+1]##* }}"
        buffer[line]="$lasttab"
    fi
    bim_edit
}

bim_blank() {
    [ "$1" ] && num="$1" || num=1
    for ((i=0;i<$num;i++)); do
        buffer=([0]="" "${buffer[@]:1:line}" "" "${buffer[@]:line+1}")
        unset "buffer[0]"
    done
}

bim_backblank() {
    [ "$1" ] && num="$1" || num=1
    for ((i=0;i<$num;i++)); do
        buffer=([0]="" "${buffer[@]:1:line-1}" "" "${buffer[@]:line}")
        unset "buffer[0]"
    done
}

bim_yank() {
    lineyank="${buffer[line]}"
    message="line yanked."
}

bim_paste() {
    buffer=([0]="" "${buffer[@]:1:line}" "$lineyank" "${buffer[@]:line+1}")
    unset "buffer[0]"
}

bim_clear() {
    ((line == 0)) && return
    cursor goto $((line-base + 2)) 6
    buffer[line]=""
    unsaved_changes=1
}

# insert mode
# my new robust replacement for 'read' that goes character by character
bimput() { # <var> [starting string]
    # starting text of line
    local buf="$2"
    local ch=""
    cursor beam
    cursor show
    while true; do
        IFS='' read -s -n1 ch
        case "$ch" in
            "")
                bimputstatus="esc"
                break
                ;;
            # read -n1 seems to interpret ENTER as nothing
            "")
                bimputstatus="enter"
                break
                ;;
            # vscode is unable do display a backspace
            # but there is one between these quotes
            "")
                if [ "$buf" ]; then
                    buf="${buf%?}"
                    printf "\b \b"
                else
                    bimputstatus="backline"
                    break
                fi
                ;;
            "	")
                buf="${buf}${shiftwidth:="  "}"
                echo -n "${shiftwidth}"
                ;;
            *)
                buf="${buf}${ch}"
                printf "$ch"
                ;;
        esac
    done
    eval "${1}=\${buf}"
    cursor hide
    cursor block
}

bim_edit() {
    # refresh, as 'read' will freeze drawing
    refresh
    # make a line in an empty buffer
    ((line == 0)) && buffer[1]="" && line=1 && refresh
    # print '--INSERT--' at the bottom
    cursor goto $LINES
    printf "\e[32m%s\e[m" "--INSERT--"
    # do the actual thing
    cursor goto $((line-base + 1)) $((6 + ${#buffer[line]}))
    bimput "buffer[line]" "${buffer[line]}"
    case "$bimputstatus" in
        "enter")
            # nice and simple
            bim_insert
            ;;
        "backline")
            # delete line
            buffer=([0]="" "${buffer[@]:1:line-1}" "${buffer[@]:line+1}")
            unset "buffer[0]"
            # go back a line and edit
            ((line--))
            bim_edit
            ;;
    esac
    unsaved_changes=1
}

bim_prepend() {
    # refresh, as 'read' will freeze drawing
    refresh
    # make a line in an empty buffer
    ((line == 0)) && buffer[1]="" && line=1 && refresh
    # print '--INSERT--' at the bottom
    cursor goto $LINES
    printf "\e[32m%s\e[m" "--PREPEND--"
    # do the actual thing
    cursor goto $((line-base + 2)) 4
    printf "^~"
    cursor underline
    cursor show
    read -re
    cursor hide
    cursor block
    # write $REPLY + what was already there
    buffer[line]="${REPLY}${buffer[line]}"
    unsaved_changes=1
}

bim_prompt() {
    bind 'set disable-completion off' 2>/dev/null
    cursor show
    read -rep ":" choice
    bind 'set disable-completion on' 2>/dev/null

    # run command and wait
    if [ "${choice::1}" = "!" ]; then
        eval "${choice##!}"
        cursor hide
        printf "\e[31mpress any key to continue."
        read -N1 -r
    # read command output
    elif [ "${choice::3}" = "r !" ]; then
        eval "output=\"\$(${choice##r !})\""
        split "$output" $'\n'
        bim_blank ${#arr[@]}
        i=0
        while [ $i -lt ${#arr[@]} ]; do
            buffer[line+i+1]="${arr[i]}"
            unset "buffer[0]"
            ((i++))
        done
        cursor hide
        unsaved_changes=1
    # simply run command
    else
        eval "$choice"
        succ=$?
        if [ ! "$(type -t ${choice%% *})" = "function" ]; then
            message="finished with exit code $succ"
        fi
        cursor hide
    fi
    # cursor must be hidden in each case individually.
}

misc_prompt() {
    # cursor must be shown externally
    # as to not pass escape sequences into functions
    [ "$1" ] || return 1
    bind 'set disable-completion off' 2>/dev/null
    read -rep "$1"
    bind 'set disable-completion on' 2>/dev/null

    printf '%s' "$REPLY"
}

quit() {
    if [ "$unsaved_changes" = 0 ]; then
        exit 0
    else
        message="unsaved changes. force quit with \":q!\""
    fi
}

bim_bof() {
	[ ${#buffer[@]} = 0 ] && return 1
    line=1
}

bim_eof() {
    line=${#buffer[@]}
}

bim_goto() {
    [ "$1" ] || return 1
    [ ${#buffer[@]} -ge $1 ] && line=$1
}

bim_center() {
    (( base=line-((LINES-3)/2) ))
    [ $base -lt 1 ] && base=1
}

# functions that are really just aliases
# and shortcuts for the command line

w() {
    bim_write "$@"
}

q() {
    quit
}

q!() {
    exit 0
}
wq() {
    w "$@" && q
}

e() {
    bim_read "$@"
}


keyboard_loop () {
    startup
    [ "$1" ] && bim_read "$1"
    refresh

    while true; do
        read -rsN1 key
        message=""

        # iteration (only 2 digit numbers)
        # cancel with ESC
        case $key in
            1|2|3|4|5|6|7|8|9)
                digit1="$key"
                printf '%d' "$key"
                read -rsN1 key
                case $key in
                    1|2|3|4|5|6|7|8|9|0)
                        digit2="$key"
                        printf '%d' "$key"
                        read -rsN1 key
                        ;;
                    "")
                        digit1="1"
                        digit2=""
                        ;;
                    *)
                        digit2=""
                        ;;
                esac
                ;;
            "")
                digit1="1"
                digit2=""
                ;;
            *)
                digit1="1"
                digit2=""
                ;;
        esac

        # compute keys from rc or defaults
        # reiterate if applicable
        kbj="${digit1}${digit2}"
        for ((kbinc=0; kbinc < kbj; kbinc++)); do
            keybinds
        done

        # universal scrolling system
        if [ $base -gt $line ]; then
            [ $base = 1 ] || base=$line
        elif (( base+LINES-3 < line )); then
            ((base=line-LINES+3))
        fi

        # refresh the UI
        refresh
    done
    clear
}

usage () {
echo '
bim: bash vim

usage: ${0##*/} [ options | file ]

options:
    -h|--help : print this help message
    -k|--keys : print a basic usage document'
}

keys () {
echo '# navigation
  j - move down  (:bim_down [LINES])
  k - page up    (:bim_up [LINES])
  J - page down
  K - page up
  g - first line (:bim_bof)
  G - last line  (:bim_eof)
  t - go to line (:bim_goto [LINE])

# editing
  a - append to line  (:bim_edit)
  I - prepend to line (:bim_prepend)
  d - delete line     (:bim_delete)
  c - clear line      (:bim_clear)
  y - yank line       (:bim_yank)
  p - paste line      (:bim_paste)
  n - create line below (:bim_blank [LINES])
  N - create line above (:bim_backblank [LINES])
  o - create line below and edit (:bim_insert)
  O - create line above and edit (:bim_backinsert)

# commands
# NOTE: the command line is for both editor and shell commands.
   : - open command line
  :w [FILE] - write to current or given file
  :q - quit
 :q! - force quit
 :wq - write and quit
  :e [FILE] - open file
  :![COMMAND] - pause to view the output of a command
:r ![COMMAND] - read output of a command'
}



main() {
    case $1 in
        -h|--help) trap : EXIT; usage;;
        -k|--keys) trap : EXIT; keys;;
        -v|--version) echo "$version"; exit;;
        *) keyboard_loop "$1";;
    esac
}

main "$@"
;;
watch)
#!/bin/bash
waittime=2 #default
waitsleep(){
	if [ -z "$1" ]; then
	  echo "watch: waitsleep: amount of time to sleep not provided"
	  exit
	fi
	read -d "" -rt "$1"
}
printhelp(){
	echo "usage: waittime [ -n | -h -v ] [time] cmd"
}
[ -n "$WATCH_INTERVAL" ] && waittime="$WATCH_INTERVAL"
case "$1" in
	-n|--interval)waittime="$2"; shift 2;;
	-h|--help)printhelp; exit;;
esac
while true
do
	printf "\033c"
	$@
	sleep "$waittime"
done
;;
wc)
#!/usr/bin/env bash
#
# wc in pure bash.

while getopts "lcw" opt; do
    case $opt in
        l) lines=1 ;;
        c) bytes=1 ;;
        w) words=1 ;;

        ?)
            printf '%s\n' "error: -$OPTARG not a valid option." >&2
            exit 1
        ;;
    esac
done

[[ -t 0 && -f ${*: -1} ]] &&
    file=${*: -1}

[[ -t 0 && ! -f $file ]] && {
    printf '%s\n' "wc: ${file:-null}: No such file or directory." >&2
    exit 1
}

mapfile file_data < "${file:-/dev/stdin}"

for line in "${file_data[@]}"; do
    read -ra line_split <<< "$line"
    ((splits+=${#line_split[@]}, chars+=${#line}))
done

[[ -z $lines && -z $bytes && -z $words ]] &&
    ((lines=1, bytes=1, words=1))

[[ $lines ]] && printf '%s ' "${#file_data[@]}"
[[ $words ]] && printf '%s ' "$splits"
[[ $bytes ]] && printf '%s ' "$chars"

printf '%s\n' "$file"
;;
which)
#!/bin/bash
which $@
;;
whoami)
#!/usr/bin/env bash
#
# whoami in pure bash.

echo "$USER"
;;
yes)
#!/usr/bin/env bash
#
# yes in pure bash.

if [[ "$1" ]]; then
    for ((;;)); {
        printf '%s\n' "$1"
    }
else
    for ((;;)); {
        printf y\\n
    }
fi
;;
*)
echo arch at bano base16 base64 basename bashbox-create bc bf cat chr clear colors colors256 command cp curl cut date dialog dir dirname ebashs echo ed emacs env exec expand expr exprf factor false figlethd find findfast free ftype getlines getopt grep hd head hextorgb hostname kill less locale logname lolcat lowercase ls lscpu makewords man more nano nl nosj od ord ping pr print printenv printf ps pwd pwdx readlink readsyntax realpath rev rgbtohex sed seq sh sha256sum sha512 sleep stat strip syntax tac tail tee time timeout top touch tput true truecolors ttysize type uidname uname uniq uppercase uptime vdir vi view watch wc which whoami yes
;;
esac
